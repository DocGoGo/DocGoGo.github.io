<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux-RHCE-124-第五章节 | 欢迎来到李维虎的在线博客</title><meta name="author" content="李维虎"><meta name="copyright" content="李维虎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="管理本地用户和组什么是用户？​	用户账户在可以运行命令的不同人员和程序之间提供安全界限。 ​	用户使用用户名想人类用户标识自己并加强操作的便利性。在内部，系统通过分配的唯一标识号（用户ID或UID）来区分不同的用户账户。在大多数情况下，如果有人使用用户账号，则系统会位改用户分配一个机密密码，以证明他们是登录的授权用户。 ​	用户账户构成了系统安全的基础。系统中的每个进程（运行的程序）都作为一个特定">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-RHCE-124-第五章节">
<meta property="og:url" content="http://example.com/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="欢迎来到李维虎的在线博客">
<meta property="og:description" content="管理本地用户和组什么是用户？​	用户账户在可以运行命令的不同人员和程序之间提供安全界限。 ​	用户使用用户名想人类用户标识自己并加强操作的便利性。在内部，系统通过分配的唯一标识号（用户ID或UID）来区分不同的用户账户。在大多数情况下，如果有人使用用户账号，则系统会位改用户分配一个机密密码，以证明他们是登录的授权用户。 ​	用户账户构成了系统安全的基础。系统中的每个进程（运行的程序）都作为一个特定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/doc_img/RHCE_cover.jpeg">
<meta property="article:published_time" content="2025-04-03T08:42:14.000Z">
<meta property="article:modified_time" content="2025-05-20T09:21:25.917Z">
<meta property="article:author" content="李维虎">
<meta property="article:tag" content="RHCE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/doc_img/RHCE_cover.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux-RHCE-124-第五章节",
  "url": "http://example.com/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/",
  "image": "http://example.com/img/doc_img/RHCE_cover.jpeg",
  "datePublished": "2025-04-03T08:42:14.000Z",
  "dateModified": "2025-05-20T09:21:25.917Z",
  "author": [
    {
      "@type": "Person",
      "name": "李维虎",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/index_img/logo.png"><link rel="canonical" href="http://example.com/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux-RHCE-124-第五章节',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/doc_img/RHCE_cover.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/index_img/butterfly-icon.png" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">Linux-RHCE-124-第五章节</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux-RHCE-124-第五章节<a class="post-edit-link" href="null_posts/01-RHCE/01-124/Linux-RHCE-124-第五章节.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-03T08:42:14.000Z" title="发表于 2025-04-03 16:42:14">2025-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-20T09:21:25.917Z" title="更新于 2025-05-20 17:21:25">2025-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RHCE/">RHCE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="管理本地用户和组"><a href="#管理本地用户和组" class="headerlink" title="管理本地用户和组"></a>管理本地用户和组</h1><h2 id="什么是用户？"><a href="#什么是用户？" class="headerlink" title="什么是用户？"></a>什么是用户？</h2><p>​	用户账户在可以运行命令的不同人员和程序之间提供安全界限。</p>
<p>​	用户使用用户名想人类用户标识自己并加强操作的便利性。在内部，系统通过分配的唯一标识号（用户ID或UID）来区分不同的用户账户。在大多数情况下，如果有人使用用户账号，则系统会位改用户分配一个机密密码，以证明他们是登录的授权用户。</p>
<p>​	用户账户构成了系统安全的基础。系统中的每个进程（运行的程序）都作为一个特定用户运行。每个文件都有一个特定用户作为其所有者。借助文件所有权，系统可以对文件的用户实施访问控制。与运行进程相关联的用户可确定该进程可访问的文件和目录。</p>
<p>​	用户账户有以下三种主要类型：超级用户、系统用户和普通用户。</p>
<ul>
<li>超级用户账户负责管理系统。超级用户的名称为root，其账户的UID为0.超级用户具有完全的系统访问权限。</li>
<li>系统用户账户提供支持服务进程使用。这些进程（或守护进程）通常不需要以超级用户身份运行。系统会为它们分配非特权账户，确保其文件和其他资源不受彼此以及系统上普通用户的影响。用户无法使用系统用户账户以交互式登录。</li>
<li>大多数用户都有用于日常工作的普通用户账户。与系统用户一样，普通用户对系统具有有限的访问权限。</li>
</ul>
<p>​	使用id命令可显示有关当前已登录用户的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	要查看有关其他用户的基本信息，请将用户作为参数传递给id命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">id</span> redhat01 </span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01)</span><br><span class="line">[kiosk@foundation0 home]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ls -l命令可查看文件的所有者。使用ls -ld命令可查看目录的所有者，而不是该目录的内容。在以下出书中，第三列显示所有者的用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l test1.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk 1 Mar  6 16:46 test1.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld Music/</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk 6 Feb  1  2023 Music/</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ps命令可查看进程信息。默认为仅显示当前shell中的进程。使用ps命令-a选项可查看与某一终端相关的所有进程。使用ps命令-u选项可查看与进程关联的用户。在以下输出中，第一列显示用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps -au</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">kiosk       2342  0.0  0.0 374120  5872 tty2     Ssl+ 14:28   0:00 /usr/libexec/gdm-wayland-session --register-s</span><br><span class="line">kiosk       2352  0.0  0.1 521392 19632 tty2     Sl+  14:28   0:00 /usr/libexec/gnome-session-binary</span><br><span class="line">kiosk       3200  0.0  0.0 224212  5800 pts/0    Ss+  14:29   0:00 bash</span><br><span class="line">kiosk       4447  0.0  0.0 224228  5768 pts/6    Ss   14:35   0:00 -bash</span><br><span class="line">kiosk       4918  1.5  0.0 224096  5556 pts/7    Ss+  15:13   0:00 -bash</span><br><span class="line">kiosk       4952  0.0  0.0 225500  3648 pts/6    R+   15:13   0:00 ps -au</span><br></pre></td></tr></table></figure>

<p>​	以上命令输出按名称显示用户名，但操作系统内部利用UID来跟踪用户。用户名到UID的映射在账户信息数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;passwd文件存储有关本地用户的信息。</p>
<p>​	&#x2F;etc&#x2F;passwd文件的每一行都包含了有关某个用户的信息。该文件划分为7个以上的冒号分割的字段。以下是来自&#x2F;etc&#x2F;passwd行的示例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">redhat01:x:1001:1001:User One:/home/redhat01:/bin/bash</span><br></pre></td></tr></table></figure>

<p>​	代码块的每个部分，用冒号分割</p>
<ul>
<li>redhat01：此为用户的用户名</li>
<li>x：用户的加密密码历来存储在这里；但在此是一个占位符。</li>
<li>1001：此用户账户的UID编号</li>
<li>1001：此用户账户的主要组的GID编号。本章节稍后将对组进行讨论</li>
<li>User One：此用户的简短注释、描述或真实姓名等。</li>
<li>&#x2F;home&#x2F;redhat01：用户的主目录，以及登录shell启动时的初始工作目录。</li>
<li>&#x2F;bin&#x2F;bash：此用户的默认shell程序，在登陆时运行，一些账户使用&#x2F;sbin&#x2F;nologin shell来禁止该用户使用交互式登录。</li>
</ul>
<h2 id="什么是组"><a href="#什么是组" class="headerlink" title="什么是组"></a>什么是组</h2><p>​	组是需要共享文件和其他系统资源访问权限的用户集合。组可用于向一组用户授予文件访问权限，而非向一个用户授予访问权限。</p>
<p>​	与用户一样，组也具有组名以便识别。在内部，系统通过分配的唯一标识号（组ID或GID）来区分不同的组。组名到GID映射在组账户信息身份管理数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;group文件存储有关本地组的信息。</p>
<p>​	&#x2F;etc&#x2F;group文件的每行都包含了有关某个组的信息。每个组条目被分为四个以冒号分割的字段。以下来自&#x2F;etc&#x2F;group行的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...忽略...</span><br><span class="line">redhat01:x:1001:user01,user02</span><br></pre></td></tr></table></figure>

<p>​	考虑代码块的每个部分用冒号分割：</p>
<ul>
<li>redhat01：此组的名称</li>
<li>x：以前的组密码字段；现在是一个占位符。</li>
<li>1001：此组的GID编号。</li>
<li>user01,user02：属于此组成员的用户列表，作为一个补充组。</li>
</ul>
<h2 id="主要组和补充组"><a href="#主要组和补充组" class="headerlink" title="主要组和补充组"></a>主要组和补充组</h2><p>​	每一个用户有且只有一个主要组。对于本地用户而言，这个组按照GID列在&#x2F;etc&#x2F;passwd文件中。主要组拥有用户创建的文件。</p>
<p>​	在创建普通用户时，会创建一个与用户名同名的组，作为该用户的主要组。该用户是这个私有组的唯一成员。这种组成员资格设计简化了文件权限的管理，默认为区隔不同的用户组。</p>
<p>​	用户还可以拥有多个补充组。补充组中的成员资格存储在&#x2F;etc&#x2F;group文件中。根据所在组身份具有访问权限，将授予用户对文件的访问权限，不论这些组是主要组还是补充组。例如，如果user01用户有一个主要组user01以下两个补充组wheel和webadmin，那么该用户就可以读取这三个组中任何一个组，有权读取的文件。</p>
<p>​	id命令可以显示用户的组成员资格。在以下示例中，kiosk用户具有组kiosk作为自己的主要组（gid）。groups项列出此用户的所以组成员资格，而且用户还具有libvirt组作为补充组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="获取超级用户访问权限"><a href="#获取超级用户访问权限" class="headerlink" title="获取超级用户访问权限"></a>获取超级用户访问权限</h1><h2 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h2><p>​	大多数操作系统具有一个超级用户，该用户拥有系统的全部权限。在红帽Linux中，此为root用户。此用户的特权高于文件系统上的一般特权，您可以使用它来管理系统。若要执行诸如安装或删除软件以及管理系统文件和目录任务，必须将特权升级到root用户。</p>
<p>​	通常，普通用户中只有root用户才能控制大部分设备，但也有一些例外。例如，普通用户可以控制可移动设备，如USB设备。因此，虽然普通用户可以添加和删除文件并可管理可移动的设备，但默认情况下，只有root用户才能管理硬盘。</p>
<p>​	尽管如此，这种无限制的特权也带来了职责问题。root用户拥有足以破坏系统的无限制特权：删除文件和目录、删除用户账户，以及添加后门等。一旦root用户账户被盗，系统将处于危险之中，您也可能会失去管理控制。红帽建议系统管理员始终以普通用户身份登录，仅在需要时升级到root用户特权。</p>
<p>​	Linux上root账户大致相当于Windows上的本地Admininstrator账户。在Linux中，大多数系统管理员都作为无特权的用户登录，然后使用特种工具临时获得root特权。</p>
<p>​	<code>警告：Windows用户可能熟悉以本地Administrator用户身份登录以执行系统管理员职责的做法。如今不建议这样做，用户通过Administrator组中的成员资格来获取执行管理的特权。RHEL中同样如此，红帽建议系统管理员不要直接以root身份登录。取而代之，系统管理员以普通用户身份登录，然后使用其他机制（例如：su、sudo或policykit）临时获得超级用户特权。</code></p>
<h2 id="切换用户账户"><a href="#切换用户账户" class="headerlink" title="切换用户账户"></a>切换用户账户</h2><p>​	通过使用su命令，用户可以切换至另一个用户账户。如果从普通用户账户运行su命令并将另一用户账户作为参数，则必须提供要切换到的用户账户密码。以root用户身份运行su时，则无需输入用户密码。</p>
<p>​	本示例从kiosk账户运行su命令来切换到redhat01账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ su redhat01</span><br><span class="line">Password: <span class="comment"># redhat01的密码</span></span><br><span class="line">[redhat01@foundation0 kiosk]$ <span class="built_in">id</span></span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[redhat01@foundation0 kiosk]$</span><br></pre></td></tr></table></figure>

<p>​	如果省略用户名作为su命令的参数，则默认情况下su 或 su - 命令会尝试切换到root。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[redhat01@foundation0 kiosk]$ su -</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Apr  3 18:01:23 CST 2025 on pts/6</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	命令su将启动非登录shell，而命令su - （带有短划线选项）会启动登录shell。两个命令的主要区别在于，su - 会将shell环境变量设置为如同该用户身份重新登录一样，而su以该用户身份启动shell，但使用的是原始用户环境变量设置。</p>
<p>​	<code>注意：su命令最常用于获得另一个用户身份（通常root）运行的命令行界面（shell提示符）。但是，您还可以通过su命令结合-c选项，以另一个用户身份运行任意程序。具体su命令更多选项可通过man su(1)查看</code></p>
<h2 id="通过sudo运行命令"><a href="#通过sudo运行命令" class="headerlink" title="通过sudo运行命令"></a>通过sudo运行命令</h2><p>​	出于安全原因，在某些情况下，系统管理员会将root用户配置为没有有限的密码。因此，用户无法使用密码直接以root身份登录系统。此外，您也无法使用su来获取交互式shell。在这种情况下，您可以使用sudo命令来获取root访问权限。</p>
<p>​	与su命令不同，sudo通常要求用户输入自己的密码以进行身份验证，而不是输入他们正尝试访问的用户账户的密码。也就是说，用户使用sudo命令以root身份运行命令时，是不需要知道root密码。相反，他们将使用自己的密码来验证访问权限。</p>
<p>​	下表总结了su、su - 和sudo命令之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>su</th>
<th>su -</th>
<th>sudo</th>
</tr>
</thead>
<tbody><tr>
<td>成为新用户</td>
<td>是</td>
<td>是</td>
<td>权限升级的命令</td>
</tr>
<tr>
<td>环境</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>需要密码</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>特权</td>
<td>与新用户相同</td>
<td>与新用户相同</td>
<td>有配置定义</td>
</tr>
<tr>
<td>记录的活动</td>
<td>仅su命令</td>
<td>仅su命令</td>
<td>权限升级的命令</td>
</tr>
</tbody></table>
<p>​	此外，您可以将sudo配置为允许特定用户像某个其他用户一样运行任何命令，或仅允许以该用户是否允许部分命令。例如，如果您将sudo命令配置为允许redhat01用户以root身份允许usermod命令，那么您可以允许一下命令来锁定或解锁用户账户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> usermod -L redhat01 </span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[kiosk@foundation0 home]$ su - redhat01 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br><span class="line">[kiosk@foundation0 home]$</span><br></pre></td></tr></table></figure>

<p>​	如果某用户尝试以另一用户身份允许命令，但sudo配置不允许，则bash会阻止该命令，记录这次尝试，并向root发送一封邮件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> -f /var/log/secure</span><br><span class="line">Apr 17 15:53:04 foundation0 su[2569]: pam_unix(su-l:auth): authentication failure; <span class="built_in">logname</span>=kiosk uid=1000 euid=0 <span class="built_in">tty</span>=/dev/pts/0 ruser=kiosk rhost=  user=redhat01</span><br></pre></td></tr></table></figure>

<p>​	sudo的另一个好处是默认将所有执行的命令记录到&#x2F;var&#x2F;log&#x2F;secure中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# tail -f /var/log/secure</span><br><span class="line">Apr 17 15:50:06 foundation0 sudo[2373]:   kiosk : command not allowed ; TTY=pts/0 ; PWD=/home ; USER=root ; COMMAND=/sbin/usermod -L redhat01</span><br></pre></td></tr></table></figure>

<p>​	在红帽Linux中，wheel组所有成员都可以使用自己的密码通过sudo以任何用户身份允许命令，包括root在内</p>
<h2 id="通过Sudo获取交互式Root-Shell"><a href="#通过Sudo获取交互式Root-Shell" class="headerlink" title="通过Sudo获取交互式Root Shell"></a>通过Sudo获取交互式Root Shell</h2><p>​	要通过sudo访问root账户，请使用sudo -i命令。此命令将切换root账户并运行该用户的默认shell及关联的交互式登录脚本。要在没有交互式脚本的情况下运行shell，请使用sudo -s命令。</p>
<p>​	例如，管理员可以获取kiosk实例上root用户的交互式shell，方法是使用SSH公钥身份验证作为普通用户kiosk登录，在运行sudo -i命令获取root用户的shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> -i</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="配置Sudo"><a href="#配置Sudo" class="headerlink" title="配置Sudo"></a>配置Sudo</h2><p>​	&#x2F;etc&#x2F;sudoers文件是sudo命令的主要配置文件。如果多个管理员试图编辑该文件，为了避免出现问题，您只能特殊的visudo命令进行编辑。visudo编辑器也会验证该文件，确保没有语法错误。</p>
<p>​	例如，以下来自&#x2F;etc&#x2F;sudoers文件的这一行可为wheel组成员启用sudo访问权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>

<ul>
<li>%wheel字符串是规则所应用到的用户或组。词语wheel前的%符号指定该是对一个组进行权限的设置。</li>
<li>ALL&#x3D;(ALL:ALL)命令指定在具有此文件的任何主机上（第一个ALL），wheel组中的用户可以在系统上以任何其他用户（第二个ALL）和任何其他组（第三个ALL）运行命令。</li>
<li>最后的ALL命令指定wheel组中的用户可以运行任何命令。</li>
</ul>
<p>​	默认情况下，&#x2F;etc&#x2F;sudoers文件还包含&#x2F;etc&#x2F;sudoers.d目录中所有文件的内容，作为配置文件的一部分。通过使用这种层次结构，您只需将相应的文件放入该目录中，即可为用户添加sudo访问权限。</p>
<p>​	<code>注意：将配置文件放在/etc/sudoers.d目录下比较方便。将文件复制到目录中或从目录中删除文件，即可启用或禁用sudo访问权限。通常每个文件都会以用户或组来进行命名，当要启用或是禁用时，只需将文件在该目录中复制或删除即可。避免一个文件长篇大论，难以维护</code></p>
<p>​	要为redhat01用户启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;redhat01文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /etc/sudoers.d/redhat01 </span><br><span class="line">redhat01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要为group01组启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;group01文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/group01</span><br><span class="line">%group01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要使games组中的用户能够以operator用户身份运行id命令，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;games文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/games</span><br><span class="line">%games ALL=(operator) /bin/id</span><br></pre></td></tr></table></figure>

<p>​	此外，也可以设置sudo，以允许用户通过使用NOPASSWD:ALL命令在不输入密码的前提下以其他用户身份允许命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/ansible</span><br><span class="line">%ansible ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p>​	虽然授权用户或组这种级别的访问权限存在明显的安全风险，但系统会将这种做法用于云实例、虚拟机和调配系统，以配置服务器。您必须谨慎地保护具有此访问权限的账户，并且要求使用SSH公钥身份验证，以便远程系统上的用户能访问它。</p>
<h1 id="管理本地用户账户"><a href="#管理本地用户账户" class="headerlink" title="管理本地用户账户"></a>管理本地用户账户</h1><h2 id="从命令行创建用户"><a href="#从命令行创建用户" class="headerlink" title="从命令行创建用户"></a>从命令行创建用户</h2><p>​	useradd username命令可以创建名为username的用户。它会设置用户的主目录和账户信息，并为名为username的用户创建一个私有组。此时，该账户尚未设置有效密码，用户也要设置了密码后才能登录。</p>
<p>​	useradd –help 命令将显示可用于覆盖默认设置的基本选项。大多数情形中，您可以将相同的选项用于usermod命令，以修改现有用户。</p>
<p>​	在红帽linux9中，useradd命令为新用户分配的第一个大于或等于1000的可用UID，除非您通过-u选项进行明确指定。</p>
<h2 id="从命令行修改现有的用户"><a href="#从命令行修改现有的用户" class="headerlink" title="从命令行修改现有的用户"></a>从命令行修改现有的用户</h2><p>​	usermod –help命令显示用于修改账户的基本选项。一些常见的选项如下：</p>
<table>
<thead>
<tr>
<th>usermod选项</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>-a，–append</td>
<td>与-G选项一起使用，将补充组添加到用户当前的组成员集合中，而不是将补充组集合替换为新的集合。</td>
</tr>
<tr>
<td>-c，–comment COMMENT</td>
<td>将COMMENT文本添加到注释字段。</td>
</tr>
<tr>
<td>-d，–home HOME_DIR</td>
<td>为用户账户指定一个主目录。</td>
</tr>
<tr>
<td>-g， –gid GROUP</td>
<td>为用户账户指定主要组。</td>
</tr>
<tr>
<td>-G，–groups GROUPS</td>
<td>为用户账户指定补充组，多个补充组用逗号分割列表。</td>
</tr>
<tr>
<td>-L， –lock</td>
<td>锁定用户账户。</td>
</tr>
<tr>
<td>-m，–move-home</td>
<td>将用户的主目录移送到新的位置。您必须将它于-d选项搭配使用。</td>
</tr>
<tr>
<td>-s，–shell SHELL</td>
<td>为用户账户指定特定的登录shell。</td>
</tr>
<tr>
<td>-U，–unlock</td>
<td>解锁用户账户。</td>
</tr>
</tbody></table>
<h2 id="从命令行删除用户"><a href="#从命令行删除用户" class="headerlink" title="从命令行删除用户"></a>从命令行删除用户</h2><p>​	userdel username 命令从&#x2F;etc&#x2F;passwd中删除用户的详细信息，但用户的主目录保持不变。userdel -r username 命令从&#x2F;etc&#x2F;passwd 中删除用户，同时删除用户的主目录。</p>
<p>​	<code>警告：如果您在不指定userdel -r 选项的情况下删除用户，则用户的文件归为未分配的UID所有。如果您创建了一个用户，并且该用户被分配了已删除用户的UID，则新账户将用有这些文件，这存在安全风险。通常，组织安全策略不允许删除用户账户，而是锁定它们不被使用，以避免这种情况。</code></p>
<p>​	以下示例演示了这如何导致信息泄露：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 kiosk]# useradd user01</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3 user01   user01     78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">[root@foundation0 ~]# userdel user01 </span><br><span class="line"><span class="comment"># 为加-r选项，此时用户的主目录处于未分配状态，他之前所属用户UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 创建用户，-u 指定该用户的UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user02</span><br><span class="line"><span class="comment"># 由于于之前的user01的UID一致，user01的主目录则自动归属为user02</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 10:57 user01</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 11:02 user02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>请注意，user02现在拥有之前归为user01所属的所有文件。root用户可以使用find / -nouser -o -nogroup 命令来查找无人拥有的文件和目录。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# userdel user02 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 11:02 user02</span><br><span class="line"><span class="comment"># nouser表示没有归属用户的条件，nogroup表示没有归属用户的组，-o选项表示【或】的意思，用于多个条件的拼接</span></span><br><span class="line">[root@foundation0 ~]# find / -nouser -o -nogroup </span><br><span class="line">...忽略...</span><br><span class="line">/home/user01/.mozilla</span><br><span class="line">/home/user01/.mozilla/extensions</span><br><span class="line">/home/user01/.mozilla/plugins</span><br><span class="line">/home/user01/.bash_logout</span><br><span class="line">/home/user01/.bash_profile</span><br><span class="line">/home/user01/.bashrc</span><br><span class="line">/home/user02</span><br><span class="line">....忽略....</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="从命令行设置密码"><a href="#从命令行设置密码" class="headerlink" title="从命令行设置密码"></a>从命令行设置密码</h2><p>​	passwd username 命令可为username用户设置初始密码，或更改其现有密码。root用户可以将密码设置为任何值。如果密码不符合最低建议标准，终端会显示消息；不顾哦，之后您可以重新键入该新密码，passwd也会成功更新该密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user01</span><br><span class="line">useradd: warning: the home directory /home/user01 already exists.</span><br><span class="line">useradd: Not copying any file from skel directory into it.</span><br><span class="line">Creating mailbox file: File exists</span><br><span class="line"><span class="comment"># 为用户设置初始密码，密码：123456，虽会提示密码过于简单，未通过字典检查，但再次确认密码后任然可以成功设置。</span></span><br><span class="line">[root@foundation0 home]# passwd user01 </span><br><span class="line">Changing password <span class="keyword">for</span> user user01.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	<code>建议普通用户必须选择至少八个字符长的密码。不要使用字典词语、用户名或旧密码。</code></p>
<h2 id="UID范围"><a href="#UID范围" class="headerlink" title="UID范围"></a>UID范围</h2><ul>
<li>UID 0：超级用户(root)账户UID。</li>
<li>UID 1-200：静态分配给系统进程的系统账户UID。</li>
<li>UID 201-999：分配给不拥有此系统上文件的系统进程的UID。需要非特权UID的软件将从这个可用池中动态分配UID。</li>
<li>UID 1000+：分配给普通非特权用户的UID范围。</li>
</ul>
<p>注意：RedHat6及更早的版本对系统用户使用的范围1-499的UID，对普通用户使用高于500的UID。您可以在&#x2F;etc&#x2F;login.defs文件中更改useradd和groupadd默认范围。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250513112428467.png" alt="image-20250513112428467"></p>
<h1 id="管理本地组账户"><a href="#管理本地组账户" class="headerlink" title="管理本地组账户"></a>管理本地组账户</h1><h2 id="从命令行创建组"><a href="#从命令行创建组" class="headerlink" title="从命令行创建组"></a>从命令行创建组</h2><p>​	groupadd命令用于创建组。不带选项时，groupadd命令会使用&#x2F;etc&#x2F;login.defs文件中通过GID_MIN和GID_MAX 变量指定的范围内的下一个可用GID。默认情况下，该命令分配的GID值大于任何其他现有的GID，即使有较低的值可用。</p>
<p>​	groupadd 命令 -g选项指定该组使用的特定GID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# groupadd -g 10000 group1</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">....忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：由于创建用户时会自动为该用户生成一个私有组（GID 1000+），一些管理员会留出了一个单独的GID范围，用于创建补充组来满足其目的。但是，这种额外的管理是不必要的，因为用户的UID和主要组GID是不需要是相同的数字。</code></p>
<p>​	groupadd 命令 -r 选项用于创建系统组。与普通一样，系统组使用&#x2F;etc&#x2F;login.defs文件中列出的有效系统GID范围内的GID。&#x2F;etc&#x2F;login.defs文件中的SYS_GID_MIN和SYS_GID_MAX配置项定义系统GID的范围。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group2:x:976:</span><br></pre></td></tr></table></figure>



<h2 id="从命令行修改现有的组"><a href="#从命令行修改现有的组" class="headerlink" title="从命令行修改现有的组"></a>从命令行修改现有的组</h2><p>​	groupmod 命令可以更改现有组的属性。groupmod命令-n选项可指定组的新名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -n group002 group2 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:976:</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	注意组名称从group2更改为group002，groupmod命令-g选项可更改GID</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -g 975 group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:975:</span><br></pre></td></tr></table></figure>

<p>​	注意GID从原来的976变更为975.</p>
<h2 id="从命令行删除组"><a href="#从命令行删除组" class="headerlink" title="从命令行删除组"></a>从命令行删除组</h2><p>​	groupdel 命令可删除组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# groupdel group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：如果删除的组是现有用户的主要组，则您无法删除它。于使用userdel命令类似，首先检查以确保找到该组拥有的文件，避免信息泄露</code></p>
<h2 id="从命令行更改组成员资格"><a href="#从命令行更改组成员资格" class="headerlink" title="从命令行更改组成员资格"></a>从命令行更改组成员资格</h2><p>​	组成员资格通过用户管理进行控制。使用usermod -g命令来更改用户的主要组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01)</span><br><span class="line">[root@foundation0 home]# usermod -g group01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	使用usermod -aG命令，将用户太你家到某一补充组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# usermod -aG user01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01)</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：usermod命令的-a选项可启用附加模式。不带-a选项时，命令会从当前未包含在 -G 选项列表中的任何补充组从该用户中删除。</code></p>
<h2 id="比较主要组和补充组成员资格"><a href="#比较主要组和补充组成员资格" class="headerlink" title="比较主要组和补充组成员资格"></a>比较主要组和补充组成员资格</h2><p>​	用户的主要组是在&#x2F;etc&#x2F;passwd文件中查看的用户账户和组。一个用户一次只能属于一个主要组。</p>
<p>​	用户的补充组是为用户配置的额外组，可在&#x2F;etc&#x2F;group文件中的用户条目中查看。一个用户可以属于任意数量的补充组，以有效实施文件访问和权限。</p>
<p>​	对于配置基于组的文件权限而言，用户的主要组和补充组之间没有区别。如果用户所属的组被分配了特定文件的访问权限，则该用户有权访问这些文件。</p>
<p>​	用户的主要组和补充组成员资格之间唯一的区别体现在用户创建文件时。新文件必须具有用户所有者和组所有者，这是在文件创建时分配的。用户的主要组用于新文件的组所有权，除非被选项命令覆盖。</p>
<h2 id="临时更改您的主要组"><a href="#临时更改您的主要组" class="headerlink" title="临时更改您的主要组"></a>临时更改您的主要组</h2><p>​	只有用户的主要组才会用于新文件创建属性。但是，您可以暂时将主要组切换到另一个组，但只能从您所属的补充组中去选择。如果您要手动或以脚本方式创建多个新文件，并希望创建时将不通的组分配为所有者，则可以切换组。</p>
<p>​	在此shell会话中，使用newgrp命令来切换主要组。您可以在所属的任何主要组或补充组之间却换，但一次只能由一个组是主要组。如果您注销并重新登录，主要组将回复为默认值。此示例将user01用户中的补充组user01临时切换为主要组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[user01@foundation0 ~]$ newgrp </span><br><span class="line">group1  user01  </span><br><span class="line">[user01@foundation0 ~]$ newgrp user01 </span><br><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01),10000(group1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="管理用户密码"><a href="#管理用户密码" class="headerlink" title="管理用户密码"></a>管理用户密码</h1><h2 id="影子密码和密码策略"><a href="#影子密码和密码策略" class="headerlink" title="影子密码和密码策略"></a>影子密码和密码策略</h2><p>​	加密的密码最初存储在全局可读的&#x2F;etc&#x2F;passwd文件中。这曾认为是最妥善的，直到对加密密码的字典式攻击变得常见。加密后的密码已移至&#x2F;etc&#x2F;shadow文件，只有root用户可以读取该文件。</p>
<p>​	与&#x2F;etc&#x2F;passwd文件一样，每个用户在&#x2F;etc&#x2F;shadow文件中都有一个条目。&#x2F;etc&#x2F;shadow文件中的示例条目具有九个以冒号分割的字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redhat01:$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0:20195:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>​	以此代码块为例，每个字段用冒号分割：</p>
<ul>
<li>redhat01：用户账户名称。</li>
<li>$6$N4i94UcIEydv…省略：用户的加密密码，$6开头（SHA-512）加密。</li>
<li>20195：上次更改密码时间距离纪元的天数；纪元是UTC时区的1970-01-01。</li>
<li>0：自上次更改密码以来到用户可再次更改密码之前必须经过的最短天数。</li>
<li>99999：在密码过期之前不进行密码更改的最长天数。空字段表示密码永不过期，自最后一次修改密码截至多少天过期。</li>
<li>7：在密码过期前提前多少天警告用户。</li>
<li>空：自密码过期之日起，在账户自动锁定前能够活动的天数，宽限天数。</li>
<li>空：密码到期之日距离纪元的天数。空字段表示密码永不过期，密码过期天数。</li>
<li>空：保留字段，预留给未来使用。</li>
</ul>
<h2 id="加密密码的格式"><a href="#加密密码的格式" class="headerlink" title="加密密码的格式"></a>加密密码的格式</h2><p>​	加密密码字段中存储了三段信息：所用的哈希算法、salt及加密哈希值。每段信息由美元符号（$）字符分割。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0</span><br></pre></td></tr></table></figure>

<ul>
<li>$6：此密码所使用的哈希算法。6表示SHA-512,这是RedHat默认算法；1表示MD5，而5则表示SHA-256。</li>
<li>$N4i94UcIEydvTFzp：用于加密密码的salt；最初是随机选择的。</li>
<li>$pf9W0C4I6w4BFxyK&#x2F;ver…忽略：用户密码的加密后的哈希；将salt和未加密密码组合并加密，生成密码哈希。</li>
</ul>
<p>​	将salt与密码组合的主要原因是为了防止使用预先计算的密码哈希列表攻击。添加salt会改变生成的哈希值，使预先计算的列表毫无用处。如果攻击者获得了使用salt的&#x2F;etc&#x2F;shadow文件的副本，则它们需要通过暴力破解来猜测密码，这将花费更多的时间和精力。</p>
<h2 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h2><p>​	用户尝试登录时，系统在&#x2F;etc&#x2F;shadow文件中查询用户的条目，将用户的salt和键入的未加密密码组合，在使用制定的哈希算法加密组合。如何加密组合后的结果与已加密的哈希匹配，则用户键入了正确的密码。如果结果与已加密的密码不符合，则用户键入了错误的密码，登录尝试也会失败。这种方式允许系统半段用户是否键入了正确的密码，同时又不以用于登录的密码形式来存储密码。</p>
<h2 id="配置密码期限"><a href="#配置密码期限" class="headerlink" title="配置密码期限"></a>配置密码期限</h2><p>​	下图显示了相关的密码期限参数，可以通过chage命令对起调整实施密码期限策略。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250520145616305.png" alt="image-20250520145616305"></p>
<p>​	以下示例演示使用chage命令修改redhat01用户的密码策略。该命令定义密码修改间隔最短期限（-m）为0天，密码最长有效期（-M）为90天，警告期（-W）7天，以及过期后宽限（-I）14天后自动过期为不活动状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -m 0 -M 90 -W 7 -I 14 redhat01</span><br><span class="line">[root@foundation0 ~]# chage -l redhat01 </span><br><span class="line">Last password change					: Apr 17, 2025</span><br><span class="line">Password expires					: Jul 16, 2025</span><br><span class="line">Password inactive					: Jul 30, 2025</span><br><span class="line">Account expires						: never</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 90</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	假设您在RedHat上管理用户密码策略。user01用户是系统中的新用户，您要设置自定义密码期限策略。您希望将账户的到期之间设置为，即日起30天后到期，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> +%F</span><br><span class="line">2025-05-20</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F</span><br><span class="line">2025-06-19</span><br><span class="line">[root@foundation0 ~]# chage -E $(<span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F) user01</span><br><span class="line">[root@foundation0 ~]# chage -l user01 | grep <span class="string">&quot;Account expires&quot;</span></span><br><span class="line">Account expires						: Jun 19, 2025</span><br></pre></td></tr></table></figure>

<ul>
<li>使用date命令获取当前时间，并通过+%F选项，调整date命令输出的日期格式。</li>
<li>使用date命令的-d选项以及“+30 days”参数获取即日起30天后的日期，并转换日期格式。</li>
<li>使用chage命令的-E选项，将获得的截至日期作为参数赋予该选项。</li>
<li>使用chage命令的-l选项，并且通过grep命令筛选出命令输出结果中的“Account expires”行，最终查看user01用户的过期时间成功设置为30天后。</li>
</ul>
<p>​	几天后，您在&#x2F;var&#x2F;log&#x2F;secure日志文件中发现user01用户有一个奇怪的行为。用户尝试使用sudo与其他用户的文件交互。您怀疑用户可能忘记关闭在另一台计算机上工作时打开的ssh会话。您希望user01用户在下次登录时更改密码，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -d 0 user01 </span><br><span class="line">[root@foundation0 ~]# chage -l user01</span><br><span class="line">Last password change					: password must be changed</span><br><span class="line">Password expires					: password must be changed</span><br><span class="line">Password inactive					: password must be changed</span><br><span class="line">Account expires						: Jun 19, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	此时user01的密码策略中提示，用户必须修改密码的结果，下次用户登录时就必须要求修改密码了。</p>
<p>​	<code>注意：date命令可以计算未来的时间。-u选项报告UTC时间。</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# date -d &quot;+5 days&quot; -u +%F</span><br><span class="line">2025-05-25</span><br></pre></td></tr></table></figure>

<p>​	您可以在&#x2F;etc&#x2F;login.defs文件中更改默认密码期限配置。PASS_MAX_DAYS和PASS_MIN_DAYS选项分别设置密码的默认最长和最短期限。PASS_WARN_AGE设置密码的默认警告期限。默认密码期限策略中的任何更改都会影响更改后新创建的用户。现有用户继续使用就密码期限设置，而非新密码设置。</p>
<h2 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h2><p>​	您可以使用usermod命令来修改用户的账户到期日期。例如，usermod命令-L选项可锁定用户账户，并且该用户无法登录系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L user03</span><br><span class="line">[kiosk@foundation0 ~]$ su - user03 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br></pre></td></tr></table></figure>

<p>​	如果用户在特定日期从公司离职，您可以通过usermod命令锁定并使其到期。该日期必须是从1970-01-01的天开始算起，或者使用YYYY-MM-DD格式。以下示例中，usermod命令于2025-05-21锁定user03用户并使其过期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L -e 2025-05-21 user03 </span><br><span class="line">[root@foundation0 ~]# chage -l user03 </span><br><span class="line">Last password change					: May 20, 2025</span><br><span class="line">Password expires					: never</span><br><span class="line">Password inactive					: never</span><br><span class="line">Account expires						: May 21, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	账户锁定后，您可以防止用户使用密码向系统进行验证。简易使用此方法防止前员工访问账户。使用usermod命令-U选项可以重新启用账户的访问权限。</p>
<h2 id="非登录Shell"><a href="#非登录Shell" class="headerlink" title="非登录Shell"></a>非登录Shell</h2><p>​	nologin shell用作不打算以交互方式登录系统的用户账户的代替shell。从安全角度来看，在账户不需要登录系统时，禁止账户登录系统是一个明智的选择。例如，邮件服务器可能需要账户来存储邮件，需要密码供用户通过检索邮件所用的邮件客户端进行身份验证。用户不需要直接登录该系统。</p>
<p>​	这种情况的常用解决方案是将用户的登录shell设置为&#x2F;sbin&#x2F;nologin。如果用户试图直接登录系统，nologin shell将关闭该连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -s /sbin/nologin user03 </span><br><span class="line">[root@foundation0 ~]# su - user03</span><br><span class="line">Last login: Tue May 20 14:49:37 CST 2025 on pts/0</span><br><span class="line">Last failed login: Tue May 20 14:51:02 CST 2025 on pts/0</span><br><span class="line">There were 4 failed login attempts since the last successful login.</span><br><span class="line">This account is currently not available.</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：nologin shell可以防止以交互式使用系统，但不会阻止访问。如果用户使用密码进行身份验证，它们有时可以通过身份验证，并使用web应用、文件传输程序或邮件读取程序等应用上传或检索文件。</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">李维虎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/">http://example.com/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归博主所有，如有转载，请注明来自原作者，联系方式（微信）：a1253582301</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RHCE/">RHCE</a></div><div class="post-share"><div class="social-share" data-image="/img/doc_img/RHCE_cover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第四章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux-RHCE-124-第四章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第六章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux-RHCE-124-第六章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第七章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-26</div><div class="info-item-2">Linux-RHCE-124-第七章节</div></div><div class="info-2"><div class="info-item-1">监控和管理Linux进程进程状态和生命周期进程的定义</div></div></div></a><a class="pagination-related" href="/2025/02/27/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第一章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">Linux-RHCE-124-第一章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第三章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-07</div><div class="info-item-2">Linux-RHCE-124-第三章节</div></div><div class="info-2"><div class="info-item-1">在红帽企业Linux中获取帮助阅读手册页Linux手册页简介​	本地系统上通常可用的文档来源之一是系统手册页或man page。软件包随附这些页面来提供文档，您可以使用man命令从命令行访问这些文档。页面存储在&#x2F;usr&#x2F;share&#x2F;man 目录的子目录中。 ​	man page 源自过去的Linux程序员手册，该手册篇幅很长，足以划分多个章节。每个章节包含有特定主题信息。    章节 内容类型 描述    1 用户命令 可执行命令和shell程序   2 系统调用 从用户空间调用的内核例程   3 库函数 有程序库提供   4 特殊文件 例如设备文件   5 文件格式 用于许多配置文件和结构   6 游戏和屏保 过去的趣味程序章节   7 惯例、标准和其他 协议、文件系统   8 系统管理和特权命令 维护任务   9 Linux内核API 内部内核调用   ​	为区分不同章节中相同的主题名称，man...</div></div></div></a><a class="pagination-related" href="/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第二章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Linux-RHCE-124-第二章节</div></div><div class="info-2"><div class="info-item-1">从命令行管理文件​	 欢迎阅览我的文章，本章节将介绍什么是Linux，演示环境为RedHat-9 描述Linux文件系统层次结构概念​	Linux系统中的所有文件存储在文件系统中，他们被组织到一颗上下颠倒的树中，称为文件系统层次结构。这个层次结构是上下颠倒的树，因为树根在顶部，树根下方延伸处目录和子目录的分支。  ​	&#x2F; 目录是根目录，位于文件系统层次结构的顶部。&#x2F; 字符还用做文件名中的目录分隔符。例如：如果etc是&#x2F; 根目录的子目录，则可将该目录指代为 &#x2F;etc。类似的，如果&#x2F;etc目录包含一个名为issue的文件，可以将该文件指代为&#x2F;etc&#x2F;issue。 ​	&#x2F;...</div></div></div></a><a class="pagination-related" href="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第四章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="info-item-2">Linux-RHCE-124-第四章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第六章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="info-item-2">Linux-RHCE-124-第六章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李维虎</div><div class="author-info-description">一个热爱技术分享的有志青年</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的<em>博客网站</em>，如对文章内容有疑惑可扫描二维码添加博主微信。</p> <p>文章来之不易，如认为文章不错请在文章底部为博主打赏,你的支持是我持续更新的动力</p> <CENTER><img src="img\index_img/wxewm.png" alt="描述文字" style="width:250px; height:250px;"></CENTER></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">管理本地用户和组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是用户？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">什么是组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E5%92%8C%E8%A1%A5%E5%85%85%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">主要组和补充组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.</span> <span class="toc-text">获取超级用户访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7"><span class="toc-number">2.1.</span> <span class="toc-text">超级用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7"><span class="toc-number">2.2.</span> <span class="toc-text">切换用户账户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87sudo%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">通过sudo运行命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Sudo%E8%8E%B7%E5%8F%96%E4%BA%A4%E4%BA%92%E5%BC%8FRoot-Shell"><span class="toc-number">2.4.</span> <span class="toc-text">通过Sudo获取交互式Root Shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AESudo"><span class="toc-number">2.5.</span> <span class="toc-text">配置Sudo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7"><span class="toc-number">3.</span> <span class="toc-text">管理本地用户账户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">3.1.</span> <span class="toc-text">从命令行创建用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E7%8E%B0%E6%9C%89%E7%9A%84%E7%94%A8%E6%88%B7"><span class="toc-number">3.2.</span> <span class="toc-text">从命令行修改现有的用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-number">3.3.</span> <span class="toc-text">从命令行删除用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">从命令行设置密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UID%E8%8C%83%E5%9B%B4"><span class="toc-number">3.5.</span> <span class="toc-text">UID范围</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E7%BB%84%E8%B4%A6%E6%88%B7"><span class="toc-number">4.</span> <span class="toc-text">管理本地组账户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">从命令行创建组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E7%8E%B0%E6%9C%89%E7%9A%84%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">从命令行修改现有的组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%A0%E9%99%A4%E7%BB%84"><span class="toc-number">4.3.</span> <span class="toc-text">从命令行删除组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9B%B4%E6%94%B9%E7%BB%84%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BC"><span class="toc-number">4.4.</span> <span class="toc-text">从命令行更改组成员资格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%BB%E8%A6%81%E7%BB%84%E5%92%8C%E8%A1%A5%E5%85%85%E7%BB%84%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BC"><span class="toc-number">4.5.</span> <span class="toc-text">比较主要组和补充组成员资格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E6%9B%B4%E6%94%B9%E6%82%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84"><span class="toc-number">4.6.</span> <span class="toc-text">临时更改您的主要组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">管理用户密码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%AD%90%E5%AF%86%E7%A0%81%E5%92%8C%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.</span> <span class="toc-text">影子密码和密码策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%AF%86%E7%A0%81%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">加密密码的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-number">5.3.</span> <span class="toc-text">密码验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E6%9C%9F%E9%99%90"><span class="toc-number">5.4.</span> <span class="toc-text">配置密码期限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">5.5.</span> <span class="toc-text">限制访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%99%BB%E5%BD%95Shell"><span class="toc-number">5.6.</span> <span class="toc-text">非登录Shell</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第七章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第七章节"/></a><div class="content"><a class="title" href="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第七章节">Linux-RHCE-124-第七章节</a><time datetime="2025-05-26T08:59:32.000Z" title="发表于 2025-05-26 16:59:32">2025-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/20/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Linux%E6%A0%B9%E6%8C%82%E8%BD%BD%E7%9B%98%E6%89%A9%E5%AE%B9/" title="Linux根目录磁盘扩容"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux根目录磁盘扩容"/></a><div class="content"><a class="title" href="/2025/05/20/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Linux%E6%A0%B9%E6%8C%82%E8%BD%BD%E7%9B%98%E6%89%A9%E5%AE%B9/" title="Linux根目录磁盘扩容">Linux根目录磁盘扩容</a><time datetime="2025-05-20T08:45:28.527Z" title="发表于 2025-05-20 16:45:28">2025-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第六章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第六章节"/></a><div class="content"><a class="title" href="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第六章节">Linux-RHCE-124-第六章节</a><time datetime="2025-05-20T08:18:29.000Z" title="发表于 2025-05-20 16:18:29">2025-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第五章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第五章节"/></a><div class="content"><a class="title" href="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第五章节">Linux-RHCE-124-第五章节</a><time datetime="2025-04-03T08:42:14.000Z" title="发表于 2025-04-03 16:42:14">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第四章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第四章节"/></a><div class="content"><a class="title" href="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第四章节">Linux-RHCE-124-第四章节</a><time datetime="2025-03-10T08:42:14.000Z" title="发表于 2025-03-10 16:42:14">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/doc_img/RHCE_cover.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 李维虎</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">主题框架声明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="晚,上,好" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>