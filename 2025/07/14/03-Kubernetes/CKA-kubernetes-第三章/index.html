<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CKA-kubernetes-第三章 | 欢迎来到李维虎的在线博客</title><meta name="author" content="李维虎"><meta name="copyright" content="李维虎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kubectl语法​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。 ​	kubectl命令的常见格式是：kubectl action resource [parameter]。  kubectl：二进制执行文件。 action：操作选项。 resource：资源类型。 parameter（可选）：参数。  ​">
<meta property="og:type" content="article">
<meta property="og:title" content="CKA-kubernetes-第三章">
<meta property="og:url" content="http://example.com/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/index.html">
<meta property="og:site_name" content="欢迎来到李维虎的在线博客">
<meta property="og:description" content="Kubectl语法​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。 ​	kubectl命令的常见格式是：kubectl action resource [parameter]。  kubectl：二进制执行文件。 action：操作选项。 resource：资源类型。 parameter（可选）：参数。  ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/doc_img/Kubernetes.webp">
<meta property="article:published_time" content="2025-07-14T03:36:45.000Z">
<meta property="article:modified_time" content="2025-09-12T10:25:35.515Z">
<meta property="article:author" content="李维虎">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/doc_img/Kubernetes.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CKA-kubernetes-第三章",
  "url": "http://example.com/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/",
  "image": "http://example.com/img/doc_img/Kubernetes.webp",
  "datePublished": "2025-07-14T03:36:45.000Z",
  "dateModified": "2025-09-12T10:25:35.515Z",
  "author": [
    {
      "@type": "Person",
      "name": "李维虎",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/index_img/logo.png"><link rel="canonical" href="http://example.com/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CKA-kubernetes-第三章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/doc_img/Kubernetes.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/index_img/butterfly-icon.png" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">CKA-kubernetes-第三章</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CKA-kubernetes-第三章<a class="post-edit-link" href="null_posts/03-Kubernetes/CKA-kubernetes-第三章.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-14T03:36:45.000Z" title="发表于 2025-07-14 11:36:45">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-12T10:25:35.515Z" title="更新于 2025-09-12 18:25:35">2025-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Kubectl语法"><a href="#Kubectl语法" class="headerlink" title="Kubectl语法"></a>Kubectl语法</h1><p>​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。</p>
<p>​	kubectl命令的常见格式是：<code>kubectl action resource [parameter]</code>。</p>
<ul>
<li>kubectl：二进制执行文件。</li>
<li>action：操作选项。</li>
<li>resource：资源类型。</li>
<li>parameter（可选）：参数。</li>
</ul>
<p>​	这会对指定的资源（类似node或deployment）执行指定的操作（类似create、describe或delete）。您可以再子命令后面使用 <code>--help</code>获取可能参数相关的更多信息。kubectl get nodes –help</p>
<p>​	示例：创建一个deployment类型的资源，创建的资源名称为deployment-nginx，所引用的镜像为nginx，查询刚创建名为deployment-nginx的deployment资源类型，当前启动了0个pod</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create deployment deployment-nginx --image nginx </span><br><span class="line">deployment.apps/deployment-nginx created</span><br><span class="line"><span class="comment"># 创建资源成功，但是READY启动了0个pod</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get deployments.apps deployment-nginx </span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment-nginx   0/1     1            0           2m</span><br><span class="line"><span class="comment"># 稍等一会在查，READY已经1/1，那是因为在这过程中他回去先拉取镜像，是需要等一会的</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get deployments.apps deployment-nginx </span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment-nginx   1/1     1            1           8m48s</span><br><span class="line"><span class="comment"># 想要查看资源创建详情可通过describe选项</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl describe deployments.apps deployment-nginx </span><br><span class="line">Name:                   deployment-nginx</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 14 Jul 2025 16:44:03 +0800</span><br><span class="line">Labels:                 app=deployment-nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               app=deployment-nginx</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=deployment-nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:         nginx</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Environment:   &lt;none&gt;</span><br><span class="line">    Mounts:        &lt;none&gt;</span><br><span class="line">  Volumes:         &lt;none&gt;</span><br><span class="line">  Node-Selectors:  &lt;none&gt;</span><br><span class="line">  Tolerations:     &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   deployment-nginx-f9986cddf (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  11m   deployment-controller  Scaled up replica <span class="built_in">set</span> deployment-nginx-f9986cddf from 0 to 1</span><br><span class="line"><span class="comment"># 删除刚创建的deployment</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete deployments.apps deployment-nginx </span><br><span class="line">deployment.apps <span class="string">&quot;deployment-nginx&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h1><p>​	kubectl命令是正常是可以创建出服务，但是在企业实践中这是利用kubectl创建的服务通常仅用来测试或者临时的服务，因为一个完整的业务他是需要具备着很多参数，使用kubectl来创建显然不是很方便阅读，并且命令敲了是一次性的，当我要更新这个服务时，只能删除后重新进行执行，因为对于k8s来说它是没有更新的概念的，所有的更新都是删除后重新部署的。</p>
<p>​	但是我们使用yaml文件的方式进行部署版本迭代，那就可以很轻松的解决，唯一的缺点就是yaml的学习成本较高，对于初学者来说是较为困难的事情。下图为官网给出的一个最简单的创建资源的yaml。</p>
<ul>
<li>文件内容格式要求严格。</li>
<li>大小写敏感。</li>
<li>使用缩进表达上下级关系，上下级需保持两位空格缩进。</li>
<li>缩进时不允许使用tab，只能使用空格进行缩进。</li>
<li>#号为注释，不作为允许时的代码。</li>
<li>键值对（key:value）用冒号分割，value不允许紧挨着冒号，需要空一个书写value。</li>
<li>列表类型的value需要回车用-（减号）加一个空格来表示，多个列表使用同级缩进进行表示为一组列表。</li>
<li>文件已yaml和yml后缀作为文件名。</li>
</ul>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714172355789.png" alt="image-20250714172355789"></p>
<p>​	虽然有些复杂，但是我们可以通过帮助<code>explain</code>选项帮助我们查询它所具备的参数及用法。</p>
<p>​	例如：<code>kubectl explain pod</code></p>
<p>​	查询pod资源下存在如图标记出的key选项。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714173015446.png" alt="image-20250714173015446"></p>
<p>​	<code>kubectl explain pod.spec</code>下有具备如下图众多选项，命令中的上下级使用.（点）来表示，yaml文件中的上下级通过换行缩进两格进行表示。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714173220277.png" alt="image-20250714173220277"></p>
<p>​	</p>
<p>​	如果您对kubectl很熟悉，也可以通过kubectl来主动帮您生成yaml，仅需在写好的kubectl后加上<code>--dry-run=client -o yaml</code>参数即可，添加后您的这条语句不会正真执行操作，而是将它转化为yaml进行输出，具体示例参考下方代码。</p>
<p>​	kubectl创建一个名为deployment-nginx的deployment类型资源，镜像使用nginx，<code>--replicas 3</code>生成3个副本（Pod），<code>--dry-run=client -o yaml</code>模拟运行到客户端，已yaml的方式进行输出，这样我们就很轻松的完成一个yaml了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create deployment deployment-nginx --image nginx --replicas 3 --dry-run=client -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: deployment-nginx</span><br><span class="line">  name: deployment-nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: deployment-nginx</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: deployment-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">status: &#123;&#125;</span><br><span class="line">[root@k8s-master-01 ~]#</span><br></pre></td></tr></table></figure>

<p>​	<strong>注：Kind代表你要操作的资源类型，apiVersion代表这个资源的版本，metadata下的内容代表着这个资源的具体操作内容，apiVersion并不都是v1，下表中介绍版本中各不同的表示。</strong></p>
<table>
<thead>
<tr>
<th>Alpha</th>
<th>Beta</th>
<th>Stable</th>
</tr>
</thead>
<tbody><tr>
<td>1、版本名称包含了Alpha。</td>
<td>1、版本名称包含了Beta。</td>
<td>1、版本名称是vX，其中X是整数。</td>
</tr>
<tr>
<td>2、可能是由缺陷的。启用该功能可能会带来问题，默认是关闭的。</td>
<td>2、代码进行测试过。启动该功能认为是安全的，默认是启用。</td>
<td>2、功能和稳定版本将出现在许多后续版本的发行软件中。</td>
</tr>
<tr>
<td>3、支持的功能可能在没有通知的情况下随时删除。</td>
<td>3、所有以支持的功能不会被删除，细节可能发生变化。</td>
<td>3、有时候也会被称为GA或者毕业等词汇。</td>
</tr>
<tr>
<td>4、API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</td>
<td>4、对象的模式和语义可能会在后续的Beta测试版或稳定版中以不兼容的方式进行更改。</td>
<td></td>
</tr>
<tr>
<td>5、由于BUG风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</td>
<td>5、建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。如果您有多个可以独立升级的集群，则可以放款此限制。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="API-and-RESOURCES"><a href="#API-and-RESOURCES" class="headerlink" title="API and RESOURCES"></a>API and RESOURCES</h1><p>​	我们前面简单以pod、deployment资源进行了演示，那么我们这个k8s到底还存在着哪些API功能呢？</p>
<p>​	可以通过：<code>kubectl api-resources</code>命令进行查看。</p>
<ul>
<li>NAME：资源名称，通常用于kubectl中表示资源类型的名称。</li>
<li>SHORTNAMES：资源名称缩写，通常用于kubectl中表示资源类型的名称缩写。</li>
<li>APIVERSION：API版本，通常用于表示这每个资源的稳定情况及预示后续版本可能会带来的某些变化。</li>
<li>NAMESPACED：代表着这个资源的命名空间作用域范围。<ul>
<li>True表示只作用于所创建隶属于哪个命名空间的范围。</li>
<li>False表示该资源创建后作用域整个集群。</li>
</ul>
</li>
<li>KIND：资源类型，通常用于Yaml中表示要操作的资源类型。</li>
</ul>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714174333125.png" alt="image-20250714174333125"></p>
<p>​	<strong>注：NAMESPACED其实主要的作用就是在您写Yaml时，如果是True那您就需要在metadata下写明该资源要创建到哪个命名空间中，作用域这个小范围，如果是False则无需写明，因为他的作用域是集群的全局，写不写意义不大。</strong></p>
<h1 id="Kubernetes与docker的关系"><a href="#Kubernetes与docker的关系" class="headerlink" title="Kubernetes与docker的关系"></a>Kubernetes与docker的关系</h1><p>​	在之前我们介绍过，当您使用了K8s那我们就从一个打螺丝的一线员工晋升为领导了，我们所有操作都是通过master节点中的kubelet下发指令然后通过kube-api向node节点中的kubelet发送指令，翻译成docker的语言，让docker干活，node节点中的kubelet就处于一个监工的角色。以下用一个示例来演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我们通过master节点创建了一个资源，让docker去生成一个httpd的容器。</span></span><br><span class="line"><span class="comment"># 这里k8s告诉我资源已经创建成功，但是容器是否有创建成功我们不知道。</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl create deployment httpd-01 --image httpd</span><br><span class="line">deployment.apps/httpd-01 created</span><br><span class="line"><span class="comment"># 可以通过如下命令看到READY1/1说明运行了一个容器，一个容器正在运行中</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl get deployments.apps </span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">httpd-01   1/1     1            1           8m9s</span><br><span class="line"><span class="comment"># 我们在master上并未发现有httpd镜像</span></span><br><span class="line">[root@k8s-master-01 namespace]# docker images</span><br><span class="line">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx                                                      latest     9592f5595f2b   3 weeks ago     192MB</span><br><span class="line">reg.liweihu.cn/calico/typha                                v3.30.2    b3baa600c7ff   4 weeks ago     85.2MB</span><br><span class="line">calico/typha                                               v3.30.2    b3baa600c7ff   4 weeks ago     85.2MB</span><br><span class="line"><span class="comment"># master上并未发现有httpd容器在运行</span></span><br><span class="line">[root@k8s-master-01 namespace]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                         COMMAND                   CREATED       STATUS       PORTS     NAMES</span><br><span class="line">ba8132dd4b57   1cf5f116067c                                  <span class="string">&quot;/coredns -conf /etc…&quot;</span>   6 hours ago   Up 6 hours             k8s_coredns_coredns-dc6b59956-bfgfb_kube-system_962eb48f-da7c-40b4-be9d-2a4420322173_8</span><br><span class="line">7f4c39926348   1cf5f116067c                                  <span class="string">&quot;/coredns -conf /etc…&quot;</span>   6 hours ago   Up 6 hours             k8s_coredns_coredns-dc6b59956-72kvq_kube-system_de1ba00e-bac3-4d96-8e5c-90d523cdac40_8</span><br></pre></td></tr></table></figure>

<p>​	我们说过，master是管理节点是一个领导的角色，领导是不会在一线打螺丝的，所以我们所创建的容器肯定是在node节点上去运行的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在node1节点上我们发现了httpd被拉下来的镜像</span></span><br><span class="line">[root@k8s-node-01 ~]# docker images</span><br><span class="line">REPOSITORY                                    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx                                         latest    22bd15417453   6 days ago      192MB</span><br><span class="line">httpd                                         latest    90f191b9781e   10 days ago     148MB</span><br><span class="line"><span class="comment"># 并且我们所创建的httpd的容器也是在node1上运行的</span></span><br><span class="line">[root@k8s-node-01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                         COMMAND                   CREATED         STATUS         PORTS     NAMES</span><br><span class="line">fa97240d5022   httpd                                         <span class="string">&quot;httpd-foreground&quot;</span>        5 minutes ago   Up 5 minutes             k8s_httpd_httpd-01-6797c85b9f-csrjb_book-k8s_3ac3ff31-78de-45b3-8ca0-c40edd15c2e1_0</span><br></pre></td></tr></table></figure>



<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>​	在Kubernetes中，命名空间（Namespace）提供了一种机制，将同一集群中的资源划分为相互隔离的组。同一命名空间的内的资源名称要唯一，但跨命名空间时没这个要求。命名空间作用域仅针对带有命名空间的对象，（例如Deployment、Service等），这种作用域对集群范围的对象（例如StorageClass、Node）PersistentVolume 等）不适用，这一点也就是上段文章内容中介绍的<code>kubectl api-resources</code>命令查看到的Namespace字段，True表示适用命名空间，False表示不适用。</p>
<h2 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h2><p>​	命名空间适用于存在很多个团队或项目的用户场景，对于只有几个到十几个用户的群体，可以不需要考虑命名空间。如果业务和团队合作时确实需要，请开始使用它们。</p>
<p>​	命名空间为命名提供了一个范围。资源的名称需要在命名空间内是唯一的，但不能跨命名空间。命名空间不能相互嵌套，每个Kubernetes资源只能在一个命名空间中。</p>
<p>​	命名空间是在多个用户质检划分集群资源的一种方式（通过资源配额）。</p>
<p>​	不必使用多个命名空间来分割仅仅轻微不同的资源，例如同一软件的不同版本：应该使用标签来区分同一命名空间中的不同资源。</p>
<p>​	在Kubernetes集群中会分别会自动创建四个命令空间，我们可以使用以下命令进行查看当前集群中存在哪些命名空间。</p>
<ul>
<li>default：Kubernetes包含这个命名空间，以便于您无需创建新的命名空间即可开始使用新集群，同时当您在创建资源为指定命名空间时，默认会创建在改命名空间下。</li>
<li>kube-node-lease：该名字空间包含用于与各个节点关联的 Lease（租约）对象。 节点租约允许 kubelet 发送心跳， 由此控制面能够检测到节点故障。该命名空间下主要包含的资源是leases。</li>
<li>kube-public：所有的客户端（包括未经身份验证的客户端）都可以读取该名字空间。 该名字空间主要预留为集群使用，以便某些资源需要在整个集群中可见可读。 该名字空间的公共属性只是一种约定而非要求。</li>
<li>kube-system：该名字空间用于 Kubernetes 系统集群类资源创建的对象。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get namespaces</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   12d</span><br><span class="line">kube-node-lease   Active   12d</span><br><span class="line">kube-public       Active   12d</span><br><span class="line">kube-system       Active   12d</span><br><span class="line">tigera-operator   Active   10d</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：tigera-operator并非集群初始化的命名空间，而是Calico官方操作Kubernetes所创建的命名空间，用于创建管理Calico网络策略和配置资源的。</strong></p>
<p>​	<strong>重要：对于生产环境，请考虑不要使用default命名空间，而是创建其他具有项目意义的名字来使用。</strong></p>
<h2 id="创建一个具有项目意义的命名空间"><a href="#创建一个具有项目意义的命名空间" class="headerlink" title="创建一个具有项目意义的命名空间"></a>创建一个具有项目意义的命名空间</h2><p>​	以下我们将要创建一个属于我们项目独有、具有识别意义的命名空间，之后我们的大部分资源创建操作都将在该命名空间中。</p>
<ul>
<li>创建一个名为：book-k8s的命名空间。</li>
<li>查看命名空间，检查名为book-k8s的命名空间是否存在。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create namespace book-k8s</span><br><span class="line">namespace/book-k8s created</span><br><span class="line">[root@k8s-master-01 ~]# </span><br><span class="line">[root@k8s-master-01 ~]# kubectl get namespaces </span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">book-k8s          Active   6s</span><br><span class="line">default           Active   12d</span><br><span class="line">kube-node-lease   Active   12d</span><br><span class="line">kube-public       Active   12d</span><br><span class="line">kube-system       Active   12d</span><br><span class="line">tigera-operator   Active   10d</span><br></pre></td></tr></table></figure>

<p><strong>Yaml的方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建yaml文件</span></span><br><span class="line">[root@k8s-master-01 namespace]# <span class="built_in">cat</span> &gt;&gt; create-names.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Namespace</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: book-k8s</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 执行yaml文件</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl create -f create-names.yaml </span><br><span class="line">namespace/book-k8s created</span><br></pre></td></tr></table></figure>



<h2 id="为创建资源设置命名空间"><a href="#为创建资源设置命名空间" class="headerlink" title="为创建资源设置命名空间"></a>为创建资源设置命名空间</h2><p>​	目前我们已经创建了一个名为book-k8s的命名空间，接下来我们需要在该命名空间中创建第一个项目资源Pod。</p>
<ul>
<li>​	使用yaml或kubectl的方式创建一个Pod并指定该资源运行在book-k8s命名空间中。</li>
<li>查看资源是否正常运行中。</li>
</ul>
<p><strong>kubectl的方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为nginx的Pod，使用Nginx镜像，该资源在book-k8s命名空间下运行。</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl run nginx --image nginx --namespace book-k8s </span><br><span class="line">pod/nginx created</span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods</span><br><span class="line">No resources found <span class="keyword">in</span> default namespace.</span><br></pre></td></tr></table></figure>

<p><strong>Yaml语法：可以使用–dry-run&#x3D;client -o yaml快速生成，但在学习阶段不建议使用该方式，能使用explain进行编写是最好的。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl run nginx --image nginx --namespace book-k8s --dry-run=client -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    run: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx</span><br><span class="line">    name: nginx</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们创建了一个Pod，在book-k8s命名空间下，但是我们使用<code>kubectl get pods</code>命令查看Pod是否在正常运行时提示了，在default（默认命名空间）中未发现任何资源。</p>
<p>​	这就是之前说的，default是默认的命名空间，当你不管是创建还是查询资源时未指定命名空间，默认是使用的default命名空间。所以本示例中我们在需要指定一下命名空间，或者使用<code>-A</code>选项，显示所有命名空间下的该类型资源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有命名空间下的Pods资源类型</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS       AGE</span><br><span class="line">book-k8s      nginx                                      1/1     Running   0              11m</span><br><span class="line">kube-system   calico-kube-controllers-7f59498f59-kf5nn   1/1     Running   7 (40m ago)    10d</span><br><span class="line">kube-system   calico-node-7ndvs                          1/1     Running   7              10d</span><br><span class="line">....忽略....</span><br><span class="line"><span class="comment"># 显示book-k8s命名空间下的pods资源</span></span><br><span class="line"><span class="comment"># -n为--namespace的缩写</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods -n book-k8s </span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          12m</span><br></pre></td></tr></table></figure>



<h2 id="设置命名空间偏好（修改默认命名空间）"><a href="#设置命名空间偏好（修改默认命名空间）" class="headerlink" title="设置命名空间偏好（修改默认命名空间）"></a>设置命名空间偏好（修改默认命名空间）</h2><p>​	如果您仅有这一个命名空间，认为每次查询或创建时都需要指定命名空间较为麻烦，您可以使用以下命令，将默认命名空间修改为您所指定的命名空间，但是这样也会伴随着一些失误，导致您之后操作集群时误操作风险。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config为k8s的配置项，修改k8s的配置上下文。</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl config set-context --current --namespace=book-k8s</span><br><span class="line">Context <span class="string">&quot;kubernetes-admin@kubernetes&quot;</span> modified.</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl config view --minify | grep namespace:</span><br><span class="line">    namespace: book-k8s</span><br><span class="line"><span class="comment"># 再度不加命名空间，发现他默认就是查询的book-k8s下的资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods </span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          21m</span><br></pre></td></tr></table></figure>



<h2 id="删除命令空间"><a href="#删除命令空间" class="headerlink" title="删除命令空间"></a>删除命令空间</h2><p>​	当您需要删除命名空间时，可使用delete选项进行删除，如果改命名空间下存在资源，则会连通资源一并进行删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 namespace]# kubectl delete namespaces book-k8s </span><br><span class="line">namespace <span class="string">&quot;book-k8s&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p>​	如果您是使用yaml创建的资源，也可以使用创建资源时所使用的yaml文件进行删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 namespace]# kubectl delete -f create-names.yaml</span><br><span class="line">namespace <span class="string">&quot;book-k8s&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="关于Pod"><a href="#关于Pod" class="headerlink" title="关于Pod"></a>关于Pod</h1><p>​	Pod是可以再Kubernetes中创建和管理的最小单元、最小的可部署的计算单位。</p>
<p>​	Pod（就像豌豆荚）是一组（一个或多个）容器；这些容器恭喜昂存储、网络、以及怎样运行这些容器的规约。Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250721180834032.png" alt="image-20250721180834032"></p>
<p>​	之前我们说微服务他是解耦合（松散耦合），这里又提到Pod是精密耦合，这是不冲突的，对于项目的拆解是属于解耦合，但是他们实际在运行中跟豌豆荚中的豆一样，他们的关系是紧密相连的。同时你的一个项目不可能拆分的特别细，不可能细到一个把报表一个容器，只是拆分的相对精细。</p>
<p><strong>Kubernetes 集群中的 Pod 主要有两种用法：</strong></p>
<ul>
<li><strong>运行单个容器的 Pod</strong>：每个 Pod 一个容器模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>
<li><strong>运行多个协同工作的容器的 Pod</strong>： Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用。 这些位于同一位置的容器构成一个内聚单元。</li>
</ul>
<p>​	将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</p>
<h2 id="使用Pod"><a href="#使用Pod" class="headerlink" title="使用Pod"></a>使用Pod</h2><p>​	以下是一个Pod的示例，它由一个运行镜像nginx:latest的容器组成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pod-01.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-01</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx-01</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    ports: </span></span><br><span class="line"><span class="string">    - name: nginx-01-ports</span></span><br><span class="line"><span class="string">      containerPort: 80</span></span><br><span class="line"><span class="string">      protocol: TCP</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	要创建上面显示的Pod，请允许以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pod-01.yaml</span><br></pre></td></tr></table></figure>

<p>​	Pod通常不用于直接创建，而是使用工作负载资源进项创建。</p>
<h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><p>​	本页讲述 Pod 的生命周期。 Pod 遵循预定义的生命周期，起始于 Pending 阶段， 如果至少其中有一个主要容器正常启动，则进入 Running，之后取决于 Pod 中是否有容器以失败状态结束而进入 Succeeded 或者 Failed 阶段。</p>
<p>​	和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（UID）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。 如果一个节点死掉了，调度到该节点的 Pod 也被计划在给定超时期限结束后删除。</p>
<p>​	在 Pod 运行期间，kubelet 能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的状态并确定使 Pod 重新变得健康所需要采取的动作。</p>
<p>​	Pod 在其生命周期中只会被调度一次。 将 Pod 分配到特定节点的过程称为绑定，而选择使用哪个节点的过程称为调度。 一旦 Pod 被调度并绑定到某个节点，Kubernetes 会尝试在该节点上运行 Pod。 Pod 会在该节点上运行，直到 Pod 停止或者被终止； 如果 Kubernetes 无法在选定的节点上启动 Pod（例如，如果节点在 Pod 启动前崩溃）， 那么特定的 Pod 将永远不会启动。</p>
<p>​	以下我们使用一个示例来演示：</p>
<p>​	注：imagePullPolicy为镜像拉取模式：</p>
<ul>
<li>当value为IfNotPresent时，当运行的本地节点存在镜像时，则无需额外拉取，直接使用本地镜像。</li>
<li>当value为Always时，无论节点本地是否存在镜像，都从docker配置的仓库中进行额外拉取。</li>
<li>当value为Never时，无论节点本地是否存在镜像，都从本地节点进行拉取，如果本地节点不存在该镜像，则会导致容器创建失败。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pod-02.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-02</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx-02</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行yaml及查询资源状态使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pod-02.yaml</span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pod-02.yaml </span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-02   1/1     Running   0          9s</span><br></pre></td></tr></table></figure>

<p>​	最开始Pod的状态是Pending（等待执行），期间会去拉取镜像、运行镜像，当容器处于运行中时，状态则会变成Running，如果容器已失败运行结束，则会变成Failed，反之成功则会边成Succeeded（完成）。</p>
<h2 id="根容器"><a href="#根容器" class="headerlink" title="根容器"></a>根容器</h2><p>​	当我们创建了一个Pod，该Pod里拥有2个容器，那您可能会认为这个Pod里仅有两个容器，实则不然，其实该Pod拥有三个容器，其中一个容器叫做根容器（Pause）。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250722160242947.png" alt="image-20250722160242947"></p>
<p>​	之前我们介绍过，pod是由一个或多个容器组成的，他们共享网络、存储。并且生命周期是一起启动一起停止等等，该根容器就是负责这个Pod中的多个Pod网络、存储共享、生命周期一起启动或停止等。</p>
<p>​	下图中我们可以看到，其中一个node节点中，分别由K8s创建出来的三个Pod，这三个Pod分别都对应着一个容器，同样三个Pod也会有三个根容器（Pause）。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250722160604659.png" alt="image-20250722160604659"></p>
<h2 id="创建多容器Pod"><a href="#创建多容器Pod" class="headerlink" title="创建多容器Pod"></a>创建多容器Pod</h2><p>​	上面我们采用的都是单容器对应一个pod进行创建，另外一个Pod可以对应多个容器，以下示例进行演示：</p>
<p>​	对于一个Pod包含多个容器，只需要在containers下在写一个容器列表描述。</p>
<p>​	其中pod.spec下的restartPolicy参数，表示pod重启的策略模式。</p>
<ul>
<li>OnFailure： 只有在容器错误退出（退出状态非零时）才会重启。</li>
<li>Never： 从不会重启，即使失败或是完成终止都不会重启。</li>
<li>Always： 只要容器终止就自动重启容器。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pods-01.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: pods-01</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">  - name: ubuntu</span></span><br><span class="line"><span class="string">    image: ubuntu:latest</span></span><br><span class="line"><span class="string">    command: [&#x27;sh&#x27;,&#x27;-c&#x27;,&#x27;echo &quot;hello lwh&quot; &amp;&amp; sleep 3600&#x27;]</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">  restartPolicy: OnFailure</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	以下命名可以运行yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pods-01.yaml </span><br><span class="line">pod/pods-01 created</span><br></pre></td></tr></table></figure>

<p>​	以下命令可以查询资源运行情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前状态就是处于Pending中的一环，正在创建容器，也就是正在拉取容器，如果您本地没有镜像，这拉取需要等待一段时间。</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pods-01.yaml </span><br><span class="line">NAME      READY   STATUS              RESTARTS   AGE</span><br><span class="line">pods-01   0/2     ContainerCreating   0          9s</span><br><span class="line"><span class="comment"># 过一段时间以后即可处于Running</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pods-01.yaml </span><br><span class="line">NAME      READY   STATUS    RESTARTS   AGE</span><br><span class="line">pods-01   2/2     Running   0          2m23s</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：Pod实际上是不支持重启的，Pod只支持创建、删除，所以这里说的重启并非真正意义上的重启，而是删除后重新创建达到的一个重启效果。</strong></p>
<h2 id="修改Pod"><a href="#修改Pod" class="headerlink" title="修改Pod"></a>修改Pod</h2><p>​	原则上Pod是不能修改的，但是官方并没有说Pod不能修改，而是可修改的内容及其有限，几乎达到了不能修改的级别。</p>
<p>​	修改etcd数据，可以使用以下命令，之后会为您打开一个vim编辑器，正常通过编辑文本的方式进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl edit -f pods-01.yaml</span><br></pre></td></tr></table></figure>



<h2 id="进入容器的方法"><a href="#进入容器的方法" class="headerlink" title="进入容器的方法"></a>进入容器的方法</h2><p>​	如果要通过pod进入容器，与docker类似，使用以下命令：</p>
<ul>
<li>exec：执行容器命令的选项。</li>
<li>-it：交互式访问容器。</li>
<li>pods&#x2F;pods-01： 指定进入哪个Pod</li>
<li>-c nginx：如该pod存在多个容器，则需指定pod中的哪个容器名。</li>
<li>– ：k8s中的容器命令特殊连接符号。</li>
<li>&#x2F;bin&#x2F;bash：在容器中执行的bash命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl <span class="built_in">exec</span> -it pods/pods-01 -c nginx  -- /bin/bash</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">root@pods-01:/# <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>



<h2 id="删除Pod"><a href="#删除Pod" class="headerlink" title="删除Pod"></a>删除Pod</h2><p>​	如果要删除Pod可通过以下命令进行删除：</p>
<p><strong>利用创建Pod时所使用的yaml进行删除</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl delete -f pods-01.yaml </span><br><span class="line">pod <span class="string">&quot;pods-01&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>利用kubectl指定Pod进行删除</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl delete pod pods-01 </span><br><span class="line">pod <span class="string">&quot;pods-01&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="Init类型容器"><a href="#Init类型容器" class="headerlink" title="Init类型容器"></a>Init类型容器</h1><p>​	Init容器是一种特殊的容器，在Pod内的应用容器启动之前运行。Init容器可以包含一些应用镜像中不存在的实用工具和安装脚本。</p>
<p>​	您可以在Pod的规约中与用来描述应用容器的containers数组平行的位置指定Init容器。Init容器使用<code>pod.spec.initContainers</code>来进行描述。</p>
<h2 id="Init容器特点"><a href="#Init容器特点" class="headerlink" title="Init容器特点"></a>Init容器特点</h2><ul>
<li>在主容器启动前执行。</li>
<li>具有临时性，执行完成即终止。</li>
<li>kubectl get无法查看到pod。</li>
</ul>
<h2 id="使用Init容器"><a href="#使用Init容器" class="headerlink" title="使用Init容器"></a>使用Init容器</h2><p>​	以下生成了一个Yaml文件，该yaml较之前的复杂很多，以下会对yaml做些内容解析，该部分仅用理解initContainers参数，其余的volumeMounts目前稍作了解即可：</p>
<ul>
<li><strong>metadata.labels</strong>：为该Pod打上一个标签，对服务是无任何意义的，主要是便于后续资源查找筛选使用。</li>
<li><strong>metadata.containers.volumeMounts</strong>：为该容器挂载一个持久卷，向宿主机的<code>/work-dir</code>目录创建文件可映射到容器内的<code>/usr/share/nginx/html</code>目录。</li>
<li><strong>metadata.spec.volumes</strong>：创建一个空的持久卷，持久卷名字为：<code>workdir</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; init-pods.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: my-web</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: my-web</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: my-web</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">    - name: workdir</span></span><br><span class="line"><span class="string">      mountPath: /usr/share/nginx/html</span></span><br><span class="line"><span class="string">  initContainers:</span></span><br><span class="line"><span class="string">  - name: my-service</span></span><br><span class="line"><span class="string">    image: busybox:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">    command:</span></span><br><span class="line"><span class="string">    - wget</span></span><br><span class="line"><span class="string">    - &quot;-O&quot;</span></span><br><span class="line"><span class="string">    - &quot;/work-dir/index.html&quot;</span></span><br><span class="line"><span class="string">    - http://info.cern.ch</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">    - name: workdir</span></span><br><span class="line"><span class="string">      mountPath: &quot;/work-dir&quot;</span></span><br><span class="line"><span class="string">  volumes:</span></span><br><span class="line"><span class="string">  - name: workdir</span></span><br><span class="line"><span class="string">    emptyDir: &#123;&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	执行yaml文件使用如下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f init-pods.yaml </span><br><span class="line">pod/my-web created</span><br></pre></td></tr></table></figure>

<p>​	yaml整个执行阶段的变化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init容器正在创建</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS     RESTARTS   AGE</span><br><span class="line">my-web   0/1     Init:0/1   0          6s</span><br><span class="line"><span class="comment"># init容器进行初始化任务中</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS            RESTARTS   AGE</span><br><span class="line">my-web   0/1     PodInitializing   0          9s</span><br><span class="line"><span class="comment"># init容器初始化完成，应用容器运行中</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-web   1/1     Running   0          11s</span><br></pre></td></tr></table></figure>





<h2 id="Init容器的具体行为"><a href="#Init容器的具体行为" class="headerlink" title="Init容器的具体行为"></a>Init容器的具体行为</h2><p>以上yaml整个运行流程梳理：</p>
<ol>
<li>initContainers的初始化容器会先去执行wget下载一个index.html的文件到容器的&#x2F;work-dir&#x2F;index.html目录下，同时该init容器的&#x2F;work-dir&#x2F;目录挂载了名为workdir的持久卷，也相当于把文件下载到了这个持久卷中，执行完成后init容器会以completed状态结束。</li>
<li>containers运行的应用容器是一个nginx页面服务，该容器将持久卷workdir挂载到服务首页配置目录中，持久卷内具有一个从init容器帮我们提前完成下载的index.html的文件，最终完成整个服务的部署启动。</li>
</ol>
<p>总结：init通常用于应用服务运行前的环境检查，及先决条件配置，当先决条件满足后才会正式运行我们真正用到的容器服务。</p>
<h1 id="Sidecar类型容器"><a href="#Sidecar类型容器" class="headerlink" title="Sidecar类型容器"></a>Sidecar类型容器</h1><p>​	Sidecar容器也称为边车容器，他与主应用容器是在同一个Pod中运行的辅助性容器。Sidecar容器通过额外的辅助性服务或功能（如日志记录、监控、安全性或数据同步）来增强或扩展主应用容器的功能，而无需直接修改主应用代码。</p>
<h2 id="Sidecar容器特点"><a href="#Sidecar容器特点" class="headerlink" title="Sidecar容器特点"></a>Sidecar容器特点</h2><p>​	Sidecar具有以下特点：</p>
<ul>
<li>Sidecar并非特定类型的容器，而是一个辅助容器的概念。</li>
<li>Sidecar生命周期具有持久性。</li>
<li>Sidecar容器可被kubectl get获取到（取决于用法）</li>
<li>Pod终止时主容器会先行终止，Sidecar等待主容器终止后随之终止。</li>
</ul>
<h2 id="以init容器启动Sidecar"><a href="#以init容器启动Sidecar" class="headerlink" title="以init容器启动Sidecar"></a>以init容器启动Sidecar</h2><p>​	以下Ymal将产生具有Sidecar概念的pod，细心的可以看出，这怎么跟之前创建的Init容器一样，都具有一个containers（主容器）和initContainers（初始化容器），唯一不同的是initContainers容器里增加了一个重启策略，策略模式为Always，只要容器终止就会自动重启，这里我们先来解析以下他分别做了些什么事。</p>
<ul>
<li>​	创建了一个containers容器，使用了alpine镜像，command中每秒向容器内的&#x2F;opt&#x2F;logs.txt文件中写入”logging”内容，并挂载了一个名为data的临时卷。</li>
<li>创建了一个initContainers容器，使用了alpine镜像，并且restartPolicy（重启策略）为Always，容器停止则自动重启，command中实时查看&#x2F;opt&#x2F;logs.txt文件，并同样挂载了一个名为data的临时卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; init-Sidecar.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: myapp</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: myapp</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: myapp</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: myapp</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: myapp</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;while true; do echo &quot;logging&quot; &gt;&gt; /opt/logs.txt; sleep 1; done&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      initContainers:</span></span><br><span class="line"><span class="string">        - name: logshipper</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          restartPolicy: Always</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;tail -F /opt/logs.txt&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      volumes:</span></span><br><span class="line"><span class="string">        - name: data</span></span><br><span class="line"><span class="string">          emptyDir: &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	以下命令可运行yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create -f init-Sidecar.yaml</span><br></pre></td></tr></table></figure>

<p>​	查看效果，需要查看资源日志可使用kubectl logs [资源名] [一个pod包含多个容器则需要指定容器]：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于init容器具有重启策略的加持，会一直进行重启，所以READY的时候会发现这个pod具有两个容器</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods myapp-55d976bcf9-m4mw8 </span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myapp-55d976bcf9-m4mw8   2/2     Running   0          35m</span><br><span class="line"><span class="comment"># 正常情况下我们无法通过kubectl查看到主容器的日志文件情况</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-55d976bcf9-m4mw8 myapp</span><br><span class="line"><span class="comment"># 但是当我们指定查看辅助容器，则可以快速查看和定位到主容器服务写入的日志</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-55d976bcf9-m4mw8 logshipper </span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete -f init-Sidecar.yaml</span><br></pre></td></tr></table></figure>





<h2 id="以普通容器启动Sidecar"><a href="#以普通容器启动Sidecar" class="headerlink" title="以普通容器启动Sidecar"></a>以普通容器启动Sidecar</h2><p>​	以下Yaml与上面init启动的Sidecar是一样的，区别就是在于Sidecar辅助容器现在用普通的containers进行创建，并且<code>restartPolicy: Always</code>与containers同级，作用域是containers下的所有容器，但是这个与Sidecar没有关系，这里只是为了让该资源创建时更为健壮，不会因为停止而停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; pod-Sidecar.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: myapp</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: myapp</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: myapp</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: myapp</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: myapp</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;while true; do echo &quot;logging&quot; &gt;&gt; /opt/logs.txt; sleep 1; done&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">        - name: logshipper</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;tail -F /opt/logs.txt&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      restartPolicy: Always</span></span><br><span class="line"><span class="string">      volumes:</span></span><br><span class="line"><span class="string">        - name: data</span></span><br><span class="line"><span class="string">          emptyDir: &#123;&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	使用以下命令进行yaml资源创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create -f pod-Sidecar.yaml </span><br><span class="line">deployment.apps/myapp created</span><br></pre></td></tr></table></figure>

<p>​	查看效果，需要查看资源日志可使用kubectl logs [资源名] [一个pod包含多个容器则需要指定容器]：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与init生成的Sidecar概念区别在于containers生成的pods可被直观的看到，这里外面发现READY容器数量是2</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods myapp-75c678fb68-r7fxm </span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myapp-75c678fb68-r7fxm   2/2     Running   0          3m38s</span><br><span class="line"><span class="comment"># 正常情况下我们无法通过kubectl查看到主容器的日志文件情况</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-75c678fb68-r7fxm myapp</span><br><span class="line"><span class="comment"># 但是当我们指定查看辅助容器，则可以快速查看和定位到主容器服务写入的日志</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-75c678fb68-r7fxm logshipper </span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete -f pod-Sidecar.yaml</span><br></pre></td></tr></table></figure>







<h2 id="Sidecar与init和普通容器的区别"><a href="#Sidecar与init和普通容器的区别" class="headerlink" title="Sidecar与init和普通容器的区别"></a>Sidecar与init和普通容器的区别</h2><p>​	<strong>从以上实验我们可以看出Sidecar与init的区别在于：</strong></p>
<ul>
<li>一个是可持续性运行的容器。那是因为我们加的<code>restartPolicy: Always</code>重启策略使init不会因为一次执行完成后而终止。</li>
<li>一个是为主容器做完先决运行条件后终止的容器临时在主容器启动前完成运行的容器。</li>
</ul>
<p>从以上实验我们可以看出Sidecar与普通containers的就没有区别，他就是一个普通的容器。</p>
<p>​	所以我们在开头就说Sidecar容器他只是一个概念，取决于你的用途，你的init可以用于为主容器完成先决运行条件配置、检查，也可以使用init辅助主容器持续的完成日志转发等扩展功能，而无需去修改主容器的代码。普通的containers容器也相同，你可以使用containers作为主容器，也可以使用containers辅助你另外一个主容器达到功能扩展。</p>
<p>​	就类似在一个公司会有高级程序员和程序员助理，大家都是打螺丝的员工，没有区别，而助理是为高级程序员做辅助性工作的，只是做的事情不一样而已。</p>
<p>​	<strong>重要：Pod中存在多个容器的话，并且用到了Sidecar概念时，你如果使用containers来运行这类辅助性工作的容器，里面的容器他是一起启动的，如果您需要Sidecar辅助性容器要有些延迟，在应用容器先行启动的话，建议使用initcontainers来进行创建。</strong></p>
<h2 id="Sidecar可以做什么？"><a href="#Sidecar可以做什么？" class="headerlink" title="Sidecar可以做什么？"></a>Sidecar可以做什么？</h2><p>​	一般边车容器可用来处理以下几个事件：</p>
<ul>
<li>日志代理&#x2F;转发，例如fluentd；</li>
<li>Service Mesh，比如Istio，Linkerd；</li>
<li>代理，比如Docker Ambassador；</li>
<li>探活：检查某些组件是不是正常工作；</li>
<li>其他辅助性工作，比如拷贝文件，下载文件等；</li>
</ul>
<h1 id="静态pod"><a href="#静态pod" class="headerlink" title="静态pod"></a>静态pod</h1><p><strong>正常资源创建流程</strong></p>
<p>​	<code>在此我们可以回忆一下，我们前面介绍的k8s创建一个Pod的流程，kubectl将指令发送给API，API接收到请求后，询问kube-scheduler（调度器）这个Pod适合放在哪个节点上运行，发送给API，API将资源信息存放到etcd数据库，并发送给选中节点中的kubelet，节点中的kubelet把指令翻译成docker看得懂的语言进行创建，并将创建的结果及状态反馈给API，API再将状态信息等数据存入ETCD数据库。所有的资源创建都由API进行监管</code></p>
<p>​	</p>
<p>​	<strong>而静态 Pod 在指定的节点上由 kubelet 守护进程直接管理，不需要 API 服务器监管。</strong> 与由控制面管理的 Pod（例如，Deployment） 不同；kubelet 监视每个静态 Pod（在它失败之后重新启动）。</p>
<p>​	静态 Pod 始终都会绑定到特定节点的 Kubelet 上。</p>
<p>​	既然静态Pod不能API所监管，那么我们为什么可以在kubectl get node的时候看见这些静态Pod呢？</p>
<p>​	kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod 自动创建一个镜像 mirror Pod。 这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。 Pod 名称将把以连字符开头的节点主机名作为后缀。</p>
<h2 id="静态Pod如何创建？"><a href="#静态Pod如何创建？" class="headerlink" title="静态Pod如何创建？"></a>静态Pod如何创建？</h2><p>​	其实静态Pod里我们很近，其实k8s中的API、controller-manager、kube-scheduler就是使用静态Pod进行部署的。我们可以发现这几个Pod他的命名格式跟静态Pod一摸一样，都是组件名+节点主机名进行命名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get pods -A</span><br><span class="line">kube-system   kube-apiserver-k8s-master-01               1/1     Running            17 (24m ago)   17d</span><br><span class="line">kube-system   kube-controller-manager-k8s-master-01      1/1     Running            15 (24m ago)   17d</span><br><span class="line">kube-system   kube-scheduler-k8s-master-01               1/1     Running            15 (24m ago)   17d</span><br></pre></td></tr></table></figure>



<p>​	既然静态Pod是节点中的kubelet进行创建管理的，那么我们可以通过kubelet的守护进程找到静态Pod的配置文件<code>10-kubeadm.conf</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">[root@k8s-master-01 ~]# systemctl status kubelet.service </span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; preset: disabled)</span><br><span class="line">    Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">             └─10-kubeadm.conf</span><br><span class="line">....忽略....</span><br></pre></td></tr></table></figure>

<p>​	找到配置文件后，查看他的配置文件，找到他的config.yaml文件所在目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# <span class="built_in">cat</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf | grep -i Environment</span><br><span class="line">Environment=<span class="string">&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br></pre></td></tr></table></figure>

<p>​	通过它的yaml文件找到它静态Pod的yaml文件存在路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">cat</span> /var/lib/kubelet/config.yaml | grep -i staticPodPath</span><br><span class="line">staticPodPath: /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure>

<p>​	进入到静态Pod的yaml文件存在路径，发现我们的API这些静态Pod的yaml文件全都存放在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# cd /etc/kubernetes/manifests</span><br><span class="line">[root@k8s-master-01 manifests]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 root root 2572  7月  8 16:02 etcd.yaml</span><br><span class="line">-rw-------. 1 root root 3614  7月  8 16:02 kube-apiserver.yaml</span><br><span class="line">-rw-------. 1 root root 3120  7月  8 16:02 kube-controller-manager.yaml</span><br><span class="line">-rw-------. 1 root root 1673  7月  8 16:02 kube-scheduler.yaml</span><br></pre></td></tr></table></figure>

<p>​	这个staticPodPath的路径就非常有意义，所有你在该目录下创建的yaml都会直接为您创建出一个静态Pod，无需您单独去执行任何命令，以下我们就在该目录创建一个简单的Yaml来演示一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在staticPodPath路径下创建一个yaml</span></span><br><span class="line">[root@k8s-master-01 manifests]#<span class="built_in">cat</span> &gt; staticPod.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: staticpod</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: staticpod</span></span><br><span class="line"><span class="string">    image: nginx</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	稍等一会，因为如果您当前节点的本地没有镜像它需要先拉镜像，以及kubelet会定期扫描目录中的变化。在此查询即可发现我们创建的静态资源就出现了。</p>
<p>​	这里我们发现静态Pod是以资源名-节点主机名称的方式来命名的，并且我们可以自由选择将它部署在哪个命名空间下，与我们普通Pod类似，只是创建方式，以及运行流程监管对象不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS             RESTARTS       AGE</span><br><span class="line">book-k8s      staticpod-k8s-master-01                    1/1     Running            0              2m34s</span><br><span class="line">kube-system   calico-kube-controllers-7f59498f59-kf5nn   1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-7ndvs                          1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-l4rfm                          1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-ls56h                          1/1     Running            13 (54m ago)   15d</span><br></pre></td></tr></table></figure>



<h2 id="静态Pod的用途"><a href="#静态Pod的用途" class="headerlink" title="静态Pod的用途"></a>静态Pod的用途</h2><p>​	您可以试想一下，您正常通过API创建的资源，万一哪一天API组件坏了，那么您创建的那个资源也会随着API一起全部宕机掉，但是你当前想要有一个API这个重要的组件即使坏了，也不要影响我这个Pod，那么这个时候您就可以考虑使用静态Pod进行发布。</p>
<p>​	例如：您有一个监控系统负责监控K8s集群中的各个组件以及节点的资源使用情况，那么您的这个监控系统就可以使用静态Pod进行发布，避免因为集群API损坏导致您的监控系统一同失效。</p>
<h2 id="删除静态Pod"><a href="#删除静态Pod" class="headerlink" title="删除静态Pod"></a>删除静态Pod</h2><p>​	由于静态Pod是由kubelet通过扫描静态目录，直接进行创建管理，删除也是非常简单，只需将需要删除的yaml从目录中删除即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">rm</span> -rf staticPod.yaml</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：静态Pod是无法通过kubectl delete [资源名]进行删除，因为它并非由API进行创建的，所有您无法通过该命令进行删除和管理操作，一切的操作只存在于kubelet配置的静态目录中。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">李维虎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/">http://example.com/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归博主所有，如有转载，请注明来自原作者，联系方式（微信）：a1253582301</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a></div><div class="post-share"><div class="social-share" data-image="/img/doc_img/Kubernetes.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章"><img class="cover" src="/img/doc_img/Kubernetes.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CKA-kubernetes-第二章</div></div><div class="info-2"><div class="info-item-1">Kubernetes概述​	Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。 ​	Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。K8s 这个缩写是因为 K 和 s 之间有 8 个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上，...</div></div></div></a><a class="pagination-related" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章"><img class="cover" src="/img/doc_img/Kubernetes.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CKA-kubernetes-第四章</div></div><div class="info-2"><div class="info-item-1">理解什么是K8s控制器什么是控制器​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。 ​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。 ​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方面。最常见的一个控制器是使用一种类型的资源作为它的期望状态，控制器管理控制另外一个资源类型向它的期望状态演化。 ​	例如：您的应用以容器的形式在Pods中运行；但是，直接管理单个Pod的工作量会非常繁琐。当其中一个Pod失败了，您可能希望运行一个新的Pod来替换失败的Pod。K8s控制器会帮您自动完成这些操作。 用于管理工作负载的内置 API 包括：  Deployment （也间接包括 ReplicaSet） 是在集群上运行应用的最常见方式。Deployment 适合在集群上管理无状态应用工作负载， 其中 Deployment 中的任何 Pod 都是可互换的，可以在需要时进行替换。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">CKA-kubernetes-第一章</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="info-item-2">CKA-kubernetes-第五章</div></div><div class="info-2"><div class="info-item-1">服务发现服务（Service）​	将在集群中运行的应用通过同一个面向外界的端点公开出去，即使工作负载分散于多个后端也完全可行。 ​	Kubernetes 中 Service 是 将运行在一个或一组 Pod上的网络应用程序公开为网络服务的方法。 ​	Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用以使用某种不熟悉的服务发现机制。 你可以在 Pod 集合中运行代码，无论该代码是为云原生环境设计的，还是被容器化的老应用。 你可以使用 Service 让一组 Pod 可在网络上访问，这样客户端就能与之交互。 ​	如果你使用 Deployment来运行你的应用， Deployment 可以动态地创建和销毁 Pod。 在任何时刻，你都不知道有多少个这样的 Pod 正在工作以及它们健康与否； 你可能甚至不知道如何辨别健康的 Pod。 Kubernetes Pod 的创建和销毁是为了匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。 ​	每个 Pod 会获得属于自己的 IP 地址（Kubernetes 期待网络插件来保证这一点）。...</div></div></div></a><a class="pagination-related" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-06</div><div class="info-item-2">CKA-kubernetes-第四章</div></div><div class="info-2"><div class="info-item-1">理解什么是K8s控制器什么是控制器​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。 ​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。 ​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方面。最常见的一个控制器是使用一种类型的资源作为它的期望状态，控制器管理控制另外一个资源类型向它的期望状态演化。 ​	例如：您的应用以容器的形式在Pods中运行；但是，直接管理单个Pod的工作量会非常繁琐。当其中一个Pod失败了，您可能希望运行一个新的Pod来替换失败的Pod。K8s控制器会帮您自动完成这些操作。 用于管理工作负载的内置 API 包括：  Deployment （也间接包括 ReplicaSet） 是在集群上运行应用的最常见方式。Deployment 适合在集群上管理无状态应用工作负载， 其中 Deployment 中的任何 Pod 都是可互换的，可以在需要时进行替换。...</div></div></div></a><a class="pagination-related" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-03</div><div class="info-item-2">CKA-kubernetes-第二章</div></div><div class="info-2"><div class="info-item-1">Kubernetes概述​	Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。 ​	Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。K8s 这个缩写是因为 K 和 s 之间有 8 个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李维虎</div><div class="author-info-description">一个热爱技术分享的有志青年</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的<em>博客网站</em>，如对文章内容有疑惑可扫描二维码添加博主微信。</p> <p>文章来之不易，如认为文章不错请在文章底部为博主打赏,你的支持是我持续更新的动力</p> <CENTER><img src="img\index_img/wxewm.png" alt="描述文字" style="width:250px; height:250px;"></CENTER></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubectl%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Kubectl语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#yaml%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">yaml语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API-and-RESOURCES"><span class="toc-number">3.</span> <span class="toc-text">API and RESOURCES</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes%E4%B8%8Edocker%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">Kubernetes与docker的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.1.</span> <span class="toc-text">何时使用多个命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.</span> <span class="toc-text">创建一个具有项目意义的命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.3.</span> <span class="toc-text">为创建资源设置命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%81%8F%E5%A5%BD%EF%BC%88%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">设置命名空间偏好（修改默认命名空间）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.</span> <span class="toc-text">删除命令空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EPod"><span class="toc-number">6.</span> <span class="toc-text">关于Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pod"><span class="toc-number">6.1.</span> <span class="toc-text">使用Pod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.</span> <span class="toc-text">Pod的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E5%AE%B9%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">根容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%AE%B9%E5%99%A8Pod"><span class="toc-number">6.4.</span> <span class="toc-text">创建多容器Pod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9Pod"><span class="toc-number">6.5.</span> <span class="toc-text">修改Pod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">进入容器的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4Pod"><span class="toc-number">6.7.</span> <span class="toc-text">删除Pod</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Init%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">Init类型容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Init%E5%AE%B9%E5%99%A8%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">Init容器特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Init%E5%AE%B9%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">使用Init容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B7%E4%BD%93%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.3.</span> <span class="toc-text">Init容器的具体行为</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sidecar%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">Sidecar类型容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sidecar%E5%AE%B9%E5%99%A8%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">Sidecar容器特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5init%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8Sidecar"><span class="toc-number">8.2.</span> <span class="toc-text">以init容器启动Sidecar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E6%99%AE%E9%80%9A%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8Sidecar"><span class="toc-number">8.3.</span> <span class="toc-text">以普通容器启动Sidecar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sidecar%E4%B8%8Einit%E5%92%8C%E6%99%AE%E9%80%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">Sidecar与init和普通容器的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sidecar%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">Sidecar可以做什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81pod"><span class="toc-number">9.</span> <span class="toc-text">静态pod</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81Pod%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">静态Pod如何创建？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81Pod%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">9.2.</span> <span class="toc-text">静态Pod的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%9D%99%E6%80%81Pod"><span class="toc-number">9.3.</span> <span class="toc-text">删除静态Pod</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第五章"/></a><div class="content"><a class="title" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章">CKA-kubernetes-第五章</a><time datetime="2025-10-10T01:45:13.000Z" title="发表于 2025-10-10 09:45:13">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第四章"/></a><div class="content"><a class="title" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章">CKA-kubernetes-第四章</a><time datetime="2025-08-06T08:04:01.000Z" title="发表于 2025-08-06 16:04:01">2025-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第三章"/></a><div class="content"><a class="title" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章">CKA-kubernetes-第三章</a><time datetime="2025-07-14T03:36:45.000Z" title="发表于 2025-07-14 11:36:45">2025-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第二章"/></a><div class="content"><a class="title" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章">CKA-kubernetes-第二章</a><time datetime="2025-07-03T01:40:06.000Z" title="发表于 2025-07-03 09:40:06">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第一章"/></a><div class="content"><a class="title" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章">CKA-kubernetes-第一章</a><time datetime="2025-06-05T02:38:53.000Z" title="发表于 2025-06-05 10:38:53">2025-06-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/doc_img/Kubernetes.webp);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 李维虎</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">主题框架声明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="晚,上,好" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>