<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CKA-kubernetes-第四章 | 欢迎来到李维虎的在线博客</title><meta name="author" content="李维虎"><meta name="copyright" content="李维虎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="理解什么是K8s控制器什么是控制器​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。 ​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。 ​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方">
<meta property="og:type" content="article">
<meta property="og:title" content="CKA-kubernetes-第四章">
<meta property="og:url" content="http://example.com/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/index.html">
<meta property="og:site_name" content="欢迎来到李维虎的在线博客">
<meta property="og:description" content="理解什么是K8s控制器什么是控制器​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。 ​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。 ​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/doc_img/Kubernetes.webp">
<meta property="article:published_time" content="2025-08-06T08:04:01.000Z">
<meta property="article:modified_time" content="2025-10-09T09:46:37.880Z">
<meta property="article:author" content="李维虎">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/doc_img/Kubernetes.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CKA-kubernetes-第四章",
  "url": "http://example.com/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/",
  "image": "http://example.com/img/doc_img/Kubernetes.webp",
  "datePublished": "2025-08-06T08:04:01.000Z",
  "dateModified": "2025-10-09T09:46:37.880Z",
  "author": [
    {
      "@type": "Person",
      "name": "李维虎",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/index_img/logo.png"><link rel="canonical" href="http://example.com/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CKA-kubernetes-第四章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/doc_img/Kubernetes.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/index_img/butterfly-icon.png" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">CKA-kubernetes-第四章</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CKA-kubernetes-第四章<a class="post-edit-link" href="null_posts/03-Kubernetes/CKA-kubernetes-第四章.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-06T08:04:01.000Z" title="发表于 2025-08-06 16:04:01">2025-08-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-09T09:46:37.880Z" title="更新于 2025-10-09 17:46:37">2025-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="理解什么是K8s控制器"><a href="#理解什么是K8s控制器" class="headerlink" title="理解什么是K8s控制器"></a>理解什么是K8s控制器</h1><h2 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h2><p>​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。</p>
<p>​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。</p>
<p>​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方面。最常见的一个控制器是使用一种类型的资源作为它的期望状态，控制器管理控制另外一个资源类型向它的期望状态演化。</p>
<p>​	例如：您的应用以容器的形式在Pods中运行；但是，直接管理单个Pod的工作量会非常繁琐。当其中一个Pod失败了，您可能希望运行一个新的Pod来替换失败的Pod。K8s控制器会帮您自动完成这些操作。</p>
<p><strong>用于管理工作负载的内置 API 包括</strong>：</p>
<ul>
<li>Deployment （也间接包括 ReplicaSet） 是在集群上运行应用的最常见方式。Deployment 适合在集群上管理无状态应用工作负载， 其中 Deployment 中的任何 Pod 都是可互换的，可以在需要时进行替换。 （Deployment 替代原来的 ReplicationController API）。</li>
<li>StatefulSet 允许你管理一个或多个运行相同应用代码、但具有不同身份标识的 Pod。 StatefulSet 与 Deployment 不同。Deployment 中的 Pod 预期是可互换的。 StatefulSet 最常见的用途是能够建立其 Pod 与其持久化存储之间的关联。 例如，你可以运行一个将每个 Pod 关联到 PersistentVolume 的 StatefulSet。如果该 StatefulSet 中的一个 Pod 失败了，Kubernetes 将创建一个新的 Pod， 并连接到相同的 PersistentVolume。</li>
<li>DaemonSet 定义了在特定节点上提供本地设施的 Pod， 例如允许该节点上的容器访问存储系统的驱动。当必须在合适的节点上运行某种驱动或其他节点级别的服务时， 你可以使用 DaemonSet。DaemonSet 中的每个 Pod 执行类似于经典 Unix &#x2F; POSIX 服务器上的系统守护进程的角色。DaemonSet 可能对集群的操作至关重要， 例如作为插件让该节点访问集群网络， 也可能帮助你管理节点，或者提供增强正在运行的容器平台所需的、不太重要的设施。 你可以在集群的每个节点上运行 DaemonSets（及其 Pod），或者仅在某个子集上运行 （例如，只在安装了 GPU 的节点上安装 GPU 加速驱动）。</li>
<li>你可以使用 Job 和&#x2F;或 CronJob 定义一次性任务和定时任务。 Job 表示一次性任务，而每个 CronJob 可以根据排期表重复执行。</li>
</ul>
<p>​	</p>
<h2 id="ReplicaSet控制器"><a href="#ReplicaSet控制器" class="headerlink" title="ReplicaSet控制器"></a>ReplicaSet控制器</h2><p>​	ReplicaSet控制器确保在任何时候都有特定数量的Pod副本处于运行状态，也就是说通过ReplicaSet控制器创建的多个Pods都会被ReplicaSet控制器所控制，并保证这些Pods总是处于可用正常运行的状态。</p>
<p>​	例如：您通过ReplicaSet控制器创建了一组Pod数量为3个，在运行过程中如果其中一个Pod宕机或者被删除了，那么ReplicaSet控制器就会自动创建一个Pod，以保证您期望的3个Pod始终在线。</p>
<h3 id="何时使用ReplicaSet"><a href="#何时使用ReplicaSet" class="headerlink" title="何时使用ReplicaSet"></a>何时使用ReplicaSet</h3><p>​	ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。</p>
<p>​	这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义你的应用。Deployment后续会相继介绍。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>​	<strong>YAML关键参数解析</strong></p>
<ul>
<li><strong>spec.selector.matchLabels</strong>：标签选择器，用于ReplicaSet控制器选定哪些Pod归该资源进行控制，这是控制器重要的参数。</li>
<li><strong>spec.replicas</strong>：副本数，用于设定您期望的Pod副本数，控制器将始终保持该组Pod数接近您期望的数值。</li>
<li><strong>spec.template</strong>：该模块下面用于定义您的Pod以及容器的创建模板，于之前学习的创建Pod的YAML类似。</li>
<li><strong>spec.template.metadata.labels</strong>：为Pod定义标签，与selector(标签选择器)相互配合，为Pod创建标签，标签相互匹配后，ReplicaSet控制器即可将该组Pod归为自己管理的Pod组。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; replicaset.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: ReplicaSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">  name: nginx-rs</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 3</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          protocol: TCP</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行Yaml文件创建资源，可以使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f replicaset.yaml</span><br></pre></td></tr></table></figure>

<p>​	查看资源创建状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询目前存在一个名为nginx-rs的ReplicaSet资源</span></span><br><span class="line"><span class="comment"># DESIRED期望副本数3，CURRENT当前副本数3，READY正在允许的副本数3</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get -f replicaset.yaml </span><br><span class="line">NAME       DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-rs   3         3         3       20h</span><br><span class="line"><span class="comment"># 通过--show-labels显示资源标签，-l搜索具有app=nginx标签的资源</span></span><br><span class="line"><span class="comment"># 当前具有3个受ReplicaSet管理的Pod资源</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-5p8k8   1/1     Running   1 (16m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (16m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (16m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>

<p>​	当您通过命名删除一个Pod，模拟某一个Pod掉线的情况时，秒删除，秒级速度为您重新拉起一个新的Pod，以保证您该组Pod副本数始终保持为3。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除其中一个Pod</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl delete pods  nginx-rs-5p8k8</span><br><span class="line">pod <span class="string">&quot;nginx-rs-5p8k8&quot;</span> deleted</span><br><span class="line"><span class="comment"># ReplicaSet控制器马上新拉起一个名为nginx-rs-fmdqf的Pod，保证副本数处于3</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (25m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-fmdqf   1/1     Running   0             2s    app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (26m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>

<p>​	<strong>重要：由于ReplicaSet控制器是通过标签来进行管理和识别当前的副本数的，如果此刻您的副本数是满足的，您手动创建了一个具备选择器选择的相同标签的Pod，那么您手动创建的这个Pod马上就会被控制器删除掉，因为控制器会检测到这个Pod，发现副本数超了，控制器会把最后创建的给删掉。</strong></p>
<p>​	<strong>如果您手动创建具备同标签的Pod时，刚好副本数当前是不满足的状态，那么你新创建的这个Pod会加入到ReplicaSet控制器进行管理，即便他里面的images不同。</strong></p>
<p>​	<strong>所以我们在使用和管理K8s时，最好使用yaml进行统一创建和删除，同时前期也要对您部署的微服务做好统一的规划，避免冲突出现。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动创建一个名为：centos，使用的镜像为：centos，并且同样具备app=nginx标签的pod</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl run --image centos  -l app=nginx centos</span><br><span class="line">pod/centos created</span><br><span class="line"><span class="comment"># 再次查询发现新创建的Pod不存在，被控制器删掉了</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (38m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-fmdqf   1/1     Running   0             12m   app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (38m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>



<h2 id="Deployments控制器"><a href="#Deployments控制器" class="headerlink" title="Deployments控制器"></a>Deployments控制器</h2><p>​	Deployment用于管理运行一个应用负载的一组Pod，通常适用于不保持状态的负载。</p>
<h3 id="Deployment与ReplicaSet区别"><a href="#Deployment与ReplicaSet区别" class="headerlink" title="Deployment与ReplicaSet区别"></a><strong>Deployment与ReplicaSet区别</strong></h3><p>​	Deployment是一个可以拥有ReplicaSet并使用声明式方式再服务器端完成对Pod滚动更新的对象。尽管ReplicaSet可以独立使用，但它的主要用途是作为Deployment的编排Pod创建、删除、更新和Pod 自动扩缩器的一种机制，因为有了Deployment使得它们整体更加的健硕。当您使用了Deployment时，您不需要关心如何管理它所创建的ReplicaSet，Deployment 拥有并管理其 ReplicaSet。 因此，建议你在需要 ReplicaSet 时使用 Deployment，并且管理整个架构时仅需对Deployment进行管理，再由Deployment去管理旗下的ReplicaSet或Pod。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>​	创建Deployment的yaml文件，用于创建和管理该Deployment，重点Yaml参数解析如下：</p>
<ul>
<li>spec.replicas：该Deployment所创建管理的ReplicaSet控制器的期望副本数。</li>
<li>spec.replicas.selector.matchLabels：用于创建Deployment以及它所创建的ReplicaSet的标签选择器，用于标识归其所管理的Pod资源。</li>
<li>spec.template：以下为所创建具体资源Pod的模板类。</li>
<li>spec.template.metadata.labels：用于该模板Pod创建时具有的标签，与标签选择器一致，标识这些具有同类标签的为一组资源，归该Deployment所管理。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line">  name: nginx-dlt</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-dlt</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-dlt</span><br><span class="line">      namespace: book-k8s</span><br><span class="line">    spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: nginx-dlt</span><br><span class="line">       image: nginx:1.14.2</span><br><span class="line">       imagePullPolicy: IfNotPresent</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 80</span><br><span class="line">         protocol: TCP</span><br></pre></td></tr></table></figure>

<p>​	运行Yaml文件创建资源，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f deployment.yaml </span><br><span class="line">deployment.apps/nginx-dlt created</span><br></pre></td></tr></table></figure>

<p>​	查看Deployment资源创建状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt --show-labels </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE   LABELS</span><br><span class="line">nginx-dlt   3/3     3            3           10m   &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	根据标签查看Deployment创建并管理的ReplicaSet资源状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE   LABELS</span><br><span class="line">nginx-dlt-7b5fbfc86b   3         3         3       13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br></pre></td></tr></table></figure>

<p>​	根据标签查看ReplicaSet资源所创建的Pod状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pod -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-dlt-7b5fbfc86b-89t7p   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br><span class="line">nginx-dlt-7b5fbfc86b-ckl5k   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br><span class="line">nginx-dlt-7b5fbfc86b-frkt8   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br></pre></td></tr></table></figure>



<h3 id="Deployment滚动更新"><a href="#Deployment滚动更新" class="headerlink" title="Deployment滚动更新"></a>Deployment滚动更新</h3><p>​	根据上述示例，我们创建了一个具有nginx:1.14.2镜像的Pod服务，此刻我们希望将镜像更新为nginx:1.16.1版本，可以按照如下操作进行滚动更新。</p>
<ul>
<li>kubectl：二进制命令</li>
<li>set：修改</li>
<li>image：镜像</li>
<li>deployments：修改的资源是deployments资源</li>
<li>nginx-dlt：deployments的资源名称</li>
<li>ginx-dlt：创建容器时的容器名，标识要修改哪个容器</li>
<li>&#x3D;nginx:1.16.1：要更新的容器镜像版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<p>​	更新完成后，我们会发现我们的rs会多出一条，但是其中一个rs是之前我们初次创建deployment时生成的rs，当前该rs处于全员下线的状态，这就是我们前面所说的，滚动更新，他会新增一个rs，并仅关闭一定数量的Pod，最新版本的rs中有一个Pod启动了，旧的rs就会下线一个，依次滚动轮换，始终保持更新业务不间断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE    LABELS</span><br><span class="line">nginx-dlt-6dbffd95f4   0         0         0       10m    app=nginx-dlt,pod-template-hash=6dbffd95f4</span><br><span class="line">nginx-dlt-7f77dfcf6c   3         3         3       8m5s   app=nginx-dlt,pod-template-hash=7f77dfcf6c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	以防万一，我们还可以通过describe选项查看deployment详细资源描述，验证镜像是否已更换为最新版本镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.16.1</span><br></pre></td></tr></table></figure>







<h3 id="Deployment版本回滚"><a href="#Deployment版本回滚" class="headerlink" title="Deployment版本回滚"></a>Deployment版本回滚</h3><p>​	如果我们在版本更新后发现，新版本存在重大BUG，我们需要将新版本回退到之前的版本，我们可以按照如下方法进行操作。</p>
<p>​	首先使用<code>rollout</code>选项中的<code>history</code>，查看名为nginx-dlt的deployment资源更新记录。最终我们将查看到该资源所更新过的所有记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	但是上述给出的信息仅有更新的顺序编号1、2，另外有字段是none（空），这时我们可以通过加上<code>--revision 编号</code>的方式，查看该编号具体对应的是我哪次版本的更新，经过查找，发现序号1是我需要回滚的版本为1.14.2的记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt --revision 1</span><br><span class="line">deployment.apps/nginx-dlt with revision <span class="comment">#1</span></span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:	app=nginx-dlt</span><br><span class="line">	pod-template-hash=6dbffd95f4</span><br><span class="line">  Containers:</span><br><span class="line">   nginx-dlt:</span><br><span class="line">    Image:	nginx:1.14.2</span><br><span class="line">    Port:	80/TCP</span><br><span class="line">    Host Port:	0/TCP</span><br><span class="line">    Environment:	&lt;none&gt;</span><br><span class="line">    Mounts:	&lt;none&gt;</span><br><span class="line">  Volumes:	&lt;none&gt;</span><br><span class="line">  Node-Selectors:	&lt;none&gt;</span><br><span class="line">  Tolerations:	&lt;none&gt;</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt --revision 2</span><br><span class="line">deployment.apps/nginx-dlt with revision <span class="comment">#2</span></span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:	app=nginx-dlt</span><br><span class="line">	pod-template-hash=7f77dfcf6c</span><br><span class="line">  Containers:</span><br><span class="line">   nginx-dlt:</span><br><span class="line">    Image:	nginx:1.16.1</span><br><span class="line">    Port:	80/TCP</span><br><span class="line">    Host Port:	0/TCP</span><br><span class="line">    Environment:	&lt;none&gt;</span><br><span class="line">    Mounts:	&lt;none&gt;</span><br><span class="line">  Volumes:	&lt;none&gt;</span><br><span class="line">  Node-Selectors:	&lt;none&gt;</span><br><span class="line">  Tolerations:	&lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	得知我们要回退的记录序号是1后，可通过<code>rollout</code>选项中的<code>undo</code>，对名为nginx-dlt的deployment资源，<code>--to-revision 1</code>将版本退回到1.14.2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout undo deployment nginx-dlt --to-revision 1</span><br><span class="line">deployment.apps/nginx-dlt rolled back</span><br></pre></td></tr></table></figure>

<p>​	查看资源详细信息，确认版本是否回退。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.14.2</span><br></pre></td></tr></table></figure>



<h3 id="CHANGE-CAUSE变更描述"><a href="#CHANGE-CAUSE变更描述" class="headerlink" title="CHANGE-CAUSE变更描述"></a>CHANGE-CAUSE变更描述</h3><p>​	上述介绍回滚时，我们使用<code>rollout history</code>查看历史更新记录时，发现<code>CHANGE-CAUSE</code>字段是一个为空的，所以我们只能使用<code>--revision 2</code>查看具体版本信息，已确认我们要回退的序号是多少。</p>
<p>​	CHANGE-CAUSE 的内容是从 Deployment 的 kubernetes.io&#x2F;change-cause 注解复制过来的。 复制动作发生在修订版本创建时。你可以通过以下方式设置 CHANGE-CAUSE 消息：</p>
<ul>
<li>使用 <code>[root@k8s-master-01 controller]# kubectl annotate deployments.apps nginx-dlt kubernetes.io/change-cause=&quot;image updated to 1.14.2&quot;</code> 为 当前版本的Deployment 添加注解。</li>
<li>手动编辑资源的清单。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl annotate deployments.apps nginx-dlt kubernetes.io/change-cause=<span class="string">&quot;image updated to 1.14.2&quot;</span> </span><br><span class="line">deployment.apps/nginx-dlt annotated</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         &lt;none&gt;</span><br><span class="line">3         image updated to 1.14.2</span><br></pre></td></tr></table></figure>

<p>​	或者您也可以在滚动更新时，加上–cored字段为其自动将您当前的命令当作注解进行添加。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record</span><br><span class="line">Flag --record has been deprecated, --record will be removed <span class="keyword">in</span> the future</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         image updated to 1.14.2</span><br><span class="line">4         kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>​	这样既可以清楚的看出每个版本更新的内容介绍，便于版本的回退及管理。</p>
<h3 id="扩缩容Deployment"><a href="#扩缩容Deployment" class="headerlink" title="扩缩容Deployment"></a>扩缩容Deployment</h3><p>​	您可以根据业务压力情况，灵活的对Deployment使用如下指令手动进行扩缩容操作 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 2</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   2/2     2            2           4h1m</span><br><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 4</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   4/4     4            4           3h59m</span><br></pre></td></tr></table></figure>

<p>​	假设集群启用了 Pod 的水平自动缩放， 你可以为 Deployment 设置自动缩放器，并基于现有 Pod 的 CPU 利用率选择要运行的 Pod 个数下限和上限。</p>
<p>​	这样可以让控制器进行自我调节，基于现有Pod的CPU利用率达到80，最大可自动扩容值15个副本，最小保持在10个副本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl autoscale deployment nginx-dlt --max 15 --min 10 --cpu-percent 80</span><br><span class="line">horizontalpodautoscaler.autoscaling/nginx-dlt autoscaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   10/10   10           10          4h14m</span><br></pre></td></tr></table></figure>





<h3 id="比例缩放"><a href="#比例缩放" class="headerlink" title="比例缩放"></a>比例缩放</h3><p>​	RollingUpdate 的 Deployment 支持同时运行应用程序的多个版本。 当自动缩放器缩放处于上线进程（仍在进行中或暂停）中的 RollingUpdate Deployment 时， Deployment 控制器会平衡现有的活跃状态的 ReplicaSet（含 Pod 的 ReplicaSet）中的额外副本， 以降低风险。这称为<strong>比例缩放（Proportional Scaling）</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:sometag</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<p>​	例如，你正在运行一个 10 个副本的 Deployment，其中25% max unavailable（最大不可用）, 25% max surge（最大激增）</p>
<ul>
<li>确保有10个副本正在运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   10/10   10           10          4h14m</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 Deployment 使用新镜像，碰巧该镜像无法从集群内部解析，这里采用更新一个不存在的镜像来演示阻塞。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:sometag</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>镜像更新使用 ReplicaSet <code>nginx-dlt-6788c467d8</code> 启动新的上线过程， 但由于上面提到的 <code>maxUnavailable</code> （最大不可用）、<code>maxSurge</code>（最大激增）要求，该进程当被创建出第五个副本时被阻塞了。检查上线状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6788c467d8   5         5         0       3s</span><br><span class="line">nginx-dlt-7f77dfcf6c   8         8         8       4h20m</span><br></pre></td></tr></table></figure>

<ul>
<li>然后，出现了新的 Deployment 扩缩请求。自动缩放器将 Deployment 副本增加到 15。 Deployment 控制器需要决定在何处添加 5 个新副本。如果未使用比例缩放，所有 5 个副本 都将添加到新的 ReplicaSet 中。使用比例缩放时，可以将额外的副本分布到所有 ReplicaSet。 较大比例的副本会被添加到拥有最多副本的 ReplicaSet，而较低比例的副本会进入到 副本较少的 ReplicaSet。所有剩下的副本都会添加到副本最多的 ReplicaSet。 具有零副本的 ReplicaSet 不会被扩容。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 15</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br></pre></td></tr></table></figure>

<p>​	在上面的示例中，新的rs数量是5，旧的是8，通过扩容至15，为满足扩容需要的需求，所以4个副本被添加到旧 ReplicaSet 中，2 个副本被添加到新 ReplicaSet。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6788c467d8   7         7         0       4m54s</span><br><span class="line">nginx-dlt-7f77dfcf6c   12        12        12      4h25m</span><br></pre></td></tr></table></figure>

<p>​	假定新的副本都很健康，上线过程最终应将所有副本迁移到新的 ReplicaSet 中。 要确认这一点，请运行：</p>
<p>​	但是该演示为了演示阻塞，仅有旧副本的12个是正常的，此为演示需要。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deploy</span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   12/15   7            12          4h51m</span><br></pre></td></tr></table></figure>



<h3 id="删除水平伸缩扩容"><a href="#删除水平伸缩扩容" class="headerlink" title="删除水平伸缩扩容"></a>删除水平伸缩扩容</h3><p>​	当您要清除水平伸缩策略时，可以通过如下命令来进行删除。如您删除控制器，但是未删除水平伸缩策略，并重新创建同一名称资源，您之前所创建的策略会应用在新创建的资源中。</p>
<ul>
<li>查看水平伸缩策略</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get horizontalpodautoscalers.autoscaling nginx-dlt </span><br><span class="line">NAME        REFERENCE              TARGETS              MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-dlt   Deployment/nginx-dlt   cpu: &lt;unknown&gt;/80%   10        15        10         108m</span><br></pre></td></tr></table></figure>

<ul>
<li>删除水平伸缩策略</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl delete horizontalpodautoscalers.autoscaling nginx-dlt </span><br><span class="line">horizontalpodautoscaler.autoscaling <span class="string">&quot;nginx-dlt&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<ul>
<li>删除资源，重新创建。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl delete -f deployment.yaml </span><br><span class="line">deployment.apps <span class="string">&quot;nginx-dlt&quot;</span> deleted</span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f deployment.yaml </span><br><span class="line">deployment.apps/nginx-dlt created</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   3/3     3            3           14s</span><br></pre></td></tr></table></figure>





<h3 id="暂停与恢复Deployment-的上线过程"><a href="#暂停与恢复Deployment-的上线过程" class="headerlink" title="暂停与恢复Deployment 的上线过程"></a>暂停与恢复Deployment 的上线过程</h3><p>​	在你更新一个 Deployment 的时候，或者计划更新它的时候， 你可以在触发一个或多个更新之前暂停 Deployment 的上线过程。 当你准备应用这些变更时，你可以重新恢复 Deployment 上线过程。 这样做使得你能够在暂停和恢复执行之间应用多个修补程序，而不会触发不必要的上线操作。</p>
<ul>
<li>例如，对于一个刚刚创建的 Deployment，获取Deployment、rs上线状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps,replicasets.apps --show-labels -l app=nginx-dlt</span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE   LABELS</span><br><span class="line">deployment.apps/nginx-dlt   3/3     3            3           12s   app=nginx-dlt</span><br><span class="line"></span><br><span class="line">NAME                                   DESIRED   CURRENT   READY   AGE   LABELS</span><br><span class="line">replicaset.apps/nginx-dlt-6dbffd95f4   3         3         3       12s   app=nginx-dlt,pod-template-hash=6dbffd95f4</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下指令对名为nginx-dlt的deployment资源启用暂停上线：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout pause deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt paused</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下指令对资源进行滚动更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record</span><br><span class="line">Flag --record has been deprecated, --record will be removed <span class="keyword">in</span> the future</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<ul>
<li>但是我们查看更新记录中并未存在我们刚才更新的那条记录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看deployment资源中当前的镜像版本是1.16.1是最新版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.16.1</span><br></pre></td></tr></table></figure>

<ul>
<li>最终再查看rs中还是原来的1.14.2的版本，说明我们实际的Pod并未更新成功，仅是deployment变更了而已，但是实际的rs控制Pod的资源实际还是原本的版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe rs nginx-dlt-6dbffd95f4 | grep -i Image:</span><br><span class="line">    Image:         nginx:1.14.2</span><br></pre></td></tr></table></figure>

<ul>
<li>那是因为我们之前做了上线暂停的操作导致的，您可以根据需要在暂停和恢复期间做更多的操作，避免未作完更改操作，提前上线，造成不必要的麻烦，例如您还想对该Pod申请更多的<code>cpu=200m、memory=512Mi</code>cpu和内存资源等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> resources -f deployment.yaml  -c=nginx-dlt --limits=cpu=200m,memory=512Mi</span><br><span class="line">deployment.apps/nginx-dlt resource requirements updated</span><br></pre></td></tr></table></figure>

<ul>
<li>当您确认修改好后，想要恢复上线过程，可以是使用如下命令进行恢复。</li>
<li>此时即可看到rs正常开始上线新版本，并且版本已变为最新，以及最新的更新记录中也产生了部署记录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6dbffd95f4   0         0         0       21m</span><br><span class="line">nginx-dlt-7495f89c5    3         3         3       13s</span><br><span class="line">[root@k8s-master-01 controller]# kubectl describe rs nginx-dlt-7495f89c5 | grep Image:</span><br><span class="line">    Image:      nginx:1.16.1</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><p>​	您在生产中可能会有如下困惑，每次set更新<code>ReplicaSet</code>都会产生一条记录，并且该记录当积累到10条以后，会开始从旧版本中依次删除替换。</p>
<p>​	您如果想对<code>ReplicaSet</code>的条数有所调整的话，可以在创建Deployment的YAML文件中设置 <code>.spec.revisionHistoryLimit</code> 字段以指定保留此 Deployment 的多少个旧有 ReplicaSet。其余的 ReplicaSet 将在后台被垃圾回收。 默认情况下，此值为 10。</p>
<p>​	可参考以下示例,以下示例中<code>revisionHistoryLimit</code>值设置为0，则每次set更新，都只会保留最新的一个rs，旧的会直接被删除，如果您想能够多保留几次，则可以将该值放大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line">  name: nginx-dlt</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 0</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-dlt</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-dlt</span><br><span class="line">      namespace: book-k8s</span><br><span class="line">    spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: nginx-dlt</span><br><span class="line">       image: nginx:1.14.2</span><br><span class="line">       imagePullPolicy: IfNotPresent</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 80</span><br><span class="line">         protocol: TCP</span><br></pre></td></tr></table></figure>

<ul>
<li>确认当前的rs名称</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6dbffd95f4   3         3         3       3s</span><br></pre></td></tr></table></figure>

<ul>
<li>进行更新操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<ul>
<li>查看rs，由于<code>revisionHistoryLimit</code>设置的是0，所以原先版本的rs会被直接删除，替换为新的rs，旧的不再保留。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-7f77dfcf6c   3         3         3       22s</span><br></pre></td></tr></table></figure>

<ul>
<li>但是需要注意，生产环境不能设置为0，因为这同时也会影响回滚的历史部署记录，这回导致您无法通过<code>rollout history</code>进行回滚操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout history deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         &lt;none&gt;</span><br></pre></td></tr></table></figure>





<h2 id="DaemonSet控制器"><a href="#DaemonSet控制器" class="headerlink" title="DaemonSet控制器"></a>DaemonSet控制器</h2><p>​	DaemonSet定义了提供节点本地设施的Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具、资源监控，或者作为add-on的一部分。</p>
<p>​	DaemonSet会确保全部（或者某些）节点上运行一个Pod的副本。当有节点加入集群时，也会为他自动新增一个Pod副本。当有节点被从集群中移除时，这些Pod也会被收回。删除DaemonSet将会删除它所创建的所有Pod。</p>
<p><strong>DaemonSet的一些经典用法</strong>：</p>
<ul>
<li>在每个节点上运行集群守护进程。</li>
<li>在每个节点上运行日志收集守护进程。</li>
<li>在每个节点上运行监控守护进程。</li>
</ul>
<p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。</p>
<h3 id="编写DaemonSet规约"><a href="#编写DaemonSet规约" class="headerlink" title="编写DaemonSet规约"></a>编写DaemonSet规约</h3><ul>
<li><strong>kind: DaemonSet</strong>：创建一个资源类型为DaemonSet的资源。</li>
<li><strong>spec.template.spec.tolerations</strong>：该参数为容忍度，由于目前的要求是在所有节点上都要运行一个这样模板的Pod，在K8s默认的调度机制中，master节点是不允许运行的，所有这里要加个容忍度，让节点能够容忍该污点，具体细节后续章节中详细介绍。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; daemonSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: DaemonSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-ds</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ds</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx-ds</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: nginx-ds</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx-ds</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      tolerations:</span></span><br><span class="line"><span class="string">      - effect: NoSchedule</span></span><br><span class="line"><span class="string">        key: node-role.kubernetes.io/control-plane</span></span><br><span class="line"><span class="string">        operator: Exists</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx-ds</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行yaml，创建资源，可尝试使用如下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f daemonSet.yaml </span><br><span class="line">daemonset.apps/nginx-ds created</span><br></pre></td></tr></table></figure>

<p>​	执行后，查看想要运行结果。</p>
<p>​	<strong>发现该模板中我们并没有像deployment一样设定副本数，但是他能根据我们集群中拥有的节点数创建出对应数量的Pod副本。由于我们使用的允许容忍度，让本不执行实际工作Pod的master节点，也同时运行着该Pod副本。	所以这实验结果也就验证了最开始我们介绍的，DaemonSet的作用是可为您每个节点都运行一个Pod副本，有且只有一个。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx-ds --show-labels -o wide </span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP               NODE            NOMINATED NODE   READINESS GATES   LABELS</span><br><span class="line">nginx-ds-6wzn7   1/1     Running   0          24s   10.244.44.245    k8s-node-02     &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br><span class="line">nginx-ds-9rlrh   1/1     Running   0          24s   10.244.154.234   k8s-node-01     &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br><span class="line">nginx-ds-qm4f5   1/1     Running   0          24s   10.244.151.143   k8s-master-01   &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br></pre></td></tr></table></figure>



<h3 id="DaemonSet的调度"><a href="#DaemonSet的调度" class="headerlink" title="DaemonSet的调度"></a>DaemonSet的调度</h3><p>DaemonSet 可用于确保所有符合条件的节点都运行该 Pod 的一个副本。 DaemonSet 控制器为每个符合条件的节点创建一个 Pod，并添加 Pod 的 <code>spec.affinity.nodeAffinity</code> 字段以匹配目标主机。Pod 被创建之后，默认的调度程序通常通过设置 <code>.spec.nodeName</code> 字段来接管 Pod 并将 Pod 绑定到目标主机。如果新的 Pod 无法放在节点上，则默认的调度程序可能会根据新 Pod 的优先级抢占 （驱逐）某些现存的 Pod。</p>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>当 DaemonSet 中的 Pod 必须运行在每个节点上时，通常需要将 DaemonSet 的 <code>.spec.template.spec.priorityClassName</code> 设置为具有更高优先级的 PriorityClass， 以确保可以完成驱逐。</p>
<p>用户通过设置 DaemonSet 的 <code>.spec.template.spec.schedulerName</code> 字段，可以为 DaemonSet 的 Pod 指定不同的调度程序。</p>
<p>当评估符合条件的节点时，原本在 <code>.spec.template.spec.affinity.nodeAffinity</code> 字段上指定的节点亲和性将由 DaemonSet 控制器进行考量，但在创建的 Pod 上会被替换为与符合条件的节点名称匹配的节点亲和性。</p>
<p><code>ScheduleDaemonSetPods</code> 允许你使用默认调度器而不是 DaemonSet 控制器来调度这些 DaemonSet， 方法是将 <code>NodeAffinity</code> 条件而不是 <code>.spec.nodeName</code> 条件添加到这些 DaemonSet Pod。 默认调度器接下来将 Pod 绑定到目标主机。 如果 DaemonSet Pod 的节点亲和性配置已存在，则被替换 （原始的节点亲和性配置在选择目标主机之前被考虑）。 DaemonSet 控制器仅在创建或修改 DaemonSet Pod 时执行这些操作， 并且不会更改 DaemonSet 的 <code>spec.template</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nodeAffinity:</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">    nodeSelectorTerms:</span><br><span class="line">    - matchFields:</span><br><span class="line">      - key: metadata.name</span><br><span class="line">        operator: In</span><br><span class="line">        values:</span><br><span class="line">        - target-host-name</span><br></pre></td></tr></table></figure>



<h3 id="DaemonSet滚动更新"><a href="#DaemonSet滚动更新" class="headerlink" title="DaemonSet滚动更新"></a>DaemonSet滚动更新</h3><p>​	首先我们需要先确保原有Pod模板中带有 <code>RollingUpdate</code> 更新策略的 DaemonSet，如果没有，可根据如下操作对资源设定一个具有 <code>RollingUpdate</code> 更新策略的 DaemonSet。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; daemonSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: DaemonSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-ds</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ds</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  updateStrategy: </span></span><br><span class="line"><span class="string">    type: RollingUpdate</span></span><br><span class="line"><span class="string">    rollingUpdate: </span></span><br><span class="line"><span class="string">    # 最大不可用</span></span><br><span class="line"><span class="string">      maxUnavailable: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx-ds</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: nginx-ds</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx-ds</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      tolerations:</span></span><br><span class="line"><span class="string">      - effect: NoSchedule</span></span><br><span class="line"><span class="string">        key: node-role.kubernetes.io/control-plane</span></span><br><span class="line"><span class="string">        operator: Exists</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx-ds</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	更新模板，可使用如下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl apply -f daemonSet.yaml </span><br><span class="line">Warning: resource daemonsets/nginx-ds is missing the kubectl.kubernetes.io/last-applied-configuration annotation <span class="built_in">which</span> is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.</span><br><span class="line">daemonset.apps/nginx-ds configured</span><br></pre></td></tr></table></figure>

<p>​	最后检查 DaemonSet 的更新策略，确保已经将其设置为 <code>RollingUpdate</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl apply -f daemonSet.yaml --dry-run=client -o go-template=<span class="string">&#x27;&#123;&#123;.spec.updateStrategy.type&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#x27;</span></span><br><span class="line">RollingUpdate</span><br></pre></td></tr></table></figure>

<p>​	命令的输出都应该为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RollingUpdate</span><br></pre></td></tr></table></figure>



<h4 id="声明式命令"><a href="#声明式命令" class="headerlink" title="声明式命令"></a>声明式命令</h4><p>如果你使用配置文件来更新 DaemonSet，请使用 <code>kubectl apply</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f daemonSet.yaml</span><br></pre></td></tr></table></figure>

<h4 id="指令式命令"><a href="#指令式命令" class="headerlink" title="指令式命令"></a>指令式命令</h4><p>如果你使用指令式命令来更新 DaemonSets，请使用 <code>kubectl edit</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit ds/nginx-ds -n kube-system</span><br></pre></td></tr></table></figure>

<h5 id="只更新容器镜像"><a href="#只更新容器镜像" class="headerlink" title="只更新容器镜像"></a>只更新容器镜像</h5><p>如果你只需要更新 DaemonSet 模板里的容器镜像，比如 <code>.spec.template.spec.containers[*].image</code>， 请使用 <code>kubectl set image</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image ds/nginx-ds nginx-ds=nginx:版本号 -n kube-system</span><br></pre></td></tr></table></figure>







<h2 id="StatefulSet控制器"><a href="#StatefulSet控制器" class="headerlink" title="StatefulSet控制器"></a>StatefulSet控制器</h2><p>​	StatefulSet从字面意思来理解，就是有状态的副本集合，那既然是有状态的那就肯定是有无状态的副本。</p>
<p>​	StatefulSet 运行一组 Pod，并为每个 Pod 保留一个稳定的标识。 这可用于管理需要持久化存储或稳定、唯一网络标识的应用。</p>
<p>​	StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p>
<p>​	StatefulSet 用来管理某 Pod集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p>
<p>和 <code>Deployment</code> 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p>
<p>​	如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p>
<h2 id="使用-StatefulSet"><a href="#使用-StatefulSet" class="headerlink" title="使用 StatefulSet"></a>使用 StatefulSet</h2><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值。</p>
<ul>
<li>稳定的、唯一的网络标识符。</li>
<li>稳定的、持久的存储。</li>
<li>有序的、优雅的部署和扩缩。</li>
<li>有序的、自动的滚动更新。</li>
</ul>
<p>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment可能更适用于你的无状态应用部署需要。</p>
<h3 id="什么是有状态和无状态？"><a href="#什么是有状态和无状态？" class="headerlink" title="什么是有状态和无状态？"></a>什么是有状态和无状态？</h3><p>​	在了解什么是有状态的和无状态之前，我们先来回顾一下deployments，我们前面了解过，deployments在当遇到某一组Pod异常下线后，控制器会为我们自动创建一个新的Pod来替换下线的Pod，替换过后原有未经过持久化存储的数据就会丢失，又或者无论请求发送到了哪个Pod，返回的结果都是一致的，每个Pod他都是平等的。这叫做<strong>无状态的应用</strong>。</p>
<p>​	而<strong>有状态的应用</strong>是需要具有持久化的存储，稳定的网络标识，Pod与Pod之前并不平等，即使它们用的是同一个镜像进行创建的。这类服务我们通常称之为“有状态”的服务。</p>
<p>​	他的视线不再依靠ReplicaSet，而是用StatefulSet，它具备以下特征：</p>
<ul>
<li>稳定的持久化存储，Pod重新调度后访问相同的持久化数据，可以使用PVC实现。</li>
<li>稳定的网络标识，Pod重新调度后PodName和HostName不变，基于Headless Service实现。</li>
<li>Pod都有一个”序号“，可以有序的进行扩展，部署等操作。</li>
</ul>
<h3 id="创建有状态的应用的三部曲"><a href="#创建有状态的应用的三部曲" class="headerlink" title="创建有状态的应用的三部曲"></a>创建有状态的应用的三部曲</h3><p><img src="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20251009153313117.png" alt="image-20251009153313117"></p>
<h3 id="创建statefulSet"><a href="#创建statefulSet" class="headerlink" title="创建statefulSet"></a>创建statefulSet</h3><p><strong>制作NFS共享目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建共享目录</span></span><br><span class="line">[root@k8s-master-01 data]# <span class="built_in">mkdir</span> -p /data/nfs&#123;1..3&#125;</span><br><span class="line"><span class="comment"># 如没有NFS服务，则需先安装NFS服务</span></span><br><span class="line">[root@k8s-master-01 dev]# yum -y  install nfs-kernel-server</span><br><span class="line"><span class="comment"># 开启自启及重启启动NFS服务</span></span><br><span class="line">[root@k8s-master-01 dev]# systemctl <span class="built_in">enable</span> nfs-server.service</span><br><span class="line">[root@k8s-master-01 dev]# systemctl restart nfs-server.service</span><br><span class="line"><span class="comment"># 最终查看验证得到我们NFS共享出来的三组共享目录</span></span><br><span class="line">[root@k8s-master-01 dev]# showmount -e </span><br><span class="line">Export list <span class="keyword">for</span> k8s-master-01:</span><br><span class="line">/data/nfs3 *</span><br><span class="line">/data/nfs2 *</span><br><span class="line">/data/nfs1 *</span><br></pre></td></tr></table></figure>



<p><strong>准备StorageClass（存储类）的yaml文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; my-StorageClass.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: storage.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: StorageClass</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: my-storage-class</span></span><br><span class="line"><span class="string">  annotations:</span></span><br><span class="line"><span class="string">    storageclass.kubernetes.io/is-default-class: &quot;false&quot;</span></span><br><span class="line"><span class="string">provisioner: csi-driver.example-vendor.example</span></span><br><span class="line"><span class="string">reclaimPolicy: Retain # default value is Delete</span></span><br><span class="line"><span class="string">allowVolumeExpansion: true</span></span><br><span class="line"><span class="string">mountOptions:</span></span><br><span class="line"><span class="string">  - discard # this might enable UNMAP / TRIM at the block storage layer</span></span><br><span class="line"><span class="string">volumeBindingMode: WaitForFirstConsumer</span></span><br><span class="line"><span class="string">parameters:</span></span><br><span class="line"><span class="string">  guaranteedReadWriteLatency: &quot;true&quot; # provider-specific</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<p><strong>准备statefulSet的yaml文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; statefulSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建PV</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: PersistentVolume</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: mypv1</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  storageClassName: my-storage-class</span></span><br><span class="line"><span class="string">  capacity:</span></span><br><span class="line"><span class="string">    storage: 1Gi</span></span><br><span class="line"><span class="string">  accessModes:</span></span><br><span class="line"><span class="string">    - ReadWriteOnce</span></span><br><span class="line"><span class="string">  persistentVolumeReclaimPolicy: Recycle</span></span><br><span class="line"><span class="string">  nfs:</span></span><br><span class="line"><span class="string">    path: /data/nfs1</span></span><br><span class="line"><span class="string">    server: 192.168.8.136</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建service</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - port: 80</span></span><br><span class="line"><span class="string">    name: web</span></span><br><span class="line"><span class="string">  clusterIP: None</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建StatefulSet</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: StatefulSet</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: web</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx # 必须匹配 .spec.template.metadata.labels</span></span><br><span class="line"><span class="string">  serviceName: &quot;nginx&quot;</span></span><br><span class="line"><span class="string">  replicas: 3 # 默认值是 1</span></span><br><span class="line"><span class="string">  minReadySeconds: 10 # 默认值是 0</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx # 必须匹配 .spec.selector.matchLabels</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      terminationGracePeriodSeconds: 10</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          name: web</span></span><br><span class="line"><span class="string">        volumeMounts:</span></span><br><span class="line"><span class="string">        - name: www</span></span><br><span class="line"><span class="string">          mountPath: /usr/share/nginx/html</span></span><br><span class="line"><span class="string">  # 在创建StatefulSet的同时，创建PVC</span></span><br><span class="line"><span class="string">  volumeClaimTemplates:</span></span><br><span class="line"><span class="string">  - metadata:</span></span><br><span class="line"><span class="string">      name: www</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span></span><br><span class="line"><span class="string">      storageClassName: &quot;my-storage-class&quot;</span></span><br><span class="line"><span class="string">      resources:</span></span><br><span class="line"><span class="string">        requests:</span></span><br><span class="line"><span class="string">          storage: 1Gi</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<p><strong>创建StatefulSet</strong></p>
<p>​	在准备好所有所需yaml文件后，可参考以下方式依次执行创建资源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建存储类</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f my-StorageClass.yaml</span><br><span class="line">storageclass.storage.k8s.io/my-storage-class created</span><br><span class="line"><span class="comment"># 创建PV、service和PVC及StatefulSet</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f statefulSet.yaml </span><br><span class="line">Warning: spec.persistentVolumeReclaimPolicy: The Recycle reclaim policy is deprecated. Instead, the recommended approach is to use dynamic provisioning.</span><br><span class="line">persistentvolume/mypv1 created</span><br><span class="line">service/nginx created</span><br></pre></td></tr></table></figure>



<p><strong>查看StatefulSet运行效果</strong></p>
<p>​	这里我们也发现它分别运行了2个副本，它们的Pod副本名称都有有序的，web是我们为资源取的名称，它会在我们自定义的名称后增加-0、-1….的序号，它们的启动顺序是固定的，只有等前面的启动完成，后面的才会启动，所以我们这里序号0成功，序号1目前的卡着不动了。	</p>
<p>​	这里可能就会有小伙伴有疑问了，我们要求该StatefulSet具有3个副本，但是第一个运行成功，但是第二个为什么一直在Pending等待，这就跟我们创建的PVC有关系了，我们创建PVC的时候是采用的【ReadWriteOnce】，意思就是一个读写模式，所以当我序号0的副本跟这个PVC绑定后，第二个再来请求绑定时，则就会出现失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 data]# kubectl get statefulsets.apps </span><br><span class="line">NAME   READY   AGE</span><br><span class="line">web    1/3     12m</span><br><span class="line">[root@k8s-master-01 data]# kubectl get pods --show-labels -l app=nginx</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">web-0   1/1     Running   0          13m   app=nginx,apps.kubernetes.io/pod-index=0,controller-revision-hash=web-69cd7d45cc,statefulset.kubernetes.io/pod-name=web-0</span><br><span class="line">web-1   0/1     Pending   0          13m   app=nginx,apps.kubernetes.io/pod-index=1,controller-revision-hash=web-69cd7d45cc,statefulset.kubernetes.io/pod-name=web-1</span><br></pre></td></tr></table></figure>

<p>​	到这里不要感觉懵，我们目前是还未介绍到存储和service服务发现，目前您只需要了解StatefulSet它的作用，及StatefulSet与deployment一个有状态的应用和无状态应用的区别即可。</p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>​	Job 表示一次性任务，运行完成后就会停止。</p>
<p>​	Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>
<p>​	一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p>
<p>​	你也可以使用 Job 以并行的方式运行多个 Pod。</p>
<p>​	如果你想按某种排期表（Schedule）运行 Job（单个任务或多个并行任务），可参考下面的CronJob。</p>
<p>​	该job任务负责计算 π 到小数点后 2000 位，并将结果打印出来。 此计算大约需要 10 秒钟完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; job.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: batch/v1</span></span><br><span class="line"><span class="string">kind: Job</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: pi</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: pi</span></span><br><span class="line"><span class="string">        image: perl:5.34.0</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]</span></span><br><span class="line"><span class="string">      restartPolicy: Never</span></span><br><span class="line"><span class="string">  backoffLimit: 4</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可使用如下指令创建资源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f job.yaml </span><br><span class="line">job.batch/pi created</span><br></pre></td></tr></table></figure>

<p>​	可使用以下指令查看运行结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl logs pi-4r9z8</span><br><span class="line">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822......</span><br></pre></td></tr></table></figure>





<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>​	CronJob 通过重复调度启动一次性的 Job。</p>
<p>​	<strong>CronJob</strong> 创建基于时隔重复调度的 Job。</p>
<p>CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 <strong>crontab</strong>（cron table）文件中的一行。 它用 Cron格式进行编写， 并周期性地在给定的调度时间执行 Job。</p>
<p>CronJob 有所限制，也比较特殊。 例如在某些情况下，单个 CronJob 可以创建多个并发任务。 请参阅下面的限制。</p>
<p>当控制平面为 CronJob 创建新的 Job 和（间接）Pod 时，CronJob 的 <code>.metadata.name</code> 是命名这些 Pod 的部分基础。 CronJob 的名称必须是一个合法的 DNS 子域值， 但这会对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 DNS 标签规则。 即使名称是一个 DNS 子域，它也不能超过 52 个字符。这是因为 CronJob 控制器将自动在你所提供的 Job 名称后附加 11 个字符，并且存在 Job 名称的最大长度不能超过 63 个字符的限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; cronJob.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: batch/v1</span></span><br><span class="line"><span class="string">kind: CronJob</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: hello</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  schedule: &quot;* * * * *&quot;</span></span><br><span class="line"><span class="string">  jobTemplate:</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      template:</span></span><br><span class="line"><span class="string">        spec:</span></span><br><span class="line"><span class="string">          containers:</span></span><br><span class="line"><span class="string">          - name: hello</span></span><br><span class="line"><span class="string">            image: busybox:1.28</span></span><br><span class="line"><span class="string">            imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">            command:</span></span><br><span class="line"><span class="string">            - /bin/sh</span></span><br><span class="line"><span class="string">            - -c</span></span><br><span class="line"><span class="string">            - date; echo Hello from the Kubernetes cluster</span></span><br><span class="line"><span class="string">          restartPolicy: OnFailure</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可使用如下指令创建资源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f cronJob.yaml </span><br><span class="line">cronjob.batch/hello created</span><br></pre></td></tr></table></figure>



<p>​	它会根据您设置的时间，定时执行固定的任务，每次执行都会产生一个随机Pod，这里我设置的是每秒执行一次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pods</span><br><span class="line">NAME                         READY   STATUS              RESTARTS         AGE</span><br><span class="line">centos                       0/1     ImagePullBackOff    0                49d</span><br><span class="line">centos-01                    0/1     ImagePullBackOff    0                79d</span><br><span class="line">hello-29333343-gfkcb         0/1     Completed           0                3m47s</span><br><span class="line">hello-29333344-zjbct         0/1     Completed           0                2m47s</span><br><span class="line">hello-29333345-qvcrv         0/1     Completed           0                107s</span><br><span class="line">hello-29333346-bsb4q         0/1     ContainerCreating   0                47s</span><br></pre></td></tr></table></figure>

<p>​	可通关logs指令查看运行日志结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl logs hello-29333344-zjbct </span><br><span class="line">Thu Oct  9 09:03:28 UTC 2025</span><br><span class="line">Hello from the Kubernetes cluster</span><br></pre></td></tr></table></figure>



<h3 id="Cron-时间表语法"><a href="#Cron-时间表语法" class="headerlink" title="Cron 时间表语法"></a>Cron 时间表语法</h3><p><code>.spec.schedule</code> 字段是必需的。该字段的值遵循 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cron">Cron</a> 语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ┌───────────── 分钟 (0 - 59)</span></span><br><span class="line"><span class="comment"># │ ┌───────────── 小时 (0 - 23)</span></span><br><span class="line"><span class="comment"># │ │ ┌───────────── 月的某天 (1 - 31)</span></span><br><span class="line"><span class="comment"># │ │ │ ┌───────────── 月份 (1 - 12)</span></span><br><span class="line"><span class="comment"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）</span></span><br><span class="line"><span class="comment"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># * * * * *</span></span><br></pre></td></tr></table></figure>

<p>例如 <code>0 3 * * 1</code> 表示此任务计划于每周一凌晨 3 点运行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">李维虎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">http://example.com/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归博主所有，如有转载，请注明来自原作者，联系方式（微信）：a1253582301</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a></div><div class="post-share"><div class="social-share" data-image="/img/doc_img/Kubernetes.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章"><img class="cover" src="/img/doc_img/Kubernetes.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CKA-kubernetes-第三章</div></div><div class="info-2"><div class="info-item-1">Kubectl语法​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。 ​	kubectl命令的常见格式是：kubectl action resource [parameter]。  kubectl：二进制执行文件。 action：操作选项。 resource：资源类型。 parameter（可选）：参数。  ​	这会对指定的资源（类似node或deployment）执行指定的操作（类似create、describe或delete）。您可以再子命令后面使用 --help获取可能参数相关的更多信息。kubectl get nodes...</div></div></div></a><a class="pagination-related" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章"><img class="cover" src="/img/doc_img/Kubernetes.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CKA-kubernetes-第五章</div></div><div class="info-2"><div class="info-item-1">服务发现服务（Service）​	将在集群中运行的应用通过同一个面向外界的端点公开出去，即使工作负载分散于多个后端也完全可行。 ​	Kubernetes 中 Service 是 将运行在一个或一组 Pod上的网络应用程序公开为网络服务的方法。 ​	Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用以使用某种不熟悉的服务发现机制。 你可以在 Pod 集合中运行代码，无论该代码是为云原生环境设计的，还是被容器化的老应用。 你可以使用 Service 让一组 Pod 可在网络上访问，这样客户端就能与之交互。 ​	如果你使用 Deployment来运行你的应用， Deployment 可以动态地创建和销毁 Pod。 在任何时刻，你都不知道有多少个这样的 Pod 正在工作以及它们健康与否； 你可能甚至不知道如何辨别健康的 Pod。 Kubernetes Pod 的创建和销毁是为了匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。 ​	每个 Pod 会获得属于自己的 IP 地址（Kubernetes 期待网络插件来保证这一点）。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">CKA-kubernetes-第一章</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-03</div><div class="info-item-2">CKA-kubernetes-第二章</div></div><div class="info-2"><div class="info-item-1">Kubernetes概述​	Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。 ​	Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。K8s 这个缩写是因为 K 和 s 之间有 8 个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上，...</div></div></div></a><a class="pagination-related" href="/2025/11/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%85%AD%E7%AB%A0/" title="CKA-kubernetes-第六章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-03</div><div class="info-item-2">CKA-kubernetes-第六章</div></div><div class="info-2"><div class="info-item-1">存活、就绪和启动探针</div></div></div></a><a class="pagination-related" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="info-item-2">CKA-kubernetes-第五章</div></div><div class="info-2"><div class="info-item-1">服务发现服务（Service）​	将在集群中运行的应用通过同一个面向外界的端点公开出去，即使工作负载分散于多个后端也完全可行。 ​	Kubernetes 中 Service 是 将运行在一个或一组 Pod上的网络应用程序公开为网络服务的方法。 ​	Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用以使用某种不熟悉的服务发现机制。 你可以在 Pod 集合中运行代码，无论该代码是为云原生环境设计的，还是被容器化的老应用。 你可以使用 Service 让一组 Pod 可在网络上访问，这样客户端就能与之交互。 ​	如果你使用 Deployment来运行你的应用， Deployment 可以动态地创建和销毁 Pod。 在任何时刻，你都不知道有多少个这样的 Pod 正在工作以及它们健康与否； 你可能甚至不知道如何辨别健康的 Pod。 Kubernetes Pod 的创建和销毁是为了匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。 ​	每个 Pod 会获得属于自己的 IP 地址（Kubernetes 期待网络插件来保证这一点）。...</div></div></div></a><a class="pagination-related" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章"><img class="cover" src="/img/doc_img/Kubernetes.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-14</div><div class="info-item-2">CKA-kubernetes-第三章</div></div><div class="info-2"><div class="info-item-1">Kubectl语法​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。 ​	kubectl命令的常见格式是：kubectl action resource [parameter]。  kubectl：二进制执行文件。 action：操作选项。 resource：资源类型。 parameter（可选）：参数。  ​	这会对指定的资源（类似node或deployment）执行指定的操作（类似create、describe或delete）。您可以再子命令后面使用 --help获取可能参数相关的更多信息。kubectl get nodes...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李维虎</div><div class="author-info-description">一个热爱技术分享的有志青年</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的<em>博客网站</em>，如对文章内容有疑惑可扫描二维码添加博主微信。</p> <p>文章来之不易，如认为文章不错请在文章底部为博主打赏,你的支持是我持续更新的动力</p> <CENTER><img src="img\index_img/wxewm.png" alt="描述文字" style="width:250px; height:250px;"></CENTER></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFK8s%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">理解什么是K8s控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReplicaSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">ReplicaSet控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8ReplicaSet"><span class="toc-number">1.2.1.</span> <span class="toc-text">何时使用ReplicaSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deployments%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">Deployments控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment%E4%B8%8EReplicaSet%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">Deployment与ReplicaSet区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">Deployment滚动更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.3.4.</span> <span class="toc-text">Deployment版本回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CHANGE-CAUSE%E5%8F%98%E6%9B%B4%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">CHANGE-CAUSE变更描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E7%BC%A9%E5%AE%B9Deployment"><span class="toc-number">1.3.6.</span> <span class="toc-text">扩缩容Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E4%BE%8B%E7%BC%A9%E6%94%BE"><span class="toc-number">1.3.7.</span> <span class="toc-text">比例缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B0%B4%E5%B9%B3%E4%BC%B8%E7%BC%A9%E6%89%A9%E5%AE%B9"><span class="toc-number">1.3.8.</span> <span class="toc-text">删除水平伸缩扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8DDeployment-%E7%9A%84%E4%B8%8A%E7%BA%BF%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.9.</span> <span class="toc-text">暂停与恢复Deployment 的上线过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.10.</span> <span class="toc-text">清除策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DaemonSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">DaemonSet控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99DaemonSet%E8%A7%84%E7%BA%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">编写DaemonSet规约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DaemonSet%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.2.</span> <span class="toc-text">DaemonSet的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DaemonSet%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">DaemonSet滚动更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">声明式命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%BC%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">指令式命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E6%9B%B4%E6%96%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">只更新容器镜像</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatefulSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">StatefulSet控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-StatefulSet"><span class="toc-number">1.6.</span> <span class="toc-text">使用 StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是有状态和无状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-number">1.6.2.</span> <span class="toc-text">创建有状态的应用的三部曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAstatefulSet"><span class="toc-number">1.6.3.</span> <span class="toc-text">创建statefulSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Job"><span class="toc-number">1.7.</span> <span class="toc-text">Job</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CronJob"><span class="toc-number">1.8.</span> <span class="toc-text">CronJob</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cron-%E6%97%B6%E9%97%B4%E8%A1%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">Cron 时间表语法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/" title="Centos7.9搭建SoftEtherVPN"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Centos7.9搭建SoftEtherVPN"/></a><div class="content"><a class="title" href="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/" title="Centos7.9搭建SoftEtherVPN">Centos7.9搭建SoftEtherVPN</a><time datetime="2025-11-06T01:46:16.685Z" title="发表于 2025-11-06 09:46:16">2025-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%85%AD%E7%AB%A0/" title="CKA-kubernetes-第六章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第六章"/></a><div class="content"><a class="title" href="/2025/11/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%85%AD%E7%AB%A0/" title="CKA-kubernetes-第六章">CKA-kubernetes-第六章</a><time datetime="2025-11-03T07:14:52.000Z" title="发表于 2025-11-03 15:14:52">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第五章"/></a><div class="content"><a class="title" href="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="CKA-kubernetes-第五章">CKA-kubernetes-第五章</a><time datetime="2025-10-10T01:45:13.000Z" title="发表于 2025-10-10 09:45:13">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第四章"/></a><div class="content"><a class="title" href="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="CKA-kubernetes-第四章">CKA-kubernetes-第四章</a><time datetime="2025-08-06T08:04:01.000Z" title="发表于 2025-08-06 16:04:01">2025-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第三章"/></a><div class="content"><a class="title" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章">CKA-kubernetes-第三章</a><time datetime="2025-07-14T03:36:45.000Z" title="发表于 2025-07-14 11:36:45">2025-07-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/doc_img/Kubernetes.webp);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 李维虎</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">主题框架声明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="晚,上,好" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>