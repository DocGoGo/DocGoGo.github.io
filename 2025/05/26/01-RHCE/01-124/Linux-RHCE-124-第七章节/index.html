<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux-RHCE-124-第七章节 | 欢迎来到李维虎的在线博客</title><meta name="author" content="李维虎"><meta name="copyright" content="李维虎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="监控和管理Linux进程进程状态和生命周期进程的定义​	进程是已启动的可执行程序中运行的实例。从进程创建那一刻起，它由以下项目组成：  已分配内存的地址空间 安全属性，包括所有权凭据和特权 程序代码的一个或多个执行线程 进程状态  进程的环境是包含以下项目的信息列表：  本地和全局变量 当前调度上下文 分配的系统资源，如文件描述的网络端口  ​	现有的父进程复制自己的地址空间（成为进程分叉）来创建">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-RHCE-124-第七章节">
<meta property="og:url" content="http://example.com/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="欢迎来到李维虎的在线博客">
<meta property="og:description" content="监控和管理Linux进程进程状态和生命周期进程的定义​	进程是已启动的可执行程序中运行的实例。从进程创建那一刻起，它由以下项目组成：  已分配内存的地址空间 安全属性，包括所有权凭据和特权 程序代码的一个或多个执行线程 进程状态  进程的环境是包含以下项目的信息列表：  本地和全局变量 当前调度上下文 分配的系统资源，如文件描述的网络端口  ​	现有的父进程复制自己的地址空间（成为进程分叉）来创建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/doc_img/RHCE_cover.jpeg">
<meta property="article:published_time" content="2025-05-26T08:59:32.000Z">
<meta property="article:modified_time" content="2025-06-04T08:23:21.410Z">
<meta property="article:author" content="李维虎">
<meta property="article:tag" content="RHCE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/doc_img/RHCE_cover.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux-RHCE-124-第七章节",
  "url": "http://example.com/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/",
  "image": "http://example.com/img/doc_img/RHCE_cover.jpeg",
  "datePublished": "2025-05-26T08:59:32.000Z",
  "dateModified": "2025-06-04T08:23:21.410Z",
  "author": [
    {
      "@type": "Person",
      "name": "李维虎",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/index_img/logo.png"><link rel="canonical" href="http://example.com/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux-RHCE-124-第七章节',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/doc_img/RHCE_cover.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/index_img/butterfly-icon.png" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">Linux-RHCE-124-第七章节</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux-RHCE-124-第七章节<a class="post-edit-link" href="null_posts/01-RHCE/01-124/Linux-RHCE-124-第七章节.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-26T08:59:32.000Z" title="发表于 2025-05-26 16:59:32">2025-05-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T08:23:21.410Z" title="更新于 2025-06-04 16:23:21">2025-06-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RHCE/">RHCE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="监控和管理Linux进程"><a href="#监控和管理Linux进程" class="headerlink" title="监控和管理Linux进程"></a>监控和管理Linux进程</h1><h2 id="进程状态和生命周期"><a href="#进程状态和生命周期" class="headerlink" title="进程状态和生命周期"></a>进程状态和生命周期</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>​	进程是已启动的可执行程序中运行的实例。从进程创建那一刻起，它由以下项目组成：</p>
<ul>
<li>已分配内存的地址空间</li>
<li>安全属性，包括所有权凭据和特权</li>
<li>程序代码的一个或多个执行线程</li>
<li>进程状态</li>
</ul>
<p>进程的环境是包含以下项目的信息列表：</p>
<ul>
<li>本地和全局变量</li>
<li>当前调度上下文</li>
<li>分配的系统资源，如文件描述的网络端口</li>
</ul>
<p>​	现有的父进程复制自己的地址空间（成为进程分叉）来创建子进程结构。每个新进程分配有一个唯一进程ID（PID），满足跟踪和安全性之需。PID和父进程ID（PPID）是新进程环境的元素。任何进程都可以创建子进行。所有进程都是第一个系统进程的后代，在RedHat Linux中，第一个系统进程是systemd。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527112636921.png" alt="image-20250527112636921"></p>
<p>​	通过分叉进程，子进程继承安全性身份、过去和当前的文件描述符、端口和资源特权、环境变量，以及程序代码。随后，子进程可以执行其自己的代码程序。</p>
<p>​	通常，父进程在子进程运行期间处于睡眠状态，设置一个在子进程完成时发出信号的等待请求。子进程退出后，他会关闭或丢弃其资源和环境，并留下僵停资源，即进程表中的一个条目。父进程在子进程退出时收到信号而被唤醒，清理子进程条目的进程表，由此释放子进程的最后一个资源，然后，父进程继续执行自己的程序代码。</p>
<h3 id="描述进程状态"><a href="#描述进程状态" class="headerlink" title="描述进程状态"></a>描述进程状态</h3><p>​	在多任务处理操作系统中，每个CPU（或CPU核心）在一个时间上处理一个进程。在进程运行时，它对CPU时间和资源分配的直接要求会有变化。进程分配有一个状态，它随着环境要求而改变。</p>
<p>​	以下图示和表格详细描述了Linux进程状态。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527115327090.png" alt="image-20250527115327090"></p>
<p><strong>Linux进程状态</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>标志</th>
<th>内核定义的状态名称和描述</th>
</tr>
</thead>
<tbody><tr>
<td>运行中</td>
<td>R</td>
<td>TASK_RUNNING：进程正在CPU上执行，或者正在等待运行。处于运行中（或可运行）状态时，进程可能正在执行用户例程或内核例程（系统调用），或者已经排队并就绪。</td>
</tr>
<tr>
<td>睡眠</td>
<td>S</td>
<td>TASK_INTERRUPTIBLEl：进程正在等待某一条件：硬件请求、系统资源访问或信号。当事件或信号满足该条件时，该进程将返回运行中。</td>
</tr>
<tr>
<td>睡眠</td>
<td>D</td>
<td>TASK_UNINERRUPTIBLE：此进程也正在睡眠，但与S状态不同，不会响应信号。仅在进程终端可能会导致以外设备状态下使用。</td>
</tr>
<tr>
<td>睡眠</td>
<td>K</td>
<td>TASK_KILLABLE：与不可中断的D状态相同，但有所修改，允许等待中的任务响应要被中止（彻底退出）的信号。实用程序通常将可中止的进程显示为D状态。</td>
</tr>
<tr>
<td>睡眠</td>
<td>I</td>
<td>TASK_REPORT_IDLE：D状态的一个子集。在计算负载平均值时，内核不会统计这些进程。用于内核线程。设置了TASK_UNINTEERRUPTIBLE和TASK_NOLOAD标志。类似于TASK_KILLABLE，也是D状态的一个子集。它接受致命信号。</td>
</tr>
<tr>
<td>已停止</td>
<td>T</td>
<td>TASK_STOPPED：进程已被停止（暂停），通常是通过用户或其他进程发出的信号。进程可以通过另一信号返回到运行中状态，继续执行（恢复）。</td>
</tr>
<tr>
<td>已停止</td>
<td>T</td>
<td>TASK_TRACED：正在被调试的进程也会临时停止，并且共享同一个T状态标识。</td>
</tr>
<tr>
<td>僵停</td>
<td>Z</td>
<td>EXIT_TRACED：子进程在退出时向父进程发送信号。除进程身份（PID）之外的所有资源都已释放。</td>
</tr>
<tr>
<td>僵停</td>
<td>X</td>
<td>EXIT_DEAD：当父进程清理（获取）剩余的子进程结构时，进程现在已经彻底释放。次状态无法在进程列出实用程序中看到。</td>
</tr>
</tbody></table>
<h3 id="进程状态的重要性"><a href="#进程状态的重要性" class="headerlink" title="进程状态的重要性"></a>进程状态的重要性</h3><p>​	在对系统进行故障排除时，了解内核如何于进程通信以及进程如何相互通信非常重要。系统为每个新进程分配一个状态。top命令的S列或ps的STAT列显示每个进程的状态。在单CPU系统上，一次只能运行一个进程。您可以看到多个状态为R的进程。但是，并非所有进程都在连续运行。其中一些处于等待状态。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527134505011.png" alt="image-20250527134505011"></p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527134807084.png" alt="image-20250527134807084"></p>
<p>​	使用信号来暂停、停止、恢复、终止或中断进程。进程可以捕获来自同一系统上内核、其他进程和其他用户的信号。</p>
<h3 id="列出进程"><a href="#列出进程" class="headerlink" title="列出进程"></a>列出进程</h3><p>​	ps命令用于列出当前进程的详细信息。</p>
<ul>
<li>用户标识符（UID），它确定进程的特权。</li>
<li>唯一进程标识符（PID）。</li>
<li>已用CPU量和实际时间。</li>
<li>分配的内存量。</li>
<li>进程stdout位置，称为控制终端。</li>
<li>当前的进程状态。</li>
</ul>
<p>​	<code>重要：Linux版的ps命令支持以下选项格式：</code></p>
<ul>
<li><p><code>UNIX(POSIX)选项，可以分组单必须以连字符开头。</code></p>
</li>
<li><p><code>BSD选项，可以分组但不可以与短划线同用。</code></p>
</li>
<li><p><code>GNU长选项，以爽连字符开头。</code></p>
<p><code>例如：ps -aux 命令与ps aux命令不同。</code></p>
</li>
</ul>
<p>​	常见的ps命令aux选项显示包括无控制终端的进程在内的所有进程。长列表（lax选项）提供更多详细信息，并且通过避免查询用户名可用加快显示。相似的UNIX语法使用-ef选项来显示所有进程。在以下示例中，调度的内核线程显示在列表顶部，并用方括号括起。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps aux | <span class="built_in">tail</span> -n 10</span><br><span class="line">root        2313  0.0  0.0      0     0 ?        I    13:44   0:00 [kworker/1:0-events_long]</span><br><span class="line">root        2314  0.0  0.0      0     0 ?        I    13:44   0:00 [kworker/0:0-mm_percpu_wq]</span><br><span class="line">root        2336  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/5:0-events_freezable]</span><br><span class="line">root        2337  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">root        2363  0.0  0.0      0     0 ?        I    13:49   0:00 [kworker/3:1-events]</span><br><span class="line">root        2364  0.0  0.0      0     0 ?        I    13:50   0:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">root        2366  0.0  0.0      0     0 ?        I    13:52   0:00 [kworker/u256:0-events_unbound]</span><br><span class="line">root        2367  0.0  0.0      0     0 ?        I    13:55   0:00 [kworker/3:2-mm_percpu_wq]</span><br><span class="line">kiosk       2376  0.0  0.0 225500  3720 pts/0    R+   13:57   0:00 ps aux</span><br><span class="line">kiosk       2377  0.0  0.0 220988  1040 pts/0    S+   13:57   0:00 <span class="built_in">tail</span> -n 10</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ ps lax | <span class="built_in">tail</span> -n 10</span><br><span class="line">1     0    2314       2  20   0      0     0 -      I    ?          0:00 [kworker/0:0-events]</span><br><span class="line">1     0    2336       2  20   0      0     0 -      I    ?          0:00 [kworker/5:0-events_freezable]</span><br><span class="line">1     0    2337       2  20   0      0     0 -      I    ?          0:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">1     0    2363       2  20   0      0     0 -      I    ?          0:00 [kworker/3:1-events]</span><br><span class="line">1     0    2364       2  20   0      0     0 -      I    ?          0:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">1     0    2366       2  20   0      0     0 -      I    ?          0:00 [kworker/u256:0-nfsd4]</span><br><span class="line">1     0    2367       2  20   0      0     0 -      I    ?          0:00 [kworker/3:2-events_freezable_power_]</span><br><span class="line">1     0    2378       2  20   0      0     0 -      I    ?          0:00 [kworker/u256:1-events_unbound]</span><br><span class="line">0  1000    2379    2304  20   0 225500  1568 -      R+   pts/0      0:00 ps lax</span><br><span class="line">0  1000    2380    2304  20   0 220988   980 pipe_r S+   pts/0      0:00 <span class="built_in">tail</span> -n 10</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ ps -ef | <span class="built_in">tail</span> -n 10</span><br><span class="line">root        2314       2  0 13:44 ?        00:00:00 [kworker/0:0-events]</span><br><span class="line">root        2336       2  0 13:45 ?        00:00:00 [kworker/5:0-events_freezable]</span><br><span class="line">root        2337       2  0 13:45 ?        00:00:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">root        2363       2  0 13:49 ?        00:00:00 [kworker/3:1-events]</span><br><span class="line">root        2364       2  0 13:50 ?        00:00:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">root        2366       2  0 13:52 ?        00:00:00 [kworker/u256:0-nfsd4]</span><br><span class="line">root        2367       2  0 13:55 ?        00:00:00 [kworker/3:2-events_freezable_power_]</span><br><span class="line">root        2378       2  0 13:57 ?        00:00:00 [kworker/u256:1-events_unbound]</span><br><span class="line">kiosk       2381    2304  0 13:57 pts/0    00:00:00 ps -ef</span><br><span class="line">kiosk       2382    2304  0 13:57 pts/0    00:00:00 <span class="built_in">tail</span> -n 10</span><br></pre></td></tr></table></figure>

<p>​	默认情况下，不带选项运行ps命令会选择具有与当前用户相同的有效用户ID（EUID）并与运行命令所处同一终端关联的所有进程。僵停进程使用exiting 或defunct标签列出。</p>
<p>​	您可以使用ps 命令 –forest 选项以树形格式显示进程，从而查看父进程和子进程之间的关系。</p>
<p>​	ps 命令的默认输出按进程ID编号排序。输出中似乎使用了时间顺序，但内核重复使用了进程ID，因此其顺序不如看起来那样有序。使用ps 命令-o 或 –sort 选项对输出进行排序。显示顺序与系统进程表的顺序匹配，在进程终止和进程运行时重新使用列表行。</p>
<h2 id="控制作业"><a href="#控制作业" class="headerlink" title="控制作业"></a>控制作业</h2><h3 id="描述作业和会话"><a href="#描述作业和会话" class="headerlink" title="描述作业和会话"></a>描述作业和会话</h3><p>​	借助作业控制shell功能，单个shell实例可以运行和管理多个命令。</p>
<p>​	作业与在shell提示符中输入的每个管道相关联。该管道中的所有进程均是作业的一部分，并且是同一个进程组的成员。最小管道可以被视为在shell提示符处输入的唯一一个命令，创建仅含有一个成员的一个作业。</p>
<p>​	一次只能有一个作业从特定终端窗口中读取输入和键盘生成的信号。属于改作业的进程是该终端的前台进程。</p>
<p>​	该控制终端的后台进程是与该终端相关联的任何其他作业。终端的后台进程无法从终端读取输入或接收键盘生成的中断，但可以写入到终端。后台作业可能已停止（暂停），也可能正在运行。如果某个正在运行的后台作业尝试从终端读取内容，则该作业将自动暂停。</p>
<p>​	每个终端在其自身的会话中运行，并且可以具有一个前台进程和任意数量的后台进程。一个作业仅在属于其控制终端的一个会话中。</p>
<p>​	ps命令在TTY列中显示控制终端的设备名称。某些进程（如系统守护进行）由系统启动，并不是从控制终端启动的。这些进程不是作业的成员，并且无法转至前台。ps命令在TTY列中针对这些进程显示一个问号（？）。</p>
<h3 id="在后台运行作业"><a href="#在后台运行作业" class="headerlink" title="在后台运行作业"></a>在后台运行作业</h3><p>​	任何命令或管道都可以在后台启动，只需在命令上附加一个&amp;符号即可。Bash Shell显示作业编号（特定于会话的唯一编号）在新建子进程的PID。shell不等待子进程终止，而会显示shell提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[1] 2490</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	如果将包含竖线（|）的命令发送到后台，将显示管道中最后一个命令的PID。所有管道进程仍是该作业的成员。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> example_command | <span class="built_in">sort</span> | mail -s <span class="string">&quot;Sort Output&quot;</span> &amp;</span><br><span class="line">[3] 2553</span><br></pre></td></tr></table></figure>

<p>​	使用jobs命令显示当前shell会话的作业列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span> </span><br><span class="line">[1]   Running                 <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[2]   Stopped                 example_command | <span class="built_in">sort</span> | mail -s <span class="string">&quot;Sort Output&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	使用fg命令将后台作业置于前台。使用（%jobNumber）格式将进程指定到前台。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="built_in">sleep</span> 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在上述例子中，sleep命令现在正在控制终端的前台运行。shell本身将睡眠，并等待这一子进程退出。</p>
<p>​	若要将前台进程发送到后台，请首先在终端中按键盘生成暂停请求（Ctrl+z）。该作业将被置于后台并暂停。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="built_in">sleep</span> 10000</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 <span class="built_in">sleep</span> 10000</span><br></pre></td></tr></table></figure>

<p>​	ps命令 j选项显示与作业相关的信息。使用ps命令j选项来查找进行和会话信息。</p>
<ul>
<li>PID是唯一的进程ID。</li>
<li>PPID是此进程的父进程（即启动（分叉）此进程的进程）的PID。</li>
<li>PGID是进程组首进程的PID，通常是作业管道中的第一个进程。</li>
<li>SID是会话首进程的PID，对于作业而言，这通常是正在其控制终端上运行的交互shell。</li>
</ul>
<p>以下示例中，sleep命令当前已停止，其状态为T。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps j</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   2297    2304    2304    2304 pts/0       2595 Ss    1000   0:00 -bash</span><br><span class="line">   2304    2490    2490    2304 pts/0       2595 T     1000   0:00 <span class="built_in">sleep</span> 10000</span><br><span class="line">   2304    2533    2531    2304 pts/0       2595 T     1000   0:00 -bash</span><br><span class="line">   2304    2597    2597    2304 pts/0       2597 R+    1000   0:00 ps j</span><br></pre></td></tr></table></figure>

<p>使用bg命令和作业ID来启动暂停的进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">bg</span> %1</span><br><span class="line">[1]+ <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[kiosk@foundation0 ~]$ ps j</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   2297    2304    2304    2304 pts/0       2597 Ss    1000   0:00 -bash</span><br><span class="line">   2304    2490    2490    2304 pts/0       2597 S     1000   0:00 <span class="built_in">sleep</span> 10000</span><br><span class="line">   2304    2533    2531    2304 pts/0       2597 T     1000   0:00 -bash</span><br><span class="line">   2304    2597    2597    2304 pts/0       2597 R+    1000   0:00 ps j</span><br></pre></td></tr></table></figure>

<p>​	如果用户尝试退出带有暂停作业的终端窗口（会话），那么shell会发出警告。如果用户再次尝试立即退出，暂停的作业将会被终止。</p>
<p>​	<code>注意：在前面示例中，【[1]+ sleep 10000 &amp;】+符号表示此作业是当前的默认作业。如果不带%jobNumber参数使用作业控制命令，则对默认作业执行操作。-符号表示在当前默认作业完成时即将成为下一个默认作业。</code></p>
<h2 id="中止进程"><a href="#中止进程" class="headerlink" title="中止进程"></a>中止进程</h2><h3 id="使用信号控制进程"><a href="#使用信号控制进程" class="headerlink" title="使用信号控制进程"></a>使用信号控制进程</h3><p>​	信号是传递至进程的软件中断。信号向执行中的程序报告事件。生成信号的时间可以是错误或外部事件（I&#x2F;O请求或定时器过期），或者来自于显示使用信号发送命令或键盘序列。</p>
<p>​	下表列出了系统管理员常用进程管理的基本信号。请通过短名称（HUP）或全称（SIGHUP）来指代信号。</p>
<p><strong>基本进程信号</strong></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>Hangup：报告终端控制进程的终止。也请求进程重新初始化（重新加载配置）而不终止。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>Keyboard interrupt：导致程序终止。可以被拦截或处理。通过按INTR（中断）键序列（Ctrl+c）发送</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>Keyboard quit：与SIGINT相似；在终止时添加进程转储。通过按QUIT键序列（Ctrl+\）发送。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>Kill, unblockable:导致立即终止程序。无法被拦截、忽略或处理；总是致命的。</td>
</tr>
<tr>
<td>15（默认）</td>
<td>TERM</td>
<td>Terminate：导致程序终止。与SIGKILL不同，可以被拦截、忽略或处理。要求程序以”干净“的方式终止；它允许程序完成基本操作和自我清理后再终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>Continue：发送至进程使其恢复（若已停止）。无法拦截。即使被处理，也始终恢复进程。</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>Stop， unblockable：暂停进程。无法被拦截或处理</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>Keyboard stop：和SIGSTOP不通，可以被拦截、忽略或处理。通过按暂停键序列（Ctrl+z）发送。</td>
</tr>
</tbody></table>
<p>​	<code>注意：信号编号视不通Linux硬件平台而异，但信号名称和含义都是标准的。建议再发送信号时使用信号名称，而不是数字。本章节适用于X86_64架构系统。</code></p>
<p>​	每个信号都有一个默认操作，通常是如下操作之一：</p>
<ul>
<li><p>Term：立即终止程序（退出）。</p>
</li>
<li><p>Core：保存程序的内存镜像（核心转储），然后终止。</p>
</li>
<li><p>Stop：停止运行中的程序（暂停），再等待继续（恢复）。</p>
<p>程序通过实施处理程序例程来响应预期的事件信号，以忽略、替换或扩展信号的默认操作。</p>
</li>
</ul>
<h3 id="通过显示请求发送信号"><a href="#通过显示请求发送信号" class="headerlink" title="通过显示请求发送信号"></a>通过显示请求发送信号</h3><p>​	您可以想当前的前台进程发送信号，具体操作为案件键盘控制序列以暂停（Ctrl+z）、中止（Ctrl+c）或核心转储（Ctrl+\）该进程。不过，您可以使用信用发送命令向另一会话中的后台进程发送信号。</p>
<p>​	您可以通过名称（例如 -HUP 或 -SIGHUP）或编号（相关的 -1 选项）来指定信号。用户可以中止自己的进程，但需要root权限才能终止其他人拥有的进程。</p>
<p>​	kill命令使用PID编号向进程发送信号。芮苒其名为kill，但您可以使用这个命令来发送任何信号，而不仅仅是终止程序的信号。您可以使用kill命令 -l选项列出所有可用信号的名称和编号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX	</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2912  0.0  0.0 220956  1048 pts/0    S    17:09   0:00 <span class="built_in">sleep</span> 1000</span><br><span class="line">root        2913  0.0  0.0 220956   996 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2920  0.0  0.0 221668  2368 pts/0    S+   17:10   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> 2912</span><br><span class="line">[1]   Terminated              <span class="built_in">sleep</span> 1000</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2913  0.0  0.0 220956   996 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2922  0.0  0.0 221668  2368 pts/0    S+   17:10   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> -9 2913</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2924  0.0  0.0 221668  2356 pts/0    S+   17:11   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[2]-  Killed                  <span class="built_in">sleep</span> 2000</span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> -SIGTERM 2914</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2942  0.0  0.0 221668  2260 pts/0    S+   17:11   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[3]+  Terminated              <span class="built_in">sleep</span> 3000</span><br></pre></td></tr></table></figure>



<h3 id="控制特定进程"><a href="#控制特定进程" class="headerlink" title="控制特定进程"></a>控制特定进程</h3><p>​	使用pkill命令向一个或多个符合选择条件的进程发送信号。选择条件可用是命令名称、特定用户拥有的进程，或所有系统范围进程。</p>
<p>​	可用逐一向进程和会话发送信号，也可以集体发送。要终止一个用户的所有进程，可使用pkill命令。</p>
<p>​	由于登录会话中的初始进程（会话首进程）设计为可以处理会话终止请求并忽略不想要的键盘信号，中断某一用户的所有进程和登录shell需要使用SIGKILL信号。</p>
<p>​	首先，使用pgrep命令来确定要中止的PID编号。此命令的操作与pkill命令类似，大部分选项相同，但是pgrep命令列出进程而不是中止它们。</p>
<p>​	使用pgrep命令和-l选项列出进程名称和ID。使用任一命令和-u选项来指定拥有进程的用户的ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 home]# pgrep -l -u user03</span><br><span class="line">3174 systemd</span><br><span class="line">3179 (sd-pam)</span><br><span class="line">3200 sshd</span><br><span class="line">3207 bash</span><br><span class="line">[root@foundation0 home]# pkill -SIGKILL -u user03</span><br><span class="line">[root@foundation0 home]# pgrep -l -u user03</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	当需要注意的进程在同一登录会话中时，可能不需要中止用户所有的进程。使用w命令来确定会话的控制终端，然后仅中止引用同一中断ID的进程。</p>
<p>​	除非指定了SIGKILL，否则会话首进程（此处为Bash登录shell）可以成功处理中止请求并继续运行，但所有其他会话进程将被终止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br><span class="line">3283 systemd</span><br><span class="line">3287 (sd-pam)</span><br><span class="line">3304 sshd</span><br><span class="line">3313 bash</span><br><span class="line">[root@foundation0 ~]# w -u user03</span><br><span class="line"> 18:22:33 up  7:15,  2 <span class="built_in">users</span>,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">user03   pts/1     18:16    5:49   0.03s  0.03s -bash</span><br><span class="line">[root@foundation0 ~]# pkill -t pts/1</span><br><span class="line"><span class="comment"># 此刻发现user03的bash会话首进程依然存在，有效忽略掉了中止信号</span></span><br><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br><span class="line">3283 systemd</span><br><span class="line">3287 (sd-pam)</span><br><span class="line">3304 sshd</span><br><span class="line">3313 bash</span><br><span class="line">[root@foundation0 ~]# pkill -SIGKILL -t pts/1</span><br><span class="line"><span class="comment"># 使用SIGKILL信号，则会无视忽略，强制中止</span></span><br><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：管理员通常使用SIGKILL。</code></p>
<p>​	<code>由于SIGKILL信号无法被处理或忽视，它总是致命的。然而，它会强制终止进程，而不允许被中断的进程运行自我清理例程。RedHat Linux建议先发送SIGTERM，然后尝试SIGINT；只有这两个都失败时，在尝试SIGKILL。</code></p>
<p>​	您可以借助父进程和子进程关系应用相同的选择性进程终止。使用pstree命令查看系统或单个用户的进程树。使用父进程的PID中止其创建的所有子进程。父进程Bash登录Shell不通被终止，因为信号仅定向至它的子进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)─┬─<span class="built_in">sleep</span>(2296)</span><br><span class="line">                        ├─<span class="built_in">sleep</span>(2297)</span><br><span class="line">                        └─<span class="built_in">sleep</span>(2298)</span><br><span class="line">[root@foundation0 ~]# pkill -P 2262</span><br><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)</span><br><span class="line">[root@foundation0 ~]# pkill -SIGKILL -P 2262</span><br><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>



<h3 id="向多个进程发送信号"><a href="#向多个进程发送信号" class="headerlink" title="向多个进程发送信号"></a>向多个进程发送信号</h3><p>​	killall命令可以根据命令名称向多个进程发送信号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# ps aux | grep <span class="built_in">sleep</span></span><br><span class="line">kiosk       2346  0.0  0.0 220956   988 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 1000</span><br><span class="line">kiosk       2347  0.0  0.0 220956   988 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">kiosk       2348  0.0  0.0 220956  1040 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2350  0.0  0.0 221668  2212 pts/0    S+   17:12   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 ~]# killall <span class="built_in">sleep</span> </span><br><span class="line">[root@foundation0 ~]# ps aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2360  0.0  0.0 221668  2268 pts/0    S+   17:13   0:00 grep --color=auto <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure>

<p>​	使用kill命令终止特定的作业。在作业编号上添加前缀百分号（%）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 <span class="built_in">sleep</span> 3000 &amp;</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">kill</span> -SIGTERM %1</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Terminated              <span class="built_in">sleep</span> 3000</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>



<h3 id="以管理员身份注销用户"><a href="#以管理员身份注销用户" class="headerlink" title="以管理员身份注销用户"></a>以管理员身份注销用户</h3><p>​	出于各种原因，您可能需要注销其他用户。一些可能的情景：用户做出了安全违规行为；用户可能过度使用了资源；用户的系统不响应；或者，用户不当访问了资料。在这些情形中，您必须以管理员身份使用信号来终止其会话。</p>
<p>​	要注销某个用户，首先确定要终止的登录会话。使用w命令列出用户登录和当前运行的进程。记录TTY和FROM列，以确定要关闭的会话。</p>
<p>​	所有用户登录会话都与某个中断设备(TTY)相关联。如果设备名称为pts&#x2F;N，说明这时一个与图形终端窗口或远程登录会话相关联的伪终端。如果为ttyN，则说明用户位于一个系统控制台、替代控制台或其他直接连接的终端设备上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# w</span><br><span class="line"> 17:49:39 up  1:06,  3 <span class="built_in">users</span>,  load average: 1.29, 0.29, 0.10</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kiosk    pts/0     16:44    1.00s  0.22s  0.06s sshd: kiosk [priv]  </span><br><span class="line">kiosk    pts/1     16:50   34.00s  0.05s  0.05s -bash</span><br><span class="line">user01   tty2      17:49    1:05m  0.08s  0.07s /usr/libexec/gnome-session-binary</span><br></pre></td></tr></table></figure>

<p>​	查看会话登录时间，了解用户已登录该系统的时长。对于每个会话，当前作业占用的CPU资源（包括后台任务和子进程）位于JCPU列中。当前的前台进程CPU占用情况列在PCPU中。</p>
<h2 id="监控进程活动"><a href="#监控进程活动" class="headerlink" title="监控进程活动"></a>监控进程活动</h2><h3 id="描述负载平均值"><a href="#描述负载平均值" class="headerlink" title="描述负载平均值"></a>描述负载平均值</h3><p>​	负载平均值是Linux内核提供的一种度量，可以表示一段时间内感知的系统负载。它可用来粗略衡量待处理的系统资源请求数量，并确定系统负载的增减。</p>
<p>​	根据处于可运行和不可中断状态的进程数，内核会每五秒收集一次当前的负载数。通过汇总这些数值，可以得到最近1分钟、5分钟和15分钟内的指数移动平均值。</p>
<h3 id="负载平均值计算"><a href="#负载平均值计算" class="headerlink" title="负载平均值计算"></a>负载平均值计算</h3><p>​	负载平均值代表一段时间内感知的系统负载。通过报告CPU上准备运行的进程数以及等待磁盘或网络I&#x2F;O完成的进程数，Linux可以确定负载平均值。</p>
<ul>
<li>负载数是准备运行的进程数（进程状态为R）或等待I&#x2F;O完成的进程数（进程状态为D）的运行平均值。</li>
<li>一些UNIX系统仅考虑CPU使用率或运行列长度来指示系统负载。Linux还包含磁盘或网络利用率，因为与CPU负载一样，这些资源使用量较高会对系统性能产生重大影响。如果负载平均值很高但CPU活动很低，请检查磁盘和网络活动。</li>
</ul>
<p>​	负载平均值可以粗略衡量在执行其他任何作业之前，有多少进程当前在等待请求完成。请求可能是用于运行进程的CPU时间。或者，请求可能是让关键磁盘I&#x2F;O操作完成；在其他作业请求完成之前，不能在CPU上运行该进程，即使CPU空闲也不行。无论是哪种方法，都会影响系统负载；系统的运行看起来会变慢，因为有进程正在等待运行。</p>
<h3 id="解读负载平均值"><a href="#解读负载平均值" class="headerlink" title="解读负载平均值"></a>解读负载平均值</h3><p>​	uptime命令是显示当前负载平均值的一种方法。它可显示当前时间、计算机启动时长、运行的用户会话数以及当前的负载平均值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">uptime</span> </span><br><span class="line"> 16:30:20 up  6:24,  1 user,  load average: 0.07, 0.03, 0.01</span><br></pre></td></tr></table></figure>

<p>​	这三个负载平均值代表了最近1、5和15分钟的负载情况。它指出了系统负载似乎在增高还是降低。</p>
<p>​	如果等待CPU处理的进程是负载平均值的主要贡献因素，则可以计算近似的每个CPU负载值以判断系统是否在遭遇显著的等待。</p>
<p>​	使用lscpu命令来确定系统上存在的CPU数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@foundation0 ~]# lscpu </span><br><span class="line">Architecture:            x86_64</span><br><span class="line">  CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">  Address sizes:         45 bits physical, 48 bits virtual</span><br><span class="line">  Byte Order:            Little Endian</span><br><span class="line">CPU(s):                  8</span><br><span class="line">  On-line CPU(s) list:   0-7</span><br><span class="line">Vendor ID:               GenuineIntel</span><br><span class="line">  BIOS Vendor ID:        GenuineIntel</span><br><span class="line">  Model name:            13th Gen Intel(R) Core(TM) i9-13980HX</span><br><span class="line">    BIOS Model name:     13th Gen Intel(R) Core(TM) i9-13980HX</span><br><span class="line">    CPU family:          6</span><br><span class="line">    Model:               183</span><br><span class="line">    Thread(s) per core:  1</span><br><span class="line">    Core(s) per socket:  2</span><br><span class="line">    Socket(s):           4</span><br><span class="line">    Stepping:            1</span><br><span class="line">    BogoMIPS:            4838.40</span><br><span class="line">    Flags:               fpu vme de pse tsc msr pae mce cx8 ...忽略....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	暂时不妨设想，需要CPU时间的进程是负载数的唯一贡献因素。然后您可以用显示的负载平均值除以系统中的逻辑CPU数。值低于1表示资源利用率适当，等待时间较短。值高于1表示资源饱和，而且有一些处理处于延迟。</p>
<p>​	空闲CPU队列的负载数为0。每个等待CPU处理的进程都会使负载数加1.如果有一个进程在CPU上运行，则负载数为1；虽然资源（CPU）处于使用状态，单没有等待的请求。如果改进程运行了整整一分钟，那么它对这一分钟负载平均值的贡献就是1。</p>
<p>​	不过，因为磁盘或忘了资源忙碌而等待关键I&#x2F;O并处于不可中断睡眠状态的进行也包含在该计数内，而且会使负载平均值增大。虽然不能表示CPU使用率，但这些进程也被添加到队列数中，因为它们正在等待资源，并且在获取资源之前无法在CPU上运行。由于资源限制导致无法运行，因此这一指标仍被视为系统负载。</p>
<p>​	在资源饱和之前，负载平均值将保持在1以下，因为几乎不会在队列中发现等待的认为。只有资源饱和导致请求留在排队状态并且被负载计算例程计数时，负载平均值才会增大。当资源使用率接近100%时，每个增加的请求将开始遭遇服务等待时间。</p>
<h3 id="实时进程监控"><a href="#实时进程监控" class="headerlink" title="实时进程监控"></a>实时进程监控</h3><p>​	top命令显示系统进程的动态视图，以及一个摘要标题，后跟一个进程或线程列表。与静态的ps命令输出不同，top命令以可配置的间隔持续刷新，而且也提供列重新排列、排序和突出显示功能。您可以对top设置进行持久更改。默认的top输出列如下：</p>
<ul>
<li>进程ID（PID）</li>
<li>进程所有者用户名（USER）</li>
<li>虚拟内存（VIRT）是进程正在使用的所有内存，包括常驻集合、共享库，以及任何映射或交换的内存页。（在ps命令中标题为VSZ）</li>
<li>常驻内存（ERS）是进程所使用的物流内存，包括任何驻留2的共享对象（在ps命令中标题为RSS）</li>
<li>进程状态（S）可以是以下状态之一：<ul>
<li>D&#x3D; 不可中断睡眠</li>
<li>R&#x3D;运行中可运行</li>
<li>S&#x3D;睡眠中</li>
<li>T&#x3D;已停止或已跟踪</li>
<li>Z&#x3D;僵停</li>
</ul>
</li>
<li>CPU时间（TIME）是进程启动以来总的处理时间。可以切换为包含所有过去子进程的累计时间。</li>
<li>进程命令名称（CMMMAND）。</li>
</ul>
<p><strong>top命令中的基本击键操作</strong></p>
<table>
<thead>
<tr>
<th>键</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>？或h</td>
<td>交互式击键操作的帮助。</td>
</tr>
<tr>
<td>l、t、m</td>
<td>切换到负载、线程和内存标题行。</td>
</tr>
<tr>
<td>1</td>
<td>标题张却换显示单独CPU信息或所有CPU汇总。</td>
</tr>
<tr>
<td>s</td>
<td>更改（屏幕）刷新率，以小数点的秒数表示（如0.5、1、5）</td>
</tr>
<tr>
<td>b</td>
<td>却换反色突出显示Running进程；默认为仅粗体。</td>
</tr>
<tr>
<td>Sheift+b</td>
<td>在显示中使用粗体，用于标题以及运行中的进程。</td>
</tr>
<tr>
<td>Sheift+h</td>
<td>切换线程；显示进程摘要或单独线程。</td>
</tr>
<tr>
<td>u、Sheift+u</td>
<td>过滤任何用户名（有效、真实）</td>
</tr>
<tr>
<td>Sheift+m</td>
<td>按照内存使用率，以降序方式对进程列表排序。</td>
</tr>
<tr>
<td>Sheift+p</td>
<td>按照处理器使用率，以降序方式对进程列表排序。</td>
</tr>
<tr>
<td>k</td>
<td>中止进程。如有提示，输入PID，在输入signal。</td>
</tr>
<tr>
<td>r</td>
<td>调整进程的nice值。若有提示，输入PID，再输入nice_value。（nice值为-20到19，值越低代表该进程优先级越高）</td>
</tr>
<tr>
<td>Sheift+w</td>
<td>写入（保存）当前的显示配置，一遍下一次重新启动top时使用</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>f</td>
<td>通过启用或禁用字段的方式来管理列。也可以为top设置排序字段。（d选中或显示列，s切换该列进行排序，q退出设置）</td>
</tr>
</tbody></table>
<p>​	<code>注意：再安全模式下启动top命令时，s、k和r击键操作不可用。</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">李维虎</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/">http://example.com/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">此文章版权归博主所有，如有转载，请注明来自原作者，联系方式（微信）：a1253582301</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RHCE/">RHCE</a></div><div class="post-share"><div class="social-share" data-image="/img/doc_img/RHCE_cover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/20/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Linux%E6%A0%B9%E6%8C%82%E8%BD%BD%E7%9B%98%E6%89%A9%E5%AE%B9/" title="Linux根目录磁盘扩容"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux根目录磁盘扩容</div></div><div class="info-2"><div class="info-item-1">Linux根目录磁盘扩容环境准备假设目前我们的根目录磁盘使用率已达到100%，此刻我们的磁盘总容量为95G，并且通过lsblk发现了我新插入，即将要用于扩容到根目录的50G磁盘【nvme0n2】，环境已具备，即将开始扩容操作 1234567891011121314151617181920212223# 查看当前根目录磁盘使用情况[root@localhost ~]# df -h文件系统               容量  已用  可用 已用% 挂载点devtmpfs               4.0M     0  4.0M    0% /devtmpfs                  1.9G     0  1.9G    0% /dev/shmtmpfs                  777M  9.8M  767M    2% /run/dev/mapper/rhel-root   95G  4.9G   90G    6% //dev/nvme0n1p2         960M  264M  697M   28% /boot/dev/nvme0n1p1   ...</div></div></div></a><a class="pagination-related" href="/2025/06/04/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第八章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux-RHCE-124-第八章节</div></div><div class="info-2"><div class="info-item-1">控制服务和守护进程识别自动启动的系统进程Systemd守护进程简介​	Systemd守护进程管理Linux的启动过程，一般包括服务启动和服务管理。systemd守护进程可再系统引导时以及运行中的系统上激活系统资源、服务器守护进程和其他进程。 ​	守护进程是再执行各种任务的后台等待或运行的进程。一般情况下，守护进程再系统引导时自动启用并持续运行至关机或您手动将它停止。按照管理，守护进程的名称以及字母d结尾。 ​	在systemd意义上，服务通常是指一个或多个守护进程。但是，启动或停止服务可能会更改一次系统状态，之后不会留下一个运行中的守护进程（称之为oneshot）。 ​	在红帽企业Linux中，第一个启动的进程（PID1）是systemd守护进程，它提供以下功能：  并行化功能（同时运行多个服务），它可提高系统的启动速度。 按需启动守护进程，而不需要单独的服务。 自动服务依赖关系管理，可以防止长时间超时。例如，只有在网络可用时，依赖网络的服务才会尝试启动。 利用Linux控制组一起追踪相关进程的方式。  服务单元描述​	 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第三章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-07</div><div class="info-item-2">Linux-RHCE-124-第三章节</div></div><div class="info-2"><div class="info-item-1">在红帽企业Linux中获取帮助阅读手册页Linux手册页简介​	本地系统上通常可用的文档来源之一是系统手册页或man page。软件包随附这些页面来提供文档，您可以使用man命令从命令行访问这些文档。页面存储在&#x2F;usr&#x2F;share&#x2F;man 目录的子目录中。 ​	man page 源自过去的Linux程序员手册，该手册篇幅很长，足以划分多个章节。每个章节包含有特定主题信息。    章节 内容类型 描述    1 用户命令 可执行命令和shell程序   2 系统调用 从用户空间调用的内核例程   3 库函数 有程序库提供   4 特殊文件 例如设备文件   5 文件格式 用于许多配置文件和结构   6 游戏和屏保 过去的趣味程序章节   7 惯例、标准和其他 协议、文件系统   8 系统管理和特权命令 维护任务   9 Linux内核API 内部内核调用   ​	为区分不同章节中相同的主题名称，man...</div></div></div></a><a class="pagination-related" href="/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第二章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Linux-RHCE-124-第二章节</div></div><div class="info-2"><div class="info-item-1">从命令行管理文件​	 欢迎阅览我的文章，本章节将介绍什么是Linux，演示环境为RedHat-9 描述Linux文件系统层次结构概念​	Linux系统中的所有文件存储在文件系统中，他们被组织到一颗上下颠倒的树中，称为文件系统层次结构。这个层次结构是上下颠倒的树，因为树根在顶部，树根下方延伸处目录和子目录的分支。  ​	&#x2F; 目录是根目录，位于文件系统层次结构的顶部。&#x2F; 字符还用做文件名中的目录分隔符。例如：如果etc是&#x2F; 根目录的子目录，则可将该目录指代为 &#x2F;etc。类似的，如果&#x2F;etc目录包含一个名为issue的文件，可以将该文件指代为&#x2F;etc&#x2F;issue。 ​	&#x2F;...</div></div></div></a><a class="pagination-related" href="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第五章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-03</div><div class="info-item-2">Linux-RHCE-124-第五章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/02/27/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第一章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">Linux-RHCE-124-第一章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第六章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="info-item-2">Linux-RHCE-124-第六章节</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/06/04/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第八章节"><img class="cover" src="/img/doc_img/RHCE_cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-04</div><div class="info-item-2">Linux-RHCE-124-第八章节</div></div><div class="info-2"><div class="info-item-1">控制服务和守护进程识别自动启动的系统进程Systemd守护进程简介​	Systemd守护进程管理Linux的启动过程，一般包括服务启动和服务管理。systemd守护进程可再系统引导时以及运行中的系统上激活系统资源、服务器守护进程和其他进程。 ​	守护进程是再执行各种任务的后台等待或运行的进程。一般情况下，守护进程再系统引导时自动启用并持续运行至关机或您手动将它停止。按照管理，守护进程的名称以及字母d结尾。 ​	在systemd意义上，服务通常是指一个或多个守护进程。但是，启动或停止服务可能会更改一次系统状态，之后不会留下一个运行中的守护进程（称之为oneshot）。 ​	在红帽企业Linux中，第一个启动的进程（PID1）是systemd守护进程，它提供以下功能：  并行化功能（同时运行多个服务），它可提高系统的启动速度。 按需启动守护进程，而不需要单独的服务。 自动服务依赖关系管理，可以防止长时间超时。例如，只有在网络可用时，依赖网络的服务才会尝试启动。 利用Linux控制组一起追踪相关进程的方式。  服务单元描述​	 </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李维虎</div><div class="author-info-description">一个热爱技术分享的有志青年</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的<em>博客网站</em>，如对文章内容有疑惑可扫描二维码添加博主微信。</p> <p>文章来之不易，如认为文章不错请在文章底部为博主打赏,你的支持是我持续更新的动力</p> <CENTER><img src="img\index_img/wxewm.png" alt="描述文字" style="width:250px; height:250px;"></CENTER></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86Linux%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">监控和管理Linux进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">进程状态和生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">描述进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">进程状态的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">列出进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.2.</span> <span class="toc-text">控制作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.2.1.</span> <span class="toc-text">描述作业和会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">在后台运行作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">中止进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用信号控制进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">通过显示请求发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">控制特定进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.4.</span> <span class="toc-text">向多个进程发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E6%B3%A8%E9%94%80%E7%94%A8%E6%88%B7"><span class="toc-number">1.3.5.</span> <span class="toc-text">以管理员身份注销用户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E6%B4%BB%E5%8A%A8"><span class="toc-number">1.4.</span> <span class="toc-text">监控进程活动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E8%B4%9F%E8%BD%BD%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">1.4.1.</span> <span class="toc-text">描述负载平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E5%9D%87%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">负载平均值计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BB%E8%B4%9F%E8%BD%BD%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">1.4.3.</span> <span class="toc-text">解读负载平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7"><span class="toc-number">1.4.4.</span> <span class="toc-text">实时进程监控</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第三章"/></a><div class="content"><a class="title" href="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="CKA-kubernetes-第三章">CKA-kubernetes-第三章</a><time datetime="2025-07-14T03:36:45.000Z" title="发表于 2025-07-14 11:36:45">2025-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第二章"/></a><div class="content"><a class="title" href="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="CKA-kubernetes-第二章">CKA-kubernetes-第二章</a><time datetime="2025-07-03T01:40:06.000Z" title="发表于 2025-07-03 09:40:06">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章"><img src="/img/doc_img/Kubernetes.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA-kubernetes-第一章"/></a><div class="content"><a class="title" href="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="CKA-kubernetes-第一章">CKA-kubernetes-第一章</a><time datetime="2025-06-05T02:38:53.000Z" title="发表于 2025-06-05 10:38:53">2025-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/04/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第八章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第八章节"/></a><div class="content"><a class="title" href="/2025/06/04/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第八章节">Linux-RHCE-124-第八章节</a><time datetime="2025-06-04T08:24:51.000Z" title="发表于 2025-06-04 16:24:51">2025-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第七章节"><img src="/img/doc_img/RHCE_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-RHCE-124-第七章节"/></a><div class="content"><a class="title" href="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/" title="Linux-RHCE-124-第七章节">Linux-RHCE-124-第七章节</a><time datetime="2025-05-26T08:59:32.000Z" title="发表于 2025-05-26 16:59:32">2025-05-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/doc_img/RHCE_cover.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 李维虎</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">主题框架声明</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="晚,上,好" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>