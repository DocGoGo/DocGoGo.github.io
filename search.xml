<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux根目录磁盘扩容</title>
    <url>/2025/05/20/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Linux%E6%A0%B9%E6%8C%82%E8%BD%BD%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="Linux根目录磁盘扩容"><a href="#Linux根目录磁盘扩容" class="headerlink" title="Linux根目录磁盘扩容"></a>Linux根目录磁盘扩容</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>假设目前我们的根目录磁盘使用率已达到100%，此刻我们的磁盘总容量为95G，并且通过lsblk发现了我新插入，即将要用于扩容到根目录的50G磁盘【nvme0n2】，环境已具备，即将开始扩容操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前根目录磁盘使用情况</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">df</span> -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs               4.0M     0  4.0M    0% /dev</span><br><span class="line">tmpfs                  1.9G     0  1.9G    0% /dev/shm</span><br><span class="line">tmpfs                  777M  9.8M  767M    2% /run</span><br><span class="line">/dev/mapper/rhel-root   95G  4.9G   90G    6% /</span><br><span class="line">/dev/nvme0n1p2         960M  264M  697M   28% /boot</span><br><span class="line">/dev/nvme0n1p1         599M  7.1M  592M    2% /boot/efi</span><br><span class="line">tmpfs                  389M   52K  389M    1% /run/user/42</span><br><span class="line">tmpfs                  389M  100K  389M    1% /run/user/0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前服务器盘符使用情况</span></span><br><span class="line">[root@localhost ~]# lsblk </span><br><span class="line">NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sr0            11:0    1 1024M  0 rom  </span><br><span class="line">nvme0n1       259:0    0  100G  0 disk </span><br><span class="line">├─nvme0n1p1   259:1    0  600M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p2   259:2    0    1G  0 part /boot</span><br><span class="line">└─nvme0n1p3   259:3    0 98.4G  0 part </span><br><span class="line">  ├─rhel-root 253:0    0 94.5G  0 lvm  /</span><br><span class="line">  └─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]</span><br><span class="line">nvme0n2       259:4    0   50G  0 disk</span><br></pre></td></tr></table></figure>



<h3 id="根目录磁盘扩容"><a href="#根目录磁盘扩容" class="headerlink" title="根目录磁盘扩容"></a>根目录磁盘扩容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为新磁盘创建一个分区，p（主分区）、默认回车、w（退出并保存分区）</span></span><br><span class="line">[root@localhost ~]# fdisk /dev/nvme0n2 </span><br><span class="line"></span><br><span class="line">欢迎使用 fdisk (util-linux 2.37.4)。</span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">设备不包含可识别的分区表。</span><br><span class="line">创建了一个磁盘标识符为 0x31c8cf52 的新 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">分区类型</span><br><span class="line">   p   主分区 (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)：p</span><br><span class="line">分区号 (1-4, 默认  1): </span><br><span class="line">第一个扇区 (2048-104857599, 默认 2048): </span><br><span class="line">最后一个扇区，+/-sectors 或 +size&#123;K,M,G,T,P&#125; (2048-104857599, 默认 104857599): </span><br><span class="line"></span><br><span class="line">创建了一个新分区 1，类型为“Linux”，大小为 50 GiB。</span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 查看分区是否创建成功，新分区名称为【nvme0n2p1】</span></span><br><span class="line">[root@localhost ~]# lsblk -f </span><br><span class="line">NAME          FSTYPE      FSVER    LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sr0                                                                                            </span><br><span class="line">nvme0n1                                                                                        </span><br><span class="line">├─nvme0n1p1   vfat        FAT32          C427-1A51                               591.8M     1% /boot/efi</span><br><span class="line">├─nvme0n1p2   xfs                        93d050f3-c57c-44e8-a059-c029b36cced1    696.4M    27% /boot</span><br><span class="line">└─nvme0n1p3   LVM2_member LVM2 001       k059oe-foEY-M2YG-cKsQ-YqYB-xHgk-S3b5cs                </span><br><span class="line">  ├─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  └─rhel-swap swap        1              18d4dd2e-af9f-4f75-b78b-a9335fda999d                  [SWAP]</span><br><span class="line">nvme0n2                                                                                        </span><br><span class="line">└─nvme0n2p1</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将新分区创建为PV</span></span><br><span class="line">[root@localhost dev]# pvcreate /dev/nvme0n2p1 </span><br><span class="line">  Physical volume <span class="string">&quot;/dev/nvme0n2p1&quot;</span> successfully created.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看PV是否创建成功，可以看到【nvme0n1p3】是我现在根磁盘用的90多G的容量，而【nvme0n2p1】是新加进来的50G容量</span></span><br><span class="line">[root@localhost dev]# pvs</span><br><span class="line">  PV             VG   Fmt  Attr PSize   PFree  </span><br><span class="line">  /dev/nvme0n1p3 rhel lvm2 a--   98.41g   4.00m</span><br><span class="line">  /dev/nvme0n2p1      lvm2 ---  &lt;50.00g &lt;50.00g</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询VG现有使用情况，可以看到VG空闲内容已经不够了</span></span><br><span class="line">[root@localhost dev]# vgs</span><br><span class="line">  VG    <span class="comment">#PV #LV #SN Attr   VSize   VFree  </span></span><br><span class="line">  rhel    1   2   0 wz--n-  98.41g   4.00m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为根磁盘的VG增加空闲容量，将新的PV容量增加到这个VG</span></span><br><span class="line">[root@localhost dev]# vgextend rhel /dev/nvme0n2p1 </span><br><span class="line">  Volume group <span class="string">&quot;rhel&quot;</span> successfully extended</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看vg扩容是否成功，VG已经从原先的98G变成了148G，空闲50G可用</span></span><br><span class="line">[root@localhost dev]# vgs</span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize    VFree </span></span><br><span class="line">  rhel   2   2   0 wz--n- &lt;148.41g 50.00g</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看VG剩余数据块有多少【Free  PE / Size       12800 / 50.00 GiB】剩余12800个数据块</span></span><br><span class="line">[root@localhost dev]# vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               rhel</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  4</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;148.41 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              37992</span><br><span class="line">  Alloc PE / Size       25192 / &lt;98.41 GiB</span><br><span class="line">  Free  PE / Size       12800 / 50.00 GiB</span><br><span class="line">  VG UUID               3mFZRu-uZbm-pyEC-xAp8-42Zj-rxjz-uClt98</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看现有LV容量大小，root（根磁盘容量）、swap（swap容量）</span></span><br><span class="line">[root@localhost dev]# lvs</span><br><span class="line">  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  root rhel -wi-ao---- &lt;94.49g                                                    </span><br><span class="line">  swap rhel -wi-ao----  &lt;3.92g</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩容LV，对【/dev/rhel/root】扩容，【-l +12800】 对该LV增加12800个数据块</span></span><br><span class="line"><span class="comment"># 或者也可用根据GiB来进行增加，则使用该命令【lvextend /dev/rhel/root -L +50GiB】</span></span><br><span class="line">[root@localhost dev]# lvextend /dev/rhel/root -l +12800 </span><br><span class="line">  Size of logical volume rhel/root changed from &lt;94.49 GiB (24189 extents) to &lt;144.49 GiB (36989 extents).</span><br><span class="line">  Logical volume rhel/root successfully resized.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看根目录是文件系统，可以看到，我们原先的和新增的磁盘分区都是xfs文件系统类型</span></span><br><span class="line">[root@localhost dev]# lsblk -f</span><br><span class="line">NAME          FSTYPE      FSVER    LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sr0                                                                                            </span><br><span class="line">nvme0n1                                                                                        </span><br><span class="line">├─nvme0n1p1   vfat        FAT32          C427-1A51                               591.8M     1% /boot/efi</span><br><span class="line">├─nvme0n1p2   xfs                        93d050f3-c57c-44e8-a059-c029b36cced1    696.4M    27% /boot</span><br><span class="line">└─nvme0n1p3   LVM2_member LVM2 001       k059oe-foEY-M2YG-cKsQ-YqYB-xHgk-S3b5cs                </span><br><span class="line">  ├─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  └─rhel-swap swap        1              18d4dd2e-af9f-4f75-b78b-a9335fda999d                  [SWAP]</span><br><span class="line">nvme0n2                                                                                        </span><br><span class="line">└─nvme0n2p1   LVM2_member LVM2 001       BK4L6G-1Lt3-FuPS-5UTS-R0bm-fTIC-f2F60g                </span><br><span class="line">  └─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重载文件系统：根据你的文件系统选择重载所使用的方式</span></span><br><span class="line"><span class="comment"># 1、xfs使用【xfs_growfs /dev/rhel/root】</span></span><br><span class="line"><span class="comment"># 2、ext使用【resize2fs /dev/rhel/root】</span></span><br><span class="line">[root@localhost dev]# xfs_growfs /dev/rhel/root </span><br><span class="line">meta-data=/dev/mapper/rhel-root  isize=512    agcount=4, agsize=6192384 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0</span><br><span class="line">data     =                       bsize=4096   blocks=24769536, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=16384, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 24769536 to 37876736</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看磁盘容量，此时根目录的文件大小则从原来的95变成了145G</span></span><br><span class="line">[root@localhost dev]# <span class="built_in">df</span> -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs               4.0M     0  4.0M    0% /dev</span><br><span class="line">tmpfs                  1.9G     0  1.9G    0% /dev/shm</span><br><span class="line">tmpfs                  777M  9.7M  768M    2% /run</span><br><span class="line">/dev/mapper/rhel-root  145G  5.3G  140G    4% /</span><br><span class="line">/dev/nvme0n1p2         960M  264M  697M   28% /boot</span><br><span class="line">/dev/nvme0n1p1         599M  7.1M  592M    2% /boot/efi</span><br><span class="line">tmpfs                  389M   52K  389M    1% /run/user/42</span><br><span class="line">tmpfs                  389M   36K  389M    1% /run/user/0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux常见问题</category>
      </categories>
      <tags>
        <tag>Linux常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第二章节</title>
    <url>/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="从命令行管理文件"><a href="#从命令行管理文件" class="headerlink" title="从命令行管理文件"></a>从命令行管理文件</h1><p>​	</p>
<p>欢迎阅览我的文章，本章节将介绍什么是Linux，演示环境为RedHat-9</p>
<h3 id="描述Linux文件系统层次结构概念"><a href="#描述Linux文件系统层次结构概念" class="headerlink" title="描述Linux文件系统层次结构概念"></a>描述Linux文件系统层次结构概念</h3><p>​	Linux系统中的所有文件存储在文件系统中，他们被组织到一颗上下颠倒的树中，称为文件系统层次结构。这个层次结构是上下颠倒的树，因为树根在顶部，树根下方延伸处目录和子目录的分支。</p>
<p><img src="/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/image-20250520165728913.png" alt="image-20250520165728913"></p>
<p>​	&#x2F; 目录是根目录，位于文件系统层次结构的顶部。&#x2F; 字符还用做文件名中的目录分隔符。例如：如果etc是&#x2F; 根目录的子目录，则可将该目录指代为 &#x2F;etc。类似的，如果&#x2F;etc目录包含一个名为issue的文件，可以将该文件指代为&#x2F;etc&#x2F;issue。</p>
<p>​	&#x2F; 的子目录用于标准化用途，以便根据类型和用途整理文件，从而更加轻松的找到文件，例如：在根目录中，子目录&#x2F;boot用于存储启动系统所需的文件。</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">位置</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;boot</td>
<td>操作系统启动过程所需文件</td>
</tr>
<tr>
<td align="left">&#x2F;dev</td>
<td>供操作系统访问硬件的特殊设备文件</td>
</tr>
<tr>
<td align="left">&#x2F;etc</td>
<td>供系统及软件的配置文件</td>
</tr>
<tr>
<td align="left">&#x2F;home</td>
<td>供普通用户存储其个人数据及配置文件的主目录</td>
</tr>
<tr>
<td align="left">&#x2F;root</td>
<td>供超级用户root存储其个人数据及配置文件的主目录</td>
</tr>
<tr>
<td align="left">&#x2F;run</td>
<td>自上一次系统启动以来启动的进程的运行时数据。这些数据包括进程ID文件和锁定文件。此目录中的内容在重启时重新创建。所以该目录的数据在重启后，存放在该目录下的数据就会丢失。</td>
</tr>
<tr>
<td align="left">&#x2F;tmp</td>
<td>供临时文件使用的全局可写空间，天内未曾访问、更改或者修改的文件将自动从该目录中删除。&#x2F;var&#x2F;tmp目录也是一个临时目录，其中的文件如果在30天内为曾访问、更改或者修改过，将被自动删除</td>
</tr>
<tr>
<td align="left">&#x2F;usr</td>
<td>安装的软件、共享的库（包括文件）和只读程序数据。重要的子目录有：                                                                                       - &#x2F;usr&#x2F;bin：用户命令                                                                            - &#x2F;usr&#x2F;sbin：系统管理命令                                                               - &#x2F;usr&#x2F;local：本地自定义软件</td>
</tr>
<tr>
<td align="left">&#x2F;var</td>
<td>特定于系统的可变数据应在系统启动之间保持永久性。动态变化的文件（如数据库、缓存目录、日志文件、打印机后台处理文档和网页内容）可在&#x2F;var下找到</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="通过名称指定文件"><a href="#通过名称指定文件" class="headerlink" title="通过名称指定文件"></a>通过名称指定文件</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>​	文件或目录的路径指定其唯一的文件系统位置。跟随文件路径会遍历出一个或多个指定的子目录，用正斜杠 (&#x2F;) 分隔，直到达到目标位置。目录也称之为文件夹，可以包含其文件和其他子目录。目录的引用方式可以与文件相同</p>
<p>​	<code>注意：Linux文件名中可以接收空格字符。但是shell也使用空格来分割命令行上的选项和参数。如果命令中包含了名称带有空格的文件，则shell可能会误解释该参数，并认为该文件名是多个参数。为避免这样的情况，请将此类文件名括在引号中，以便shell激昂名称解释为单个参数。当然最好避免在文件中名中使用空格是最好的。</code></p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>​	绝对路径是一个完全限定名称，用于指定文件在文件系统层次结构中的确切位置。绝对路径从根 (&#x2F;) 目录开始寻找目标文件或目录，并包括到达特定文件所必须遍历的每个子目录。文件系统中的每个文件都有一个唯一绝对路径名，可通过一个简单的规则识别：第一个字符是正斜杠 (&#x2F;) 的路径名是绝对路径名。</p>
<p>​	例如，系统消息日志文件的绝对路径名是 &#x2F;var&#x2F;log&#x2F;messages。绝对路径名输入起来可能会太长，所以也可以通过相对于shell提示符当前工作目录的位置来查找文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation ~]# <span class="built_in">ls</span> /var/log/messages</span><br><span class="line">/var/log/messages</span><br><span class="line">[root@workstation ~]# </span><br></pre></td></tr></table></figure>



<h3 id="当前工作目录和相对路径"><a href="#当前工作目录和相对路径" class="headerlink" title="当前工作目录和相对路径"></a>当前工作目录和相对路径</h3><p>​	当用户登录并打开shell命令提示符时，初始位置通常是该用户的主目录。系统进程也有一个初始目录。用户和进程根据需要更改到其他目录。属于工作目录和当前目录指它们的当前位置</p>
<p>​	与绝对路径类似，相对路径也是标识唯一文件，但仅指定从工作目录到达文件所需的路径。相对路径遵循一个简单原则：第一字符是正斜杠之外的其他字符的路径名就是相对路径名。例如：我当前工作目录为&#x2F;var，我要找到消息日志文件则是：log&#x2F;messages</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation var]# <span class="built_in">ls</span> <span class="built_in">log</span>/messages</span><br><span class="line"><span class="built_in">log</span>/messages</span><br><span class="line">[root@workstation var]# </span><br></pre></td></tr></table></figure>

<p>​	Linux文件系统（包括ext4、XFS、GFS2和GlusterFS）是区分大小写的。在同一目录中创建FileCase.txt和filecase.txt文件将会生成两个不同的文件。</p>
<p>​	非Linux文件系统的工作方式可能会有所不同。例如：VFAT、Microsoft的NTFS和Apple的HFS+具有大小写保留行为。虽然这些文件系统不区分大小写，它们确实使用文件的原始大小写形式显示的文件名。如果在VFAT文件系统上创建上述示例中的文件，这两个名称指向同一文件，而部署指向两个不同的文件。</p>
<h3 id="浏览文件系统中的路径"><a href="#浏览文件系统中的路径" class="headerlink" title="浏览文件系统中的路径"></a>浏览文件系统中的路径</h3><p>​	pwd命令显示改shell的当前工作目录的完整路径名。此命令可帮助您却独使用当前相对路径来访问文件的语法。ls命令列出指定目录的目录内容。如果未指定目录，则列出当前工作目录的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation var]# <span class="built_in">pwd</span></span><br><span class="line">/var</span><br><span class="line">[root@workstation var]# <span class="built_in">ls</span></span><br><span class="line">account  cache  db     ftp    kerberos  <span class="built_in">local</span>  <span class="built_in">log</span>   nis  preserve  spool  yp</span><br><span class="line">adm      crash  empty  games  lib       lock   mail  opt  run       tmp</span><br><span class="line">[root@workstation var]# </span><br></pre></td></tr></table></figure>



<p>​	使用cd命令可更改shell当前工作目录。如果没有未该命令指定任何参数，它将切换到您用户的主目录。</p>
<p>​	以下示例中，cd命令混用绝对路径和相对路径，以更改shell当前工作目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd查看当前工作目录</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line"><span class="comment"># 通过相对路径进去主目录的test1</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> test1/</span><br><span class="line">[student@workstation test1]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test1</span><br><span class="line">[student@workstation test1]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line"><span class="comment"># 通过绝对路径到主目录下的test3</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> /home/student/test3</span><br><span class="line">[student@workstation test2]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test3</span><br><span class="line"><span class="comment"># 通过相对路径进去主目录的test2</span></span><br><span class="line">[student@workstation test1]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> test2/</span><br><span class="line">[student@workstation test2]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test2</span><br><span class="line"><span class="comment"># 通过cd不加参数，返回主目录</span></span><br><span class="line">[student@workstation test2]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line">[student@workstation ~]$</span><br></pre></td></tr></table></figure>

<p>​	在上述示例中，默认shell提示符还显示当前工作目录绝对路径的最后一个目录。例如，对于&#x2F;home&#x2F;student&#x2F;test1目录，仅显示test1。当您的当前目录是主目录时，提示符显示波浪号字符 (~)。</p>
<p>​	touch 命令可将文件的时间戳更新为当前日期和时间，而不进行其他修改。此命令同时也可以用于创建空的文件，因为使用touch命令加上不存在的文件名参数就会导致创建该文件。在以下示例中，touch命令在Videos子目录中创建文件，以及修改文件更新时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch 接上一个不存在的文件名参数，则创建文件</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">touch</span> test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:35 test1.txt</span><br><span class="line"><span class="comment"># 向该文件添加内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">echo</span> hahaah &gt; test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cat</span> test1.txt </span><br><span class="line">hahaah</span><br><span class="line"><span class="comment"># 修改时间为17:36</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:36 test1.txt</span><br><span class="line"><span class="comment"># 当touch 接上已存在的文件名参数，则最新修改时间更新</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">touch</span>  test1.txt </span><br><span class="line"><span class="comment"># 修改时间为：17:38</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 切文件的内容未作更改</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cat</span> test1.txt </span><br><span class="line">hahaah</span><br><span class="line">[kiosk@foundation0 Videos]$ </span><br></pre></td></tr></table></figure>



<p>​	ls 命令具有多个选项，用于显示文件的属性。最常的选项是 -l （长列表格式）、-a（包含隐藏文件在内的所有文件），以及 -R （递归方式，包含所有子目录的内容）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 长格式显示目录或指定目录下的内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 6 Mar  4 17:45 dir1</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:45 dir-1.txt</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 6 Mar  4 17:45 dir2</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:45 dir-2.txt</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 长格式显示，并且显示包含隐藏文件（.haha.txt）</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -la</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x.  4 kiosk kiosk   98 Mar  4 17:45 .</span><br><span class="line">drwx------. 18 kiosk kiosk 4096 Feb 27 15:08 ..</span><br><span class="line">drwxrwxr-x.  2 kiosk kiosk    6 Mar  4 17:45 dir1</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 dir-1.txt</span><br><span class="line">drwxrwxr-x.  2 kiosk kiosk    6 Mar  4 17:45 dir2</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 dir-2.txt</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 .haha.txt</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 长格式及递归显示dir1目录下的内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -lR dir1/</span><br><span class="line"><span class="comment"># dir1下具有test-dir、test-dir-2目录</span></span><br><span class="line">dir1/:</span><br><span class="line">total 0</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 23 Mar  4 17:50 test-dir</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 23 Mar  4 17:50 test-dir-2</span><br><span class="line"><span class="comment"># test-dir目录下具有test1.txt文件</span></span><br><span class="line">dir1/test-dir:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:50 test1.txt</span><br><span class="line"><span class="comment"># test-dir-2目录下具有test2.txt文件</span></span><br><span class="line">dir1/test-dir-2:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:50 test2.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ </span><br></pre></td></tr></table></figure>

<p>​	ls -la中的显示了所有的目录，包括隐藏目录，其中顶部具有两个特殊的目录。一个圆点（.）代表当前目录，两个原点（..）则代表父级目录，也就是当前目录的上一级目录。这些特殊目录存在于系统中的每一个目录中，在使用文件管理命令时非常有用。</p>
<p>​	<code>重要：开头为圆点（.）的文件名表示为隐藏文件；在使用ls和其他命令时，无法在普通视图中看到这些文件。此行为并非一种安全功能。因为ls -a加上选项还是可以很轻松的看到该文件。隐藏文件主要还是用于必要的用户配置文件让主目录凌乱不堪，同时也可以避免重要的配置文件被误操作，复制到其他目录或被修改、删除掉。</code></p>
<p>​	您也可以讲波浪号（~）特殊字符于其他命令组合使用，以促进于主目录的交互。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前工作目录/var，通过波浪号查看主目录内容</span></span><br><span class="line">[kiosk@foundation0 var]$ <span class="built_in">ls</span> -l ~</span><br><span class="line">total 152588</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk       127 Oct  9  2023 <span class="string">&#x27;\&#x27;</span></span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     33577 Sep 16  2022  ClassPrep.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     10853 Nov 16  2021  ClassRHAPrep.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     18852 Jul  7  2022  ClassroomReset.txt</span><br><span class="line">****忽略****</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk      7900 Nov 22  2022  History.txt</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Music</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Pictures</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Public</span><br><span class="line">-rwxrwxrwx. 1 kiosk kiosk        12 Feb 27 11:35  ssh.sh</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk        72 Jan 31  2023  survey</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Templates</span><br><span class="line">drwxr-xr-x. 4 kiosk kiosk        98 Mar  4 17:45  Videos</span><br><span class="line">[kiosk@foundation0 var]$ </span><br></pre></td></tr></table></figure>



<p>​	cd 命令同样有着许多选项。其中一些实用的应该尽早熟悉使用，要形成一种肌肉记忆。cd - 命令可更改到用户在进入当前目录之前所处的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过cd - 命令，迅速返回到之前所处的目录</span></span><br><span class="line">[kiosk@foundation0 var]$ <span class="built_in">cd</span> -</span><br><span class="line">/home/kiosk</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	<code>cd ..</code> 命令使用（..）隐藏目录上移一个级别，进入当前目录的父目录，而不必知道确切的父目录名称。其他隐藏目录（.）可为当前位置是来源或者目标参数的命令指定当前目录，以此免除输入目录绝对路径名的必要。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回上级目录</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> ..</span><br><span class="line">[kiosk@foundation0 home]$ <span class="built_in">pwd</span></span><br><span class="line">/home</span><br><span class="line"><span class="comment"># cd -返回上次所在目录</span></span><br><span class="line">[kiosk@foundation0 home]$ <span class="built_in">cd</span> -</span><br><span class="line">/home/kiosk</span><br><span class="line"><span class="comment"># 执行当前目录下的test.sh脚本文件</span></span><br><span class="line">[kiosk@foundation0 ~]$ bash ./test.sh </span><br><span class="line">Hello World</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用命令行工具管理文件"><a href="#使用命令行工具管理文件" class="headerlink" title="使用命令行工具管理文件"></a>使用命令行工具管理文件</h2><h3 id="命令行文件管理"><a href="#命令行文件管理" class="headerlink" title="命令行文件管理"></a>命令行文件管理</h3><p>​	创建、删除、复制和移动文件和目录，是系统管理员的常用操作。不带选项时，一些命令讲用于文件交互，或者可以通过相应的选项集来操作目录。</p>
<p>​	请注意运行命令时使用的选项。某些选项的含义可能因命令而异。</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>​	mkdir 命令可创建一个或多个目录或子目录。他取您要创建的目录的路径列表作为参数。</p>
<p>​	以下实例，将在&#x2F;home&#x2F;kiosk&#x2F;Documents目录下。使用mkdir命令和空格分割的目录名称列表来一次性创建多个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk/Documents</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">mkdir</span> ProjectX ProjectY ProjectZ</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span></span><br><span class="line">ProjectX  ProjectY  ProjectZ</span><br><span class="line">[kiosk@foundation0 Documents]$</span><br></pre></td></tr></table></figure>

<p>​	如果创建的目录参数已存在，或者您尝试创建的目录的父目录不存在，则mkdir命令将失败显示错误。</p>
<p>​	mkdir 命令 -p（父级）选项将为请求的目标位置创建缺失的父目录。在以下示例中，mkdir命令可以在缺少父级目录的情况下，用一个命令创建三个ChapterN子目录。 -p 选项可创建缺失的父目录Thesis。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 Documents]$ <span class="built_in">mkdir</span> -p Thesis/Chapter1 Thesis/Chapter2 Thesis/Chapter3</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> -R Thesis/</span><br><span class="line">Thesis/:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line"></span><br><span class="line">Thesis/Chapter1:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter2:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter3:</span><br><span class="line">[kiosk@foundation0 Documents]$</span><br></pre></td></tr></table></figure>

<p>​	请谨慎使用mkdir 命令的 -p 选项，因为在错误的拼写中可能会创建非预期的目录，不会因为对于您是非预期的目录，而生成错误消息。在以下示例中，假设您试图在Videos中创建一个Watched子目录，但在mkdir命令中不小心遗漏了Videos中的字母 “s”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> Video/Watched</span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Video/Watched’: No such file or directory</span><br><span class="line"><span class="comment"># 加入-p选项，Watched目录将会创建在错误父目录中</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> -p Video/Watched</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -R Video</span><br><span class="line">Video:</span><br><span class="line">Watched</span><br><span class="line"></span><br><span class="line">Video/Watched:</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	mkdir 命令失败，因为Video目录不存在。如果您使用带有-p 选项的mkdir 命令，则会无意中创建Video目录。Watched子目录将会在不正确的目录中创建。</p>
<h3 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h3><p>​	cp 命令可以复制文件，并在当前目录或者其他指定目录中创建一个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> Videos/</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span></span><br><span class="line">test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cp</span> test1.txt test2.txt </span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span></span><br><span class="line">test1.txt  test2.txt</span><br><span class="line">[kiosk@foundation0 Videos]$</span><br></pre></td></tr></table></figure>

<p>​	也可以使用cp命令将多个文件复制到某一目录中。这种情况下，最后一个参数必须是目录。复制的文件在新目录中保留其原有名称。如果目标目录中存在同名的文件，则会覆盖原有文件。默认情况下，cp 命令不复制目录，而是会忽略它。</p>
<p>​	以下示例中列出两个目录作为参数，即Thesis和ProjecrX目录。最后一个参数（ProjecrX目录）是目标，可用作目的地。cp命令忽略了Thesis参数，因为它是要复制的对象是一个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> </span><br><span class="line">ProjecrX  text1.txt  text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">cp</span> text1.txt text2.txt Thesis ProjecrX</span><br><span class="line"><span class="built_in">cp</span>: -r not specified; omitting directory <span class="string">&#x27;Thesis&#x27;</span></span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> Thesis ProjecrX</span><br><span class="line">ProjecrX:</span><br><span class="line">text1.txt  text2.txt</span><br><span class="line"></span><br><span class="line">Thesis:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>

<p>​	Thesis目录复制失败，但test1.txt和test2.txt文件复制成功。</p>
<p>​	您可以使用cp 命令 -r 选项复制目录及其内容，请记住，您可以在命令组合中使用.和..特殊目录。在以下示例中，Thesis目录及其内容复制到ProjecrX目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">cd</span> ProjecrX/</span><br><span class="line"><span class="comment"># cp 复制， ../上级目录的Thesis目录， .目的地当前所在工作目录</span></span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">cp</span> -r ../Thesis/ .</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text1.txt  text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> -R Thesis/</span><br><span class="line">Thesis/:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line"></span><br><span class="line">Thesis/Chapter1:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter2:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter3:</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ </span><br></pre></td></tr></table></figure>



<h3 id="移动文件和目录"><a href="#移动文件和目录" class="headerlink" title="移动文件和目录"></a>移动文件和目录</h3><p>​	mv 命令可将文件从一个位置移动到另一个位置。如果您将文件的绝对路径视为它的全名，那么移动文件实际上和重命名文件名一样。文件内容正在移动后保持不变。</p>
<p>​	使用mv命令来重命名文件。以下示例中，mv text1.txt命令将目录中的text1.txt 文件重命名为 text2.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text1.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">mv</span> text1.txt text2.txt </span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$</span><br></pre></td></tr></table></figure>

<p>​	使用mv 命令将文件移动到另一个目录。再以下示例中，text2.txt 文件从<del>&#x2F;Documents&#x2F;ProjecrX目录移动到</del>&#x2F;Documents&#x2F;Thesis&#x2F;Chapter1目录中。您可以使用mv命令 -v选项来显示命令操作的详细输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> ../Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">mv</span> -v text2.txt ../Thesis/Chapter1/</span><br><span class="line">renamed <span class="string">&#x27;text2.txt&#x27;</span> -&gt; <span class="string">&#x27;../Thesis/Chapter1/text2.txt&#x27;</span></span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> ../Thesis/Chapter1/</span><br><span class="line">text2.txt</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ </span><br></pre></td></tr></table></figure>



<h3 id="删除文件和目录"><a href="#删除文件和目录" class="headerlink" title="删除文件和目录"></a>删除文件和目录</h3><p>​	rm 命令可删除文件。默认情况下，rm不会删除目录。您可以使用rm命令的 -r或 –recursive选项，使rm命令删除目录及其内容（文件）。rm -r命令首先遍历每个子目录，并在删除每个目录之前逐一删除其中的文件。</p>
<p>​	在以下示例中，不带选项时rm 命令会删除test1.txt文件，但若要删除Thesis&#x2F;Chhapter1目录，您必须添加-r 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line">test1.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> Documents/Thesis/Chapter1/test1.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> Documents/Thesis/Chapter1/</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;Documents/Thesis/Chapter1/&#x27;</span>: Is a directory</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -r  Documents/Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;Documents/Thesis/Chapter1/&#x27;</span>: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis</span><br><span class="line">Chapter2  Chapter3</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>重要：红帽Linux不提供命令行取消删除功能，也没有可从中恢复报关被删除文件的“垃圾桶”。垃圾桶是桌面环境（如：GNOME）的一个组件，但是不供从shell运行的命令使用。所有在使用相对路径删除文件或目录之前，最好先使用pwd命令验证您当前的工作目录。</code></p>
<p>​	您可以使用rm命令 -i 选项以交互式提示确认后再删除。这基本上与使用rm命令-f选项相反，-f选项强制删除并且不提示用户进行确认。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rm</span> -ri Thesis/</span><br><span class="line"><span class="built_in">rm</span>: descend into directory <span class="string">&#x27;Thesis/&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/Chapter2&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/Chapter3&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/&#x27;</span>? y</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rm</span> -rf ProjecrX/</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>注意：如果同时使用-i和-f选项，-f选项将具有优先权，所以再rm删除文件之前，不会提示您进行确认。</code></p>
<p>​	您也可以使用rmdir命令来删除空目录。使用rm命令-r选项可删除非空目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dir1目录非空，dir2空目录，rmdir命令无法删除非空目录，rm -r可删除非空目录</span></span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> dir1/</span><br><span class="line">text1.txt</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> dir2</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rmdir</span> dir1/</span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;dir1/&#x27;</span>: Directory not empty</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rmdir</span> dir2/</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span></span><br><span class="line">dir1</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>



<h2 id="制作文件间的链接"><a href="#制作文件间的链接" class="headerlink" title="制作文件间的链接"></a>制作文件间的链接</h2><h3 id="管理文件间的链接"><a href="#管理文件间的链接" class="headerlink" title="管理文件间的链接"></a>管理文件间的链接</h3><p>​	您可以创建指向同一文件的多个文件名。这些文件名称为链接。</p>
<p>​	您可以创建的两种类型的链接：硬链接或符号链接（同时也称为软链接）。每种方法各有利弊。</p>
<h3 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h3><p>​	从初始名称到文件系统上的数据，每个文件都以一个硬链接开始。当创建指向文件的硬链接时，也会创建另一个指向同一数据的名称。新的硬链接与原始文件名的作用完全相同。创建之后，新的硬链接与文件的原始名称毫无二致。</p>
<p>​	您可以使用ls -l命令来确认文件是否具有多个硬链接。他报告的项目之一就是每个文件的链接数，即文件所具有的硬链接数。再下面的示例中，newfile.txt的链接数位1。它恰好有一个绝对路径，即&#x2F;home&#x2F;kiosk&#x2F;newfile.txt。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l newfile.txt </span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 6 Mar  5 16:47 newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	您可以使用ln命令来创建一个指向现有文件的硬链接（也就是指向该文件的另一个名称）。该命令至少需要两个参数：现有文件的路径，以及要创建的硬链接的路径。</p>
<p>​	以下示例将为现有文件newfile.txt，在&#x2F;tmp目录中创建一个名为newfile-hlink2.txt的硬链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> newfile.txt </span><br><span class="line">hahah</span><br><span class="line"><span class="comment"># 创建硬链接</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> newfile.txt /tmp/newfile-hlink2.txt</span><br><span class="line"><span class="comment"># 硬链接已生成</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l /tmp/newfile-hlink2.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk 6 Mar  5 16:47 /tmp/newfile-hlink2.txt</span><br><span class="line"><span class="comment"># 硬链接与原始文件具有相同的数据</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">hahah</span><br><span class="line"><span class="comment"># 修改原始文件内容的同时，硬链接的内容也同时随原文件更新</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> xixixi &gt; newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">xixixi</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	要确定两个文件是否被硬链接，请使用ls命令配合-i 选项列出每个文件索引节点编码。如果两个文件位于同一文件系统上，而且他们的索引节点编号相同，那么这两个文件就是指向同一数据的硬链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -li newfile.txt /tmp/newfile-hlink2.txt</span><br><span class="line">269337410 -rw-rw-r--. 2 kiosk kiosk 7 Mar  5 16:55 newfile.txt</span><br><span class="line">269337410 -rw-rw-r--. 2 kiosk kiosk 7 Mar  5 16:55 /tmp/newfile-hlink2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>重要：引用同一文件的硬链接具有相同的链接数、访问权限、用户和组所有权、时间戳，以及文件内容。当一个硬链接的内容发生更改，同一文件的其他硬链接也会显示更新后的新内容。这是因为每个硬链接都指向存储设备中的同一数据</code></p>
<p>​	即使原始文件被删除，只要还存在至少一个硬链接，该文件的内容就依然可用。只有最后一个硬链接被删除时，数据才会从存储中删除，从而使任何硬链接都不会引用该文件内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -rf newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -li /tmp/newfile-hlink2.txt </span><br><span class="line">269337410 -rw-rw-r--. 1 kiosk kiosk 7 Mar  5 16:55 /tmp/newfile-hlink2.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">xixixi</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h3 id="硬链接的局限性"><a href="#硬链接的局限性" class="headerlink" title="硬链接的局限性"></a>硬链接的局限性</h3><p>​	硬链接存在一些局限性。首先，您只能将硬链接用于常规文件。无法使用ln命令来创建指向目录或特殊文件的硬链接。</p>
<p>​	其次，只有当两个文件位于同一文件系统上时，您才能使用硬链接。文件系统层次结构可以由多个存储设备组成。当切换到新目录时，该目录及其内容可能会存储在不同的文件系统中，具体取决于您的系统配置。</p>
<p>​	您可用使用df命令来列出位于不同文件系统上的目录。例如，您可能会看到以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">df</span> </span><br><span class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">devtmpfs         8155384        0   8155384   0% /dev</span><br><span class="line">tmpfs            8175032        0   8175032   0% /dev/shm</span><br><span class="line">tmpfs            3270016    10264   3259752   1% /run</span><br><span class="line">/dev/nvme0n1p3 191037300 70391952 120645348  37% /</span><br><span class="line">/dev/loop2       7866562  7866562         0 100% /content/rhel9.0/x86_64/rhel8-additional</span><br><span class="line">/dev/loop1           456      456         0 100% /content/rhel9.0/x86_64/rhcsa-practice</span><br><span class="line">/dev/nvme0n1p1   2086912   971540   1115372  47% /boot</span><br><span class="line">/dev/loop0       8377364  8377364         0 100% /content/rhel9.0/x86_64/dvd</span><br><span class="line">tmpfs            1635004      104   1634900   1% /run/user/1000</span><br></pre></td></tr></table></figure>

<p>​	两个不同的目录及其子目录中的文件位于不同的文件系统上。因此，本示例中的系统而言，您可以在<code>/tmp/newfile-hlink2.txt</code>和<code>/home/kiosk/newfile.txt</code> 文件之间创建一个硬链接，因为它们都说 &#x2F; 目录的子目录，而不是列表中其他任何目录的子目录。但是您不能在<code>/boot</code>和<code>/home/kiosk/newfile.txt</code> 之间建立硬链接，因为第一个文件位于&#x2F;boot目录下的子目录并且在<code>/dev/nvme0n1p1</code>文件系统中，而第二个文件在<code>/dev/nvme0n1p3</code>文件系统中</p>
<h3 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><p>​	ln 命令 -s 选项可创建符号链接，也称为“软链接”。符号链接不是常规文件，而是指向现有文件或目录的特殊类型的文件。</p>
<p>​	符号链接相比硬链接有着一定的优势：</p>
<ul>
<li>符号链接可以链接位于不同文件系统上的两个文件。</li>
<li>符号链接可以指向目录或特殊文件，而不仅限于常规文件。</li>
</ul>
<p>​	在以下示例中，ln -s命令为&#x2F;home&#x2F;kiosk&#x2F;newfile.txt文件创建符号链接。符号链接在名称是&#x2F;tmp&#x2F;newfile-symlink.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> -s /home/kiosk/newfile.txt /tmp/newfile-symlink.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l newfile.txt /tmp/newfile-symlink.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk  6 Mar  5 17:46 newfile.txt</span><br><span class="line">lrwxrwxrwx. 1 kiosk kiosk 23 Mar  5 17:48 /tmp/newfile-symlink.txt -&gt; /home/kiosk/newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-symlink.txt</span><br><span class="line">hahah</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	在上面示例中，&#x2F;tmp&#x2F;newfile-symlink.txt文件的长列表的第一个字符是l（字母 l）而不是 - 。这个字符表示该文件是符号链接而非常规文件。</p>
<p>​	当原始常规文件被删除后，符号链接会指向原始文件，但目标已消失。指向缺少文件的符号链接称为“悬空符号链接”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -f newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l /tmp/newfile-symlink.txt </span><br><span class="line">lrwxrwxrwx. 1 kiosk kiosk 23 Mar  5 17:48 /tmp/newfile-symlink.txt -&gt; /home/kiosk/newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-symlink.txt</span><br><span class="line"><span class="built_in">cat</span>: /tmp/newfile-symlink.txt: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>重要：在上述示例中，悬空符号链接有个副作用，那就是：如果您稍后创建了一个与删除文件同名的新文件（/home/kiosk/newfile.txt），那么符号链接将不再“悬空”，而是指向这个新文件，硬链接的工作方式却不是这样的。如果您删除硬链接，然后使用常规工具（而不是ln）创建一个同名的文件，那么新文件将不会链接到旧文件，不妨通过以下方式比较硬链接和符号链接，以了解它们的工作原理：</code></p>
<ul>
<li><code>硬链接是将名称指向存储设备上的数据。</code></li>
<li><code>符号链接是将名称指向另一个名称，原文件指向存储设备上的数据。</code></li>
</ul>
<p>​	符合链接可以指向目录，而且，符号链接发挥目录一样的作用。如果使用cd进入到符合链接的目录，则当前工作目录将变为被链接的目录。有些工具可以跟踪您如何通过软链接到达这个目录的。例如，默认情况下，cd将使用符号链接的名称（而非实际的名称）来更新当前工作目录。如果要使用实际目录的名称更新当前工作目录，则可以使用 -P 选项。</p>
<p>​	以下示例将创建&#x2F;home&#x2F;kiosk&#x2F;configfiles的不好链接，它将指向&#x2F;etc目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> -s /etc/ /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 configfiles]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 configfiles]$ <span class="built_in">cd</span> -P /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 etc]$ <span class="built_in">pwd</span></span><br><span class="line">/etc</span><br><span class="line">[kiosk@foundation0 etc]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用shell扩展匹配文件名"><a href="#使用shell扩展匹配文件名" class="headerlink" title="使用shell扩展匹配文件名"></a>使用shell扩展匹配文件名</h2><h3 id="命令行扩展"><a href="#命令行扩展" class="headerlink" title="命令行扩展"></a>命令行扩展</h3><p>​	当您在Bash shell提示符中键入命令时，shell在运行该命令行之前通过多个扩展对其进行处理。您可以使用这些shell扩展来执行原本很难或不可能完成的复杂任务。</p>
<p>​	Bash执行的主要扩展有：</p>
<ul>
<li>大括号扩展，可以生成多个字符串。</li>
<li>波浪号扩展，扩展至用户主目录路径。</li>
<li>变量扩展，将文本替换为shell变量中存储的值。</li>
<li>命令替换，加ing文本替换为命令的输出。</li>
<li>路径名扩展，帮助按模式匹配选择一个或多个文件。</li>
</ul>
<p>​	路径名扩展也称为通配符，是Bash最有用的功能之一。使用此功能，可以更加轻松地管理多个文件。使用“扩展”的元字符来匹配要寻找的文件名和路径名，可以一次性针对集中的一组文件执行命令。</p>
<h3 id="路径名扩展和模式匹配"><a href="#路径名扩展和模式匹配" class="headerlink" title="路径名扩展和模式匹配"></a>路径名扩展和模式匹配</h3><p>​	路径名扩展将表示为通配符或字符类别的特殊字符模式扩展为该模式匹配的文件名列表。在shell运行您的命令之前，它会将模式替换为匹配的文件名列表。如果该模式与任何内容都不匹配，则shell将尝试使用该模式作为其运行命令的字面参数。下表列出了用于模式匹配的常见元字符和模式类型。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>由零个或跟多字符组成的任意字符串。</td>
</tr>
<tr>
<td>?</td>
<td>任何一个字符。</td>
</tr>
<tr>
<td>[abc…]</td>
<td>括起的类型（位于两个方括号之间）中的任何一个字符。</td>
</tr>
<tr>
<td>[!abc…]</td>
<td>不在括起的类型中的任意字符。</td>
</tr>
<tr>
<td>[^abc…]</td>
<td>不在括起的类型中的任意字符。</td>
</tr>
<tr>
<td>[[:alpha:]]</td>
<td>任何字母字符</td>
</tr>
<tr>
<td>[[:lower:]]</td>
<td>任何小写字符</td>
</tr>
<tr>
<td>[[:upper:]]</td>
<td>任何大写字符</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>任何字母字符或数字</td>
</tr>
<tr>
<td>[[:punct:]]</td>
<td>除空格和字母数字意外的任何可打印字符。</td>
</tr>
<tr>
<td>[[:digit:]]</td>
<td>从0到9的任何单个数字。</td>
</tr>
<tr>
<td>[[:space:]]</td>
<td>任何单个空格字符，可能包括制表符、换行符、回车符、换页符或空格。</td>
</tr>
</tbody></table>
<p>​	便于演示，以下命令创建一些示例文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">mkdir</span> glob; <span class="built_in">cd</span> glob</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> alpha bravo charlie dalta <span class="built_in">echo</span> able baker cast dog easy Able Aplha Cast 123</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">able  alpha  baker  bravo  cast  charlie  dalta  dog  easy  <span class="built_in">echo</span></span><br><span class="line">[kiosk@foundation0 glob]$</span><br></pre></td></tr></table></figure>

<p>​	以下示例中，前面两个命令通过星号（*）使用简单模式匹配，分别匹配以“a”开头的所有文件名和包含“a”的所有文件名。第三个命令使用星号和方括号匹配以“a”或“c”开头的所有文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> a*</span><br><span class="line">able  alpha</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> *a*</span><br><span class="line">able  alpha  baker  bravo  cast  charlie  dalta  easy</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> [ac]*</span><br><span class="line">able  alpha  cast  charlie</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	第一、二个命令，开头不包括“a”或“c”的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ ls [!ac]*</span><br><span class="line">baker  bravo  dalta  dog  easy  echo</span><br><span class="line">[kiosk@foundation0 glob]$ ls [^ac]*</span><br><span class="line">baker  bravo  dalta  dog  easy  echo</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	过滤出文件内任何字母字符的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">cat</span> able </span><br><span class="line">daf</span><br><span class="line">fasfa</span><br><span class="line">154512</span><br><span class="line"></span><br><span class="line">fadfa</span><br><span class="line"></span><br><span class="line">fa</span><br><span class="line">dggf</span><br><span class="line">gf</span><br><span class="line">fgd</span><br><span class="line">eq</span><br><span class="line">bnv</span><br><span class="line"></span><br><span class="line">cz</span><br><span class="line">rew</span><br><span class="line">vbc`:</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 glob]$ grep [[:alpha:]] able </span><br><span class="line">daf</span><br><span class="line">fasfa</span><br><span class="line">fadfa</span><br><span class="line">fa</span><br><span class="line">dggf</span><br><span class="line">gf</span><br><span class="line">fgd</span><br><span class="line">eq</span><br><span class="line">bnv</span><br><span class="line">cz</span><br><span class="line">rew</span><br><span class="line">vbc`:</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	以下示例中也可以使用问号 “？”来匹配其中的一些文件名，这两个命令分别仅匹配长度为四个和五个字符的文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> ????</span><br><span class="line">able  cast  easy  <span class="built_in">echo</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> ?????</span><br><span class="line">alpha  baker  bravo  dalta</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h3><p>​	大括号扩展用于生成任意字符串。大括号包含字符串的都好分割列表或顺序表达式。结果包含大括号定义之前或之后的文本。大括号扩展可以相互嵌套。您也可以使用双点语法（..），它将扩展为一个顺序序列。例如，大括号内的{a..d}双点语法扩展为 b c d。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> &#123;tmp,nginx,docker,kubelet&#125;.<span class="built_in">log</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">docker.log  kubelet.log  nginx.log  tmp.log</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> file&#123;a..c&#125;.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> file*</span><br><span class="line">filea.txt  fileb.txt  filec.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> file&#123;a..c&#125;&#123;1..3&#125;.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">filea1.txt  filea2.txt  filea3.txt  fileb1.txt  fileb2.txt  fileb3.txt  filec1.txt  filec2.txt  filec3.txt</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	可以通过大括号扩展的方式去快速创建多个文件或目录及查找等操作。</p>
<h3 id="波形符扩展"><a href="#波形符扩展" class="headerlink" title="波形符扩展"></a>波形符扩展</h3><p>​	波形符（<del>）可匹配当前用户的主目录。如果波形符后为斜杠（&#x2F;）以外的字符串，shell就会将波形符之后的字符串解释为用户名。如果存在匹配项，则用该用户的主目录绝对路径来替换字符串。如果找不到匹配的用户名，shell将使用实际波形符加上该字符串完整输出。如果您以（</del>&#x2F;）开头，shell就会将该解释为当前用户的主目录，在它之后的字符串就是当前用户主目录下的子目录。</p>
<p>​	一下示例中，echo命令用于显示波形字符最终输出的值。也可以使用echo命令来显示大括号和变量扩展字符等的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root的主目录绝对路径</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~root</span><br><span class="line">/root</span><br><span class="line"><span class="comment"># kiosk的主目录绝对路径</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~kiosk/</span><br><span class="line">/home/kiosk/</span><br><span class="line"><span class="comment"># ~/当前用户主目录，glob主目录下的子目录</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~/glob</span><br><span class="line">/home/kiosk/glob</span><br><span class="line"><span class="comment"># 匹配不到则将参数完整输出</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~ahahha</span><br><span class="line">~ahahha</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h3><p>​	变量的作用类似于可以在内存中存储值的命名容器。通过变量，可以从命令行或shell脚本内轻松访问和修改存储的数据。</p>
<p>​	您可以通过以下语法蒋数据作为值分配给变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ VARIABLENAME=value</span><br></pre></td></tr></table></figure>

<p>​	可以使用变量扩展蒋变量名转换为命令行上的值。如果字符串以美元符号（$）开头，那么shell就会尝试将该字符串的其余部分用作变量名称，并将它替换为变量中包含的任何值。也就是说美元符可以将它后面的字符串解释（标记）为这是一个变量，而非普通的字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个名为：USERNAME的变量，它的值为：Asimov</span></span><br><span class="line"><span class="comment"># 他们是一个键值对的关系</span></span><br><span class="line">[kiosk@foundation0 glob]$ USERNAME=Asimov</span><br><span class="line"><span class="comment"># $打入开头关键字同样也可以TAB为您补全上来</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="variable">$USER</span>      <span class="variable">$USERNAME</span>  </span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$USERNAME</span></span><br><span class="line">Asimov</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<p>​	为了预防您取的变量名于其他shell扩展名其冲突而引起错误，您可以将变量的名称放在大括号中，如：${VARIABLENAME}</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ USERNAME=LiWeiHu</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"><span class="variable">$&#123;USER&#125;</span>      <span class="variable">$&#123;USERNAME&#125;</span>  </span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$&#123;USERNAME&#125;</span></span><br><span class="line">LiWeiHu</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	变量名只能包含字母（大小写均可）、数字和下划线。变量名称区分大小写，不能以数字开头。</p>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>​	命令替换允许命令的输出替换命令行上的命令本身。当命令阔在括号中并且前面有美元符号（$）时，会发生命令替换。$(command) 形式可以互相嵌套多个命令扩展。</p>
<p>​	将date +%A这个原本的命令，用它输出的值去替换这个命令，去输出今天是星期几，于我们没带命令替换的普通字符串，形成一段完整的输出内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> Today is $(<span class="built_in">date</span> +%A)</span><br><span class="line">Today is Thursday</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> Today <span class="keyword">time</span> is  $(<span class="built_in">date</span> +%M) minutes past $(<span class="built_in">date</span> +%l%p).</span><br><span class="line">Today <span class="keyword">time</span> is 18 minutes past 4PM.</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="防止参数被扩展"><a href="#防止参数被扩展" class="headerlink" title="防止参数被扩展"></a>防止参数被扩展</h3><p>​	在Bash shell中，许多字符有着特殊含义。为防止命令行的某些部分上执行shell扩展，您可以为字符和字符串加引号或执行转义。</p>
<p>​	反斜杠（\）是bash shell中的转义字符。它可以防止其后的字符被扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未被转义时，$HOME将作为变量去输出key值</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/kiosk</span><br><span class="line"><span class="comment"># 通过转义符，$HOME它就是一个普通的字符串输出</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> \<span class="variable">$HOME</span></span><br><span class="line"><span class="variable">$HOME</span></span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	在上面的示例中，保护美元符免于扩展，bash将其视为常规字符，因此也就未在$HOME上执行变量扩展。</p>
<p>​	如果要保护较长的字符串，则使用单引号 （’）或双引号（”）来括起字符串。它们的作用略有不同。单引号将阻止所有shell扩展。双引号则阻止大部分shell扩展。</p>
<p>​	双引号可抑制美元符号（ $ ）、反斜杠（ \ ）、反引号（ &#96; ）和感叹号（ ! ）以外的特殊字符，在引用文本内发挥作用。这回阻止路径名扩展，但仍允许命令替换和变量扩展。</p>
<p>​	以下示例中，演示了双引号无法抑制变量扩展，依然会输出变量具有的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&quot;****** hostname is <span class="variable">$&#123;HOSTNAME&#125;</span> ********&quot;</span></span><br><span class="line">****** hostname is foundation0.ilt.example.com ********</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	使用单引号则可以按字面解释抑制引号内所有的特殊字符，以文本输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&#x27;****** hostname is $&#123;HOSTNAME&#125; ********&#x27;</span></span><br><span class="line">****** hostname is <span class="variable">$&#123;HOSTNAME&#125;</span> ********</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第三章节</title>
    <url>/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="在红帽企业Linux中获取帮助"><a href="#在红帽企业Linux中获取帮助" class="headerlink" title="在红帽企业Linux中获取帮助"></a>在红帽企业Linux中获取帮助</h1><h2 id="阅读手册页"><a href="#阅读手册页" class="headerlink" title="阅读手册页"></a>阅读手册页</h2><h3 id="Linux手册页简介"><a href="#Linux手册页简介" class="headerlink" title="Linux手册页简介"></a>Linux手册页简介</h3><p>​	本地系统上通常可用的文档来源之一是系统手册页或man page。软件包随附这些页面来提供文档，您可以使用man命令从命令行访问这些文档。页面存储在&#x2F;usr&#x2F;share&#x2F;man 目录的子目录中。</p>
<p>​	man page 源自过去的Linux程序员手册，该手册篇幅很长，足以划分多个章节。每个章节包含有特定主题信息。</p>
<table>
<thead>
<tr>
<th>章节</th>
<th>内容类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户命令</td>
<td>可执行命令和shell程序</td>
</tr>
<tr>
<td>2</td>
<td>系统调用</td>
<td>从用户空间调用的内核例程</td>
</tr>
<tr>
<td>3</td>
<td>库函数</td>
<td>有程序库提供</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件</td>
<td>例如设备文件</td>
</tr>
<tr>
<td>5</td>
<td>文件格式</td>
<td>用于许多配置文件和结构</td>
</tr>
<tr>
<td>6</td>
<td>游戏和屏保</td>
<td>过去的趣味程序章节</td>
</tr>
<tr>
<td>7</td>
<td>惯例、标准和其他</td>
<td>协议、文件系统</td>
</tr>
<tr>
<td>8</td>
<td>系统管理和特权命令</td>
<td>维护任务</td>
</tr>
<tr>
<td>9</td>
<td>Linux内核API</td>
<td>内部内核调用</td>
</tr>
</tbody></table>
<p>​	为区分不同章节中相同的主题名称，man page参考中在主题后附上章节编号（用括号括起）。例如：passwd(1)介绍更改密码的命令，而passwd(5)说明用于存储本地用户账户的&#x2F;etc&#x2F;passwd配置文件相关格式。</p>
<p>​	若要读取具体的man page，请使用man topic命令。man page一次显示一屏内容。man命令按照字母数字顺序搜索手册章节。例如：man passwd默认情况下只显示passwd(1)。要显示特定章节中的man page主题，您可以使用man section topic 命令。例如：man 5 passwd会显示passwd(5)。</p>
<p>​	常见的系统管理主题在第一章（用户命令）、第五章（文件格式）和第八章（管理命令）中。采用特定故障排除工具的管理员页可以使用第二章（系统调用）。剩余的章节供内核开发等人员参考或用于高级管理。</p>
<h3 id="阅览和搜索-Man-Page"><a href="#阅览和搜索-Man-Page" class="headerlink" title="阅览和搜索 Man Page"></a>阅览和搜索 Man Page</h3><p>​	高校的搜索主题并在man page中导航是一项非常重要的管理技能。您可以使用GUI管理goon根据来配置常见系统资源，但使用命令行界面依然更为高效。更有效的在命令行中找到所需man page信息。</p>
<p>​	下表列出在查看man page时基本的导航命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Spacebar（空格）</td>
<td>向前（向下）滚动一屏</td>
</tr>
<tr>
<td>PageDown（下键）</td>
<td>向前（向下）滚动一屏</td>
</tr>
<tr>
<td>Pageup（上键）</td>
<td>向后（向上）滚动一屏</td>
</tr>
<tr>
<td>D</td>
<td>向前（向下）滚动半屏</td>
</tr>
<tr>
<td>U</td>
<td>向后（向上）滚动半屏</td>
</tr>
<tr>
<td>&#x2F;string</td>
<td>在man page中搜索string内容</td>
</tr>
<tr>
<td>N</td>
<td>在man page中重复向前（向下）搜索</td>
</tr>
<tr>
<td>Shift+N</td>
<td>在man page中重复向后（向上）搜索</td>
</tr>
<tr>
<td>G</td>
<td>转到man page的开头</td>
</tr>
<tr>
<td>shift+G</td>
<td>转到man page的末尾</td>
</tr>
<tr>
<td>Q</td>
<td>退出man，并返回命令行</td>
</tr>
</tbody></table>
<h3 id="阅读Man-Page"><a href="#阅读Man-Page" class="headerlink" title="阅读Man Page"></a>阅读Man Page</h3><p>​	man page将各个主题划分为几个部分。大多数主题共享相同的标题，并以相同的顺序显示。通常，主题不包含所有标题，因为并非所有标题都使用所有主题。</p>
<p>​	常见的标题如下：</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>主题名称。通常是命令或文件名。简短的描述</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>命令语法概要</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>提供对主题的基本理解和描述</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>命令执行选项说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>有关如何使用命令、功能或文件的示例</td>
</tr>
<tr>
<td>FILES</td>
<td>与man page相关的文件和目录的列表。</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>相关的信息，通常是其他man page 主题。</td>
</tr>
<tr>
<td>BUGS</td>
<td>软件中已知错误。</td>
</tr>
<tr>
<td>AUTHOR</td>
<td>有关草鱼撰写该主题的人员信息。</td>
</tr>
</tbody></table>
<h3 id="根据关键字搜索man-page"><a href="#根据关键字搜索man-page" class="headerlink" title="根据关键字搜索man page"></a>根据关键字搜索man page</h3><p>​	使用man命令 -k（小写）选项（等同于apropos选项）可在man page的标题和描述中搜索关键字。关键字搜索的结果中显示与关键字匹配的man page 主题和章节编号列表。例如以下命令可搜索含词语passwd的man page。</p>
<p>​	<code>注意：关键字搜索依赖于mandb(8)命令生成的索引，该命令必须以root身份允许。在安装含有man page软件包是，man-db-cache-update访问会自动允许mandb命令，如果您通过man -k 无法搜索相应标题，则可能需要您手动执行一个mandb。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -k passwd</span><br><span class="line">chgpasswd (8)        - update group passwords <span class="keyword">in</span> batch mode</span><br><span class="line">chpasswd (8)         - update passwords <span class="keyword">in</span> batch mode</span><br><span class="line">fgetpwent_r (3)      - get passwd file entry reentrantly</span><br><span class="line">getpwent_r (3)       - get passwd file entry reentrantly</span><br><span class="line">gpasswd (1)          - administer /etc/group and /etc/gshadow</span><br><span class="line">grub2-mkpasswd-pbkdf2 (1) - Generate a PBKDF2 password <span class="built_in">hash</span>.</span><br><span class="line">htpasswd (1)         - Manage user files <span class="keyword">for</span> basic authentication</span><br><span class="line">lpasswd (1)          - Change group or user password</span><br><span class="line">openssl-passwd (1ossl) - compute password hashes</span><br><span class="line">pam_localuser (8)    - require <span class="built_in">users</span> to be listed <span class="keyword">in</span> /etc/passwd</span><br><span class="line">passwd (1)           - update user<span class="string">&#x27;s authentication tokens</span></span><br><span class="line"><span class="string">passwd (1ossl)       - OpenSSL application commands</span></span><br><span class="line"><span class="string">passwd (5)           - password file</span></span><br><span class="line"><span class="string">passwd2des (3)       - RFS password encryption</span></span><br><span class="line"><span class="string">pwhistory_helper (8) - Helper binary that transfers password hashes from passwd or shadow to opasswd</span></span><br><span class="line"><span class="string">saslpasswd2 (8)      - set a user&#x27;</span>s sasl password</span><br><span class="line">smbpasswd (5)        - The Samba encrypted password file</span><br><span class="line">vncpasswd (1)        - change the VNC password</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<p>​	man -K（大写）选项可在全文页面中搜索关键字，而补仅仅是在标题和描述中搜索。全文搜索使用更多的系统资源，耗费更长的时间。</p>
<p>​	使用全文页面搜索时，man 命令显示含有匹配项的第一页。按Q退出第一页，man命令则可显示下一页。</p>
<p>​	在本示例中，man显示每个匹配项，同时允许您查看或跳过每个匹配项。<code>man page页按Q退出，Ctrl+D（跳过该匹配项），Ctrl+c（退出匹配）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -K passwd</span><br><span class="line">--Man-- next: <span class="built_in">cut</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: <span class="built_in">logname</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: <span class="built_in">sort</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: xargs(1) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line">^C</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="模拟操作练习"><a href="#模拟操作练习" class="headerlink" title="模拟操作练习"></a>模拟操作练习</h2><p>​	请根据下列要求完成用户创建，以及用户密码修改</p>
<ul>
<li>查询su命令使用方法，将当前shell（kiosk）用户切换为root用户。</li>
<li>查询useradd命令使用方法，使用该命令创建一个名为redhat01的用户。</li>
<li>查询passwd命令使用方法，使用该命令为redhat01用户更新密码。</li>
</ul>
<h2 id="模拟练习讲解"><a href="#模拟练习讲解" class="headerlink" title="模拟练习讲解"></a>模拟练习讲解</h2><p>​	根据题目已知，我们首先要使用man page查询关于su命令的一个使用方法，并且使用su命令将我们从kiosk用户切换到root用户的shell提示符。</p>
<p>​	方式一：通过man -k 来查找su的page页，但这样会找出很多有关su的page页，在我们已知我们要查找su的用户命令时，不推荐使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ man -k su</span><br><span class="line">.....忽略.....</span><br><span class="line">strspn (3)           - get length of a prefix substring</span><br><span class="line">strspn (3p)          - get length of a substring</span><br><span class="line">strstr (3)           - locate a substring</span><br><span class="line">strstr (3p)          - find a substring</span><br><span class="line">su (1)               - run a <span class="built_in">command</span> with substitute user and group ID</span><br><span class="line">Sub::Exporter (3pm)  - a sophisticated exporter <span class="keyword">for</span> custom-</span><br><span class="line">.....忽略.....</span><br><span class="line">[kiosk@foundation0 ~]$ man 1 su</span><br></pre></td></tr></table></figure>



<p>​	方式二：已知我们要找su的用户命令，用户命令的编号是 (1)，就可以直接使用，man 1 su 或者 man su，man su在没有指定page编号时，默认是打开序号（1）的用户命令页。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ man su</span><br></pre></td></tr></table></figure>



<p>​	打开page页后，即可开始阅读su命令相关文档了。name命令的名称，synopsis命令使用的语法格式，description命令详细作用、功能描述，options命令可使用的选项即描述。可从他的语法格式中看出，该命令是试用【su [选项] [-] [用户名作为参数]】 ,方括号内表示选填项。</p>
<p><img src="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/image-20250520171558216.png" alt="image-20250520171558216"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ su - root</span><br><span class="line">Password: </span><br><span class="line">Last login: Fri Mar  7 17:46:32 CST 2025 on pts/0</span><br><span class="line">Last failed login: Mon Mar 10 14:34:10 CST 2025 on pts/0</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>



<p>​	成功切换到root后，继续查看useradd命令是如何使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man useradd</span><br><span class="line">[root@foundation0 ~]# useradd redhat01</span><br></pre></td></tr></table></figure>

<p>​	更新redhat01用的密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man passwd</span><br><span class="line">[root@foundation0 ~]# passwd redhat01 </span><br><span class="line">Changing password <span class="keyword">for</span> user redhat01.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	您可以使用man命令-t选项，将你man page写入到你的文档文件中，并使用file命令验证识别文件类型为document文档。例如下方示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -t passwd &gt; passwd.ps</span><br><span class="line">[root@foundation0 ~]# file passwd.ps </span><br><span class="line">passwd.ps: PostScript document text conforming DSC level 3.0</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	最后您可以通过evince命令，调用操作系统的文档工具打开该文档进行可视化阅览。</p>
<p><img src="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/image-20250520171622522.png" alt="image-20250520171622522"></p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第一章节</title>
    <url>/2025/02/27/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="红帽企业Linux入门"><a href="#红帽企业Linux入门" class="headerlink" title="红帽企业Linux入门"></a>红帽企业Linux入门</h1><h2 id="为什么要了解Linux？"><a href="#为什么要了解Linux？" class="headerlink" title="为什么要了解Linux？"></a>为什么要了解Linux？</h2><p>​	Linux是IT专业人士必须了解的关键技术。</p>
<p>​	Linux目前在全球范围得到广泛的使用。互联网上的用户每天通过万维网浏览各式各样的网页，例如此刻您正在通过互联网访问我的博客网站，与Linux应用和Web服务器系统进行交互。</p>
<p>​	在现代互联网时代，Linux和Windows是主要的操作系统。随着Linux广泛在企业、云等领域的采用，您有许多理由学习Linux</p>
<ul>
<li>Windows用户需要与Linux上托管的服务进行交互。</li>
<li>应用开发中，Linux常托管应用及运行。</li>
<li>云计算中，私有云或公有云实例都在使用Linux作为操作系统</li>
<li>移动应用及移动设备等通常都运行在Linux上</li>
</ul>
<h3 id="Linux的优点"><a href="#Linux的优点" class="headerlink" title="Linux的优点"></a>Linux的优点</h3><ul>
<li><p>Linux是开源软件</p>
<ul>
<li>开源意味着免费，您可以彻底了解程序或系统的工作方式，并且可以对其进行更改，并将他分享给他人使用，从而加快创新速度。</li>
</ul>
</li>
<li><p>Linux提供命令行（CLI），不仅访问便捷，并且具有强大的脚本化功能。</p>
<ul>
<li>Linux构建时的设计理念是用户可以通过CLI执行所有管理任务。它能够轻松实现自动化、部署和配置，并简化本地和远程系统的管理，从而实现易用性和稳定性。</li>
</ul>
</li>
<li><p>Linux是一种模块化的操作系统，管理员可以轻松替换或删除组件</p>
<ul>
<li>需要时，可以对系统组件进行升级和更新，Linux是一个通用开发工作站，也可以是特意精简化的软件设备</li>
</ul>
</li>
</ul>
<h3 id="RedHat是谁？"><a href="#RedHat是谁？" class="headerlink" title="RedHat是谁？"></a>RedHat是谁？</h3><p>​	RedHat翻译过来就是红色的帽子，同时它的LoGo也是一顶红色的帽子，在国内统称为红帽。</p>
<p>​	红帽是目前世界领先的开源软件解决方案供应商，使用社区驱动的方式提供可靠和高性能的云、Linux、中间件、存储和虚拟化技术。</p>
<h3 id="什么是Linux发行版"><a href="#什么是Linux发行版" class="headerlink" title="什么是Linux发行版"></a>什么是Linux发行版</h3><p>​	Linux发行版是有一种可安装的操作系统，由Linux内核以及提供支持的用户程序和库构建而成。完整的Linux系统又多个独立的开发社区开发，这些社区协同处理各个组件。发行版让用户能够轻松安装和管理正常运行的Linux系统。</p>
<p>​	1991年，名为Linus Torvalds的人开发了Unix内核，将其命名为Linux，作为开源软件进行授权。内核是操作系统的核心，它管理着硬件、内存以及运行中的程序调度。Linux内核可通过其他开源软件加以补充，如来自GNU项目的实用工具和程序、来自MIT的X window Systen的图形界面或Apache HTTP Web服务器等其他开源组件，以构建成一个完整、开源的类Unix操作系统</p>
<h2 id="访问命令行"><a href="#访问命令行" class="headerlink" title="访问命令行"></a>访问命令行</h2><h3 id="Bash-Shell简介"><a href="#Bash-Shell简介" class="headerlink" title="Bash Shell简介"></a>Bash Shell简介</h3><p>​		命令行是基于文本的界面，可用于向计算机系统输入指令。Linux命令行由名为Shell的程序提供。</p>
<p>​		红帽 Linux中为用户提供的默认shell是GNU Bourne-Again Shell简称(bash)。bash shell是UNIX系统上原始 Bourne shell简称(sh)的改进版本。</p>
<p>​		Shell在等待用户输入时会显示有一个字符串，称为Shell提示符。当普通用户启用Shell时，提示符为（$）美元符结尾的字符。kiosk则为当前所使用的用户名，foundation0则为当前您操作的主机名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​		如果以超级用户root运行Shell，则美元符则会被替换为（#）井号字符。次字符表明当前是在超级用户下进行操作Shell，有助于避免权限过大导致的误操作，从而影响到整个系统的异常破坏。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<p>​		bash命令是非常强大的。bash shell提供了脚本语言，可支持自动化任务。同时shell还可以实现图形化工具难以规模化完成的操作。</p>
<h3 id="Shell基础知识"><a href="#Shell基础知识" class="headerlink" title="Shell基础知识"></a>Shell基础知识</h3><p>在shell提示符下输入的命令需要由三个基本部分组成：</p>
<ul>
<li>要运行的命令</li>
<li>用于命令的行为选项</li>
<li>通常作为命令的目标参数</li>
</ul>
<p>命令是也要运行的程序名称。其后可能跟着一个或多个选项，用于表示该命令的行为或作用。选项通常以一个或两个破折号开头（例如：-a或 –all），有一个破折号代表选项简写，两个代表选项全称。命令和后面可能会跟着一个或多个参数，这些参数通常用于指明应在其中运行命令的目标。</p>
<p>例如：usermod -L user01，usermod是命令，-L是选项，而user01则是参数。此命令用于锁定user01用户账号的密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# usermod -L user01</span><br></pre></td></tr></table></figure>



<h3 id="登录远程系统"><a href="#登录远程系统" class="headerlink" title="登录远程系统"></a>登录远程系统</h3><p>​		Linux与用户和管理员通常需要通过网络连接到远程系统来获得对远程系统的shell访问权限。</p>
<p>​		在Linux中，获取远程系统上的shell提示符最常用的方式是使用Secure Shell（SSH）。大多数Linux系统都会默认提供SSH的命令行程序来满足这样一用途需求。</p>
<p>​		在以下示例中，在计算机上的shell提示符中使用sshmingl以student用户身份远程登录Linux系统名为servera的主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@workstation ~]$ ssh servera@student</span><br><span class="line">The authenticity of host <span class="string">&#x27;servera (172.25.250.10)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ED25519 key fingerprint is SHA256:peUGgfxFNw6Jt6WK4CB2rs+jql1/LhA32M1+8zBawLI.</span></span><br><span class="line"><span class="string">This key is not known by any other names</span></span><br><span class="line"><span class="string"># 验证指纹</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>servera<span class="string">&#x27; (ED25519) to the list of known hosts.</span></span><br><span class="line"><span class="string">student@servera&#x27;</span>s password:  <span class="comment"># 输入远程服务器的student用户密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		ssh命令通过加密连接来防止同学被窃听或截获密码和内容。</p>
<p>​		在一些场景中，不允许ssh使用密码进行登录，以加强安全性，在不输入密码的情况下对远程计算机进行身份验证的另一种方式是利用公元幺身份验证。</p>
<p>​		使用这种身份验证时，用户需要拥有内含私钥的的特殊身份文件，这相当于与用户的加密密码。在远程服务器上的账户配置有匹配的公钥，公钥不是保密的。在登录时，用户可以指定ssh私钥，如果该远程服务器上的对应账户中安装了他们的匹配公钥就会在不询问密码的情况下让用户登录</p>
<p>​		以下示例中，计算机使用shell提示符的用户通过ssh使用公钥身份验证的方式以student用户身份登录servera主机。ssh是命令，-i选项可用于只用你当前主机的私钥文件，即.ssh&#x2F;lab_rsa。当该私钥用于远程主机servera下的student用户所拥有的公钥相互匹配，则无需密码，可直接登录到servera的shell提示符中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@workstation ~]$ ssh -i .ssh/lab_rsa servera</span><br><span class="line">Activate the web console with: systemctl <span class="built_in">enable</span> --now cockpit.socket</span><br><span class="line"></span><br><span class="line">Register this system with Red Hat Insights: insights-client --register</span><br><span class="line">Create an account or view all your systems at https://red.ht/insights-dashboard</span><br><span class="line">Last login: Wed Feb 26 05:09:03 2025 from 172.25.250.9</span><br><span class="line">[student@servera ~]$ </span><br></pre></td></tr></table></figure>



<p>​		为保证连接正常，只有拥有该私钥文件的用户才能读取私钥文件。在上述示例中，私钥位于.ssh&#x2F;lab_rsa文件中，可以使用chmod 600 .ssh&#x2F;lab_rsa来确保只有其所有者才能够读取该文件。后面的文章将会详细讨论如何设置文件权限。</p>
<p>​		此外，用户还可能配置了无需指定私钥的方式，省略上述示例中 -i 指定私钥的操作，在后续章节也会陆续详细讨论。</p>
<h3 id="从远程系统中注销退出"><a href="#从远程系统中注销退出" class="headerlink" title="从远程系统中注销退出"></a>从远程系统中注销退出</h3><p>​	当您对ssh远程主机的操作完成后，想退出远程主机的shell时，可以悬着以下方式来结束本次远程会话。</p>
<ul>
<li>快捷键：Ctrl+D来结束会话</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@servera ~]$ </span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to servera closed.</span><br><span class="line">[student@workstation ~]$</span><br></pre></td></tr></table></figure>

<ul>
<li>命令行：exit</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@servera ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to servera closed.</span><br><span class="line">[student@workstation ~]$ </span><br></pre></td></tr></table></figure>





<h2 id="使用Bash-Shell执行命令"><a href="#使用Bash-Shell执行命令" class="headerlink" title="使用Bash Shell执行命令"></a>使用Bash Shell执行命令</h2><h3 id="基本命令语法"><a href="#基本命令语法" class="headerlink" title="基本命令语法"></a>基本命令语法</h3><p>​	GNU Bourne-Again Shell（bash）这个程序可以理解为用户输入的命令窗口。输入到shell中的每一个字符串最多有三个部分：命令、选项（通常以-或–开头）、参数。输入到Shell中的每个单词通过空格与其他单次间隔开。命令则是系统中安装的程序名称。每个命令都具有自己的选项和参数。</p>
<p>​	在单独的行上输入每个命令。系统会显示命令的输出结果，然后显示下一行shell提示符。此命令是输出当前使用的用户名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">whoami</span> </span><br><span class="line">kiosk</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​	如果要在一行shell提示符中输入多个命令，则可以使用分号进行分割（;）。分号是一类成为元字符的字符成员，对于bash具有特殊的解读作用。这时系统会分别执行你输入的多个命令，并分别显示多个命令的输出结果，最后显示下一行shell提示符。</p>
<p>​	whoami为第一个命令，（;）分号分割，hostname为第二个命令，作用输输出当前主机名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">whoami</span> ; hostname</span><br><span class="line">kiosk</span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="编写简单命令"><a href="#编写简单命令" class="headerlink" title="编写简单命令"></a>编写简单命令</h3><p>​	date命令可显示当前的日期和时间。超级用户或者特权用户也可以使用date来设置系统时钟。使用（+）号作为参数，指定日期命令的格式字符串。</p>
<p>​	下列示例分别使用date命令显示当前时间，以及date加参数+%R指定输出格式，只输出时、分。以及+%x显示年月日。+%Y-%m-%d:%H-%M-%S则是按照你给出的参数分别自定义日期输出格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span></span><br><span class="line">Thu Feb 27 10:48:35 AM CST 2025</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%R</span><br><span class="line">10:48</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%x</span><br><span class="line">02/27/2025</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%Y-%m-%d:%H-%M-%S</span><br><span class="line">2025-02-27:10-49-03</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	不带选项的passwd命令将更改当前用户的密码。若要更改密码，请先指定账户原始密码（当前密码）。默认情况passwd命令配置为需要强密码，其包含小写字母、大写字母、数字呵呵字符，并且不以字典中的标准单词为基础。超级用户或者特权用户可以使用passwd命令更改其他用户的密码。</p>
<p>​	输入当前密码以及新密码时，你的输入不会在shell窗口显示，所以修改避免输入错误，建议在外部将密码粘贴进来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># Rey@183dv</span></span><br><span class="line">Retype new password: <span class="comment"># Rey@183dv</span></span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​	如果输入的密码安全级别过低，是无法正常进行修改的，例如下方示例：</p>
<p>​		1、输入的密码少于8为字符，修改失败</p>
<p>​		2、密码存在于标准字典中，安全级别过低，修改失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># redhat1</span></span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">passwd: Authentication token manipulation error</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># 1q2w3e4r</span></span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word</span><br><span class="line">passwd: Authentication token manipulation error</span><br></pre></td></tr></table></figure>



<p>​	Linux中不需要文件扩展名来区分文件类型。file命令扫描文件的已编译标头中的2位数字magic number，并显示其类型。文本文件可被识别，因为它们没有经过编译。</p>
<p>​	如下示例，分别查看了三个文件的类型，第一个为txt文本类型，第二个可执行文件，第三个为文件夹（目录）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line">[kiosk@foundation0 ~]$ file /bin/passwd </span><br><span class="line">/bin/passwd: setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a467cb9c8fa7306d41b96a820b0178f3a9c66055, <span class="keyword">for</span> GNU/Linux 3.2.0, stripped</span><br><span class="line">[kiosk@foundation0 ~]$ file /home/</span><br><span class="line">/home/: directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	magic number是什么，可以理解为你的文本文件里面的内容，它是的编码格式是什么，然后file命令就会根据你文本内容的前两个数值去分辨你当前的文件属于什么类型</p>
<p>​	例如，我当前的ssh.sh里面是一些字符串，我的fiel命令解释改文本属于txt文本类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> ssh.sh </span><br><span class="line">afadsad</span><br><span class="line">[kiosk@foundation0 ~]$ file ssh.sh </span><br><span class="line">ssh.sh: ASCII text</span><br></pre></td></tr></table></figure>

<p>​	那么我对改文本的内容进行修改，修改为了标准的shell脚本格式，此时fiile命令就会解释该文本是一个可执行文件，类似于Windows的.exe文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> ssh.sh </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">[kiosk@foundation0 ~]$ file ssh.sh </span><br><span class="line">ssh.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<h3 id="查看文件的内容"><a href="#查看文件的内容" class="headerlink" title="查看文件的内容"></a>查看文件的内容</h3><p>​	Linux中最简单最常用的命令是cat命令。通过这个命令您可以创建单个或多个文件以及查看文件内容，串联不同文件中的内容，以及文件内容重定向到终端或文件内。</p>
<p>​	以下示例演示如何查看&#x2F;etc&#x2F;passwd文件的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">......省略......</span><br></pre></td></tr></table></figure>



<p>​	如果要显示多个文件的内容，请再cat命令后将文件名作为参数进行传入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 ~]$ <span class="built_in">cat</span> file1 file2 </span><br><span class="line">HHA</span><br><span class="line">XIXIXI</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	如果一些文件内容较长，可能比shell终端提供的显示空间还要多很多，cat命令不会将文件的内容显示为多个页面。这时您可以使用less命令一次显示文件的一个页面，然后通过鼠标滚轮或键盘的上下键来进行翻页查看，键盘按q退出查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ less file1 </span><br></pre></td></tr></table></figure>



<p>​	head和tail命令分别显示文件的开头和结尾部分。默认情况下这两个命令显示文件的开头10行或结尾10行，但您可以通过它的选项-n 来指定一次显示自定义行数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">head</span> -n 2 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">tail</span> -n 5 /etc/passwd</span><br><span class="line">systemd-oom:x:977:977:systemd Userspace OOM Killer:/:/usr/sbin/nologin</span><br><span class="line">kiosk:x:1000:1000::/home/kiosk:/bin/bash</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">named:x:25:25:Named:/var/named:/sbin/nologin</span><br><span class="line">dhcpd:x:177:177:DHCP server:/:/sbin/nologin</span><br></pre></td></tr></table></figure>



<p>​	wc命令可计算文件中的行、字和字符数量。使用-l、-w或-c选项，分别可以仅显示行数、字数或字符数</p>
<p>​	以下示例中，我们可以看到file1文件中有一行数据，Ha Xi分别两个字数，以及加上他俩中间的空格分割符，共5个字符。分别对应上wc输出的1、2、6。这时你可能会有疑问，该文件里我怎么数都是5个字母，怎么会统计出6个字符数呢？</p>
<p>​	那是因为wc也是通过类似cat这样的命令去先去输出了文本里的内容，然后进行统计的，cat这样输出的内容会自带一个换行符，所以我们肉眼是看不出来的，但是换行符实际是存在的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> file1 </span><br><span class="line">Ha Xi</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">wc</span> file1 </span><br><span class="line">1 2 6 file1</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	如果您想把这个换行符去掉，可以使用如下命令，其中|符号，称为管道符，作用是将它前面命令的输出结果，传递到后面的命令中去使用，tr -d ‘\n’则表示删除换行符。这些目前在后面的章节会陆续进行详细讨论，目前知道我们wc时，所统计的字符数为什么会多一个的原理即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ cat file1 | tr -d &#x27;\n&#x27; | wc </span><br><span class="line">      0       2       5</span><br></pre></td></tr></table></figure>



<h3 id="了解Tab补全"><a href="#了解Tab补全" class="headerlink" title="了解Tab补全"></a>了解Tab补全</h3><p>​	通过之后的学习，我们将会遇到许多命令，包括一些命令、选项、参数等很多很长，做为人很难全部一个字符都不差的记住，这时就得用上我们的Tab补全功能，这对我们记命令、找命令的帮助是很大的，它可以帮助你快速的找到你想找的命令。</p>
<p>​	例如：我们要修改密码，但是我只知道它是pa开头的，后面的字母我记不清了，那么我们则可以通过输入pa，随后快速按两下键盘上的Tab键，他会在你主机的众多软件命令中找关于pa开头的命令，如果你主机众多软件里只有一个pa开头的，那么直接会给你把后面的字母全部自动补充上来，如果存在多个，则它会将pa开头的命令列出来，您则可以根据你的记忆去寻找相似的，勾起你粉红色的回忆。</p>
<p>​	此时，它会列出pa开头的相关命令，然后我们就在里面找，找了一圈发现，我的回忆勾起来一些了，好像是pas后面的我又记不起来了，那么我就继续pas加TAB，缩小范围，这是选择的范围就小了，目前只出现三个pas相关的了，我一看到passwd的单词就是密码的意思，我的回忆被完全勾起来了，那就再pas的基础上再加上s，pass+TAB+TAB，再主机命令中唯一了，剩下的wd就自动给补充到shell提示符中了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ pa <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">pacat                 pam_timestamp_check   parted</span><br><span class="line">pack200               pango-list            partprobe</span><br><span class="line">packer                pango-segmentation    partx</span><br><span class="line">pacmd                 pango-view            passwd</span><br><span class="line">pactl                 paperconf             <span class="built_in">paste</span></span><br><span class="line">page_owner_sort       paperconfig           pasuspender</span><br><span class="line">pam_console_apply     paplay                patch</span><br><span class="line">pam_namespace_helper  parec                 <span class="built_in">pathchk</span></span><br><span class="line">pamon                 parecord              pax11publish</span><br><span class="line">[kiosk@foundation0 ~]$ pas  <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">passwd       <span class="built_in">paste</span>        pasuspender  </span><br><span class="line">[kiosk@foundation0 ~]$ pass <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">[kiosk@foundation0 ~]$ passwd <span class="comment"># pass唯一了，则剩下的全部字符都自动补充上来了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	相同，每个命令的选项很多我们也是可以通过Tab的方式查找补充，TAB功能很强大，强烈建于不管现在还是工作中尽量都使用Tab进行命令、选项、参数的补充，这样可以减少我们手动输入导致的很多执行错误的问题。</p>
<p>​	我们输入命令后，选项是由一个或多个减号（-）组成的，所以我们打上一个或两个减号，在按两下tab，则可以列出该命令的全部选项，同样也支持–g这样的模糊搜索示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ useradd --  <span class="comment"># 列出useradd所有的选项</span></span><br><span class="line">--badnames              --<span class="built_in">help</span>                  --prefix</span><br><span class="line">--base-dir              --home-dir              --root</span><br><span class="line">--btrfs-subvolume-home  --inactive              --selinux-user</span><br><span class="line">--comment               --key                   --shell</span><br><span class="line">--create-home           --no-create-home        --skel</span><br><span class="line">--defaults              --no-log-init           --system</span><br><span class="line">--expiredate            --non-unique            --uid</span><br><span class="line">--gid                   --no-user-group         --user-group</span><br><span class="line">--<span class="built_in">groups</span>                --password              </span><br><span class="line">[kiosk@foundation0 ~]$ useradd --g  <span class="comment"># 列出useradd --g开头选项</span></span><br><span class="line">--gid     --<span class="built_in">groups</span>  </span><br><span class="line">[kiosk@foundation0 ~]$ useradd --g</span><br></pre></td></tr></table></figure>



<h3 id="在Shell上编辑多行长命令"><a href="#在Shell上编辑多行长命令" class="headerlink" title="在Shell上编辑多行长命令"></a>在Shell上编辑多行长命令</h3><p>​	在以后的学习及工作中，我们可能会遇到命令+多个选项、参数组成的一个很长的执行命令，在一行Shell提示符中无法一次展示，且阅读性很差。这时我们可以选择将该命令分成多行来书写，我们直接回车换行，回车的含义（作用）是执行，这样我们的命令就直接被执行，无法达到换行书写的效果。</p>
<p>​	这时我们可以通过反斜杠（\）也称为转义符，它在Linux中的作用是忽略后续字符的含义，所有我们在需要换行书写的结尾接上反斜杠（\）我们的回车执行的含义就会被忽略，也就达到了换行书写的效果。</p>
<p>​	以下示例中，head -n 3表示查询文件内容的头3行，通过反斜杠（\）将我们之后要回车执行的含义给忽略掉，这样我们的命令行就切换到了下一行，我们接着写了两个路径较长的文件，查看这两个文件的内容，当我们要执行的时候最后一行不加反斜杠（\）则就是回车原本在Linux中的含义（执行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">head</span> -n 3 \</span><br><span class="line">&gt; /usr/share/dict/words \</span><br><span class="line">&gt; /usr/share/dict/linux.words </span><br><span class="line"><span class="comment"># 以下是head查询出来的文件内容输出</span></span><br><span class="line">==&gt; /usr/share/dict/words &lt;==</span><br><span class="line">1080</span><br><span class="line">10-point</span><br><span class="line">10th</span><br><span class="line"></span><br><span class="line">==&gt; /usr/share/dict/linux.words &lt;==</span><br><span class="line">1080</span><br><span class="line">10-point</span><br><span class="line">10th</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>





<h3 id="显示命令历史记录"><a href="#显示命令历史记录" class="headerlink" title="显示命令历史记录"></a>显示命令历史记录</h3><p>​	在学习和工作中我们可能会遇到重复的命令需要重复用到的情况，但是又不想老是重复输入较长的命令，以及我想看看我之前都执行了哪些命令等情况。这时我们就可能需要用到历史命令记录功能，方法又两种可以查看到我们的历史命令。</p>
<ul>
<li><p>​	方法一：在shell提示符中，使用键盘中的 <code>↑</code>【PgUp】或 <code>↓</code>【PgDn】，上下箭头来翻页查找之前输入过的命令。</p>
</li>
<li><p>方法二：通过history命令，可以将您输入的命令以结果输出的方式展示出来，并且带有每条命令的number序号</p>
<p>我们通过history查看到历史命令后，我们还可以通过<code>!String</code>命令或<code>!number</code>序号，去直接执行最近或指定的命令。</p>
<p><code>!String</code>命令是执行你最近一次执行过的类似命令。</p>
<p>​	例如：<code>!ls</code>，则是执行您最近一次执行过的 <code>!ls</code> 的命令。</p>
<p><code>!number </code>则是根据你history命令查询出来的每条命令的序号指定执行。</p>
<p>​	例如：<code>!46</code>则是执行你history结果中的序号46的命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 ~]$ <span class="built_in">history</span> </span><br><span class="line">  ...忽略...</span><br><span class="line">   46  <span class="built_in">date</span>+%x</span><br><span class="line">   47  <span class="built_in">date</span> +%x</span><br><span class="line">   48  <span class="built_in">date</span> +%Y-%m-%d:%H-%M-%S</span><br><span class="line">   49  passwd </span><br><span class="line">   50  ll</span><br><span class="line">   51  file History-7.x.txt </span><br><span class="line">   52  file Foundation-20221114.tgz </span><br><span class="line">   53  <span class="built_in">ls</span> -a</span><br><span class="line">   54  <span class="built_in">ls</span> -la</span><br><span class="line">   55  <span class="built_in">ls</span> -n</span><br><span class="line">   56  file Foundation-20221114.tgz</span><br><span class="line">  ...忽略...</span><br><span class="line">  [kiosk@foundation0 home]$ !<span class="built_in">ls</span>  </span><br><span class="line"><span class="built_in">ls</span> -n  <span class="comment"># 我最近执行的ls命令是ls -n</span></span><br><span class="line">total 4</span><br><span class="line">drwx------. 18 1000 1000 4096 Feb 27 15:08 kiosk</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 home]$ !47</span><br><span class="line"><span class="built_in">date</span> +%x  <span class="comment"># 我的序号47是date +%x的命令</span></span><br><span class="line">02/27/2025</span><br><span class="line">[kiosk@foundation0 home]$</span><br></pre></td></tr></table></figure>



<h3 id="编辑命令行"><a href="#编辑命令行" class="headerlink" title="编辑命令行"></a>编辑命令行</h3><p>​	以交互方式使用时，bash具有命令行编辑功能。使用文本编辑器命令在当前输入的命令内移动并且进行修改，使用箭头键可以在当前命令内移动，也可以访问历史命令，在本章的界面部分以及做了介绍。下列表格中将介绍更强大的编辑命令方式，学会它可以帮助您在编辑命令时更加游刃有余，编辑命令更加娴熟、迅速。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+A</td>
<td>光标跳到命令行开头</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标跳到命令行末尾</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>将光标处到命令行开头的内容删除</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>将给光标处到命令行末尾内容删除</td>
</tr>
<tr>
<td>Ctrl+LeftArrow（<code>←</code>）</td>
<td>以当前光标为起点跳到命令行前一个字的开头</td>
</tr>
<tr>
<td>Ctrl+RightArrow（<code>→</code>）</td>
<td>以当前光标为起点跳到命令行后一个字的末尾</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>在历史命令记录列表中搜索模糊搜索历史命令</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除光标前的一个字</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第六章节</title>
    <url>/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="第六章-控制对文件的访问"><a href="#第六章-控制对文件的访问" class="headerlink" title="第六章-控制对文件的访问"></a>第六章-控制对文件的访问</h1><h2 id="解释Linux文件系统权限"><a href="#解释Linux文件系统权限" class="headerlink" title="解释Linux文件系统权限"></a>解释Linux文件系统权限</h2><h3 id="Linux文件系统权限"><a href="#Linux文件系统权限" class="headerlink" title="Linux文件系统权限"></a>Linux文件系统权限</h3><p>​	文件权限控制对文件的访问。Linux文件权限简单又灵活，能够应对大多数的常见权限情况。</p>
<p>​	文件具有三个应用权限的用户类别。文件归某个用户所有，通常是文件的创建者。文件还归单个组所有，通常是创建改文件的用户的主要组，但是可以进行更改。</p>
<p>​	您可以为所属用户（用户权限）、所属组（组权限），以及系统上非用户和非所属组成员的所有其他用户（其他权限）设置不通过的权限。</p>
<p>​	最具体的权限具有优先权。用户权限覆盖组权限，后者有覆盖其他权限。</p>
<p>​	举例说明成员资格如何促进用户之间协作。假设您的系统有两个用户：alice和bob。alice是alice和web组的成员，bob是bob、wheel和web组的成员。当alice和bob协作时，文件应当与web组关联，并且组权限应当允许这两个用户访问这些文件。</p>
<p>​	有三种权限类别可应用：读取、写入和执行。下表说明了这些权限如何影响文件和目录的访问。</p>
<p><em><strong>权限对文件和目录的影响</strong></em></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可以读取该文件的内容</td>
<td>可以列出该目录下内容（文件名）</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可以更改文件的内容</td>
<td>可以创建或删除目录中的任意文件</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可以作为命令执行文件</td>
<td>目录可以成为当前工作目录。您可以允许cd进入这个目录，但还需要读取权限才能列出里面的文件。</td>
</tr>
</tbody></table>
<p>​	用户通常对只读目录具有读取和执行权限，因此他们可以进入该目录并列出该目录的内容。如果用户对目录仅具有读取访问权限，则可以列出其中文件的名称。但是，用户无法访问其他信息，如权限或时间戳。如果用户对目录具有仅执行权限，则无法列出目录中的文件名。如果他们知道自己有读取权限的文件名称，可以通过制定相对文件名称，从目录外访问该文件的内容。</p>
<p>​	对目录拥有所有权或写入权限的任何人都可以删除其中的文件，不论文件的所有权或权限如何。您可以使用粘滞位权限覆盖此行为，稍后讨论。</p>
<p>​	<code>注意：Linux文件权限的工作方式与Microsoft NTFS文件系统权限不同。在Linux上，权限仅适用于设置它们的文件或目录。目录内的子目录不会自动集成父目录的权限。但是，目录权限是可以阻止访问该目录的内容，具体取决于它们的限制程度。</code></p>
<h3 id="查看文件和目录的权限及所有权"><a href="#查看文件和目录的权限及所有权" class="headerlink" title="查看文件和目录的权限及所有权"></a>查看文件和目录的权限及所有权</h3><p>​	ls命令和-l选项可以显示有关权限和所有权的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 ~]$ <span class="built_in">ls</span> -l <span class="built_in">test</span> </span><br><span class="line">-rw-r--r--. 1 redhat01 redhat01 0 May 20 17:51 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>​	使用ls命令和-d选项可显示有关目录本身（而非其内容）的详细信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 ~]$ <span class="built_in">ls</span> -ld /home</span><br><span class="line">drwxr-xr-x. 6 root root 63 May 20 14:49 /home</span><br></pre></td></tr></table></figure>

<p>​	长列表的第一个字符表示文件类型，具体解释如下：</p>
<ul>
<li>-：是常规文件</li>
<li>d：是目录</li>
<li>l：是符号链接</li>
<li>c：是字符设备文件</li>
<li>b：是块设备文件</li>
<li>p：是命名管道文件</li>
<li>s：是本地套接字</li>
</ul>
<p>​	接下来九个字符表示文件权限。这些字符解释为三组，每组三个字符：第一组是适用于文件所有者的权限，第二组适用于文件的组所有者，最后一组则适用于其他所有（全局）用户。如果一组内是rwx，说明该组具有读取、写入和执行全部三种权限。如果一组的一个字母被替换为-，则表示改组没有这个权限。</p>
<p>​	在第一个示例中，用户redhat01的权限由第一组三个字符指定。redhat01用户对test文件具有读取和写入权限。第二组三个字符是redhat01组的权限；对test具有读取权限。第三组三个字符是所有其他用户的权限；对test具有读权限。</p>
<p>​	应用最具体的权限组。因此，如果redhat01与组redhat01具有不同权限，二用户redhat01也是该组的成员，那么将使用用户的所有者权限。这样，从族中删除用户可能不切实际时，可以为用户设置比其他组成员资源更严厉的权限集。</p>
<h3 id="权限影响示例"><a href="#权限影响示例" class="headerlink" title="权限影响示例"></a>权限影响示例</h3><p>​	以下示例说明文件权限的影响。对于这些示例，您的系统有四个具有以下组成员资格的用户：</p>
<table>
<thead>
<tr>
<th>用户</th>
<th>组成员资格</th>
</tr>
</thead>
<tbody><tr>
<td>user01</td>
<td>user01、user04</td>
</tr>
<tr>
<td>user02</td>
<td>user02、user04</td>
</tr>
<tr>
<td>user03</td>
<td>user03、operator2</td>
</tr>
<tr>
<td>user04</td>
<td>user04、operator2</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 user02 user03 user04 </span><br><span class="line">uid=1001(user01) gid=1001(user01) <span class="built_in">groups</span>=1001(user01),1004(user04)</span><br><span class="line">uid=1002(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02),1004(user04)</span><br><span class="line">uid=1003(user03) gid=1003(user03) <span class="built_in">groups</span>=1003(user03),10001(operator2)</span><br><span class="line">uid=1004(user04) gid=1004(user04) <span class="built_in">groups</span>=1004(user04),10001(operator2)</span><br></pre></td></tr></table></figure>

<p>​	这些用户将使用dir目录中的文件。如下是改目录中文件的长列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user02@foundation0 <span class="built_in">dir</span>]$ <span class="built_in">ls</span> -la</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x.  2 user02 user04        70 May 21 11:16 .</span><br><span class="line">drwxr-xr-x. 20 root   root        4096 May 21 11:18 ..</span><br><span class="line">-rw-rw-r--.  1 user01 user01         0 May 21 11:15 app1.log</span><br><span class="line">-rw-r--rw-.  1 user01 consultantl    0 May 21 11:15 app2.log</span><br><span class="line">-rw-rw-r--.  1 user02 consultantl    0 May 21 11:16 db1.conf</span><br><span class="line">-rw-r-----.  1 user02 consultantl    0 May 21 11:16 db2.conf</span><br></pre></td></tr></table></figure>

<p>​	ls 命令-a选项可显示隐藏文件的权限，包含用于表示目录及其父目录的特殊权限。在本示例中，.（点）特殊目录反映了dir本身的目录权限，而..（点点）特殊目录则反映了其父目录的权限。</p>
<p>​	对于db1.conf文件，拥有该文件的用户（user02）具有读取、写入权限，但没有执行权限。拥有该文件的组（user04）具有读取和写入权限，但没有执行权限。所有其他用户具有读取权限，但没有写入和执行权限。</p>
<p>​	下表探讨了这组权限对这些用户的一些影响：</p>
<table>
<thead>
<tr>
<th>影响</th>
<th>为什么会有此影响？</th>
</tr>
</thead>
<tbody><tr>
<td>user01用户可以更改db1.conf文件的内容。</td>
<td>user01用户是consultantl组的成员，并且该组对db1.conf文件具有读取、写入权限。</td>
</tr>
<tr>
<td>user02用户可以查看和修改db2.conf文件的内容。</td>
<td>user02用户拥有db2.conf文件，并对其具有读取和写入访问权限。</td>
</tr>
<tr>
<td>user01可以查看db2.conf文件的内容，但不能修改其内容。</td>
<td>user01用户是consultantl组的成员，并且该组对db2.conf文件仅有读取、写入权限，无写入权限。</td>
</tr>
<tr>
<td>user03和user04用户没有对db2.conf的内容的任何访问权限。</td>
<td>other权限适用于user03和user04用户，并且这些权限不包括读取或写入权限。</td>
</tr>
<tr>
<td>user01用户是唯一能够更改app1.log文件内容的用户</td>
<td>仅有user01用户和user01组的成员对该文件具有写入权限，而其他用户没用该权限，而user01组的唯一组成员是user01用户。</td>
</tr>
<tr>
<td>user03用户可以更改app2.log文件的内容。</td>
<td>user03用户不是app2.log文件的所有者，也不是consultantl组成员，因此他仅适用于other权限，other权限具有读、写去权限。</td>
</tr>
<tr>
<td>user02用户可以查看app2.log文件的内容，但不能修改app2.log文件的内容。</td>
<td>user02用户是consultantl组的成员，并且该组对app2.log文件具有读权限，虽然other具有读、写权限。但是组的优先级大于other，所以会覆盖other的权限。</td>
</tr>
<tr>
<td>user02用户可以删除app1.log和app2.log文件。</td>
<td>user02用户对dir目录又有写入权限（如.（点）特殊目录所示），因此可以删除该目录中的任何文件。即使user02用户没有直接对文件具有写入权限，依然是可以进行删除的。</td>
</tr>
</tbody></table>
<h2 id="从命令行管理文件系统权限"><a href="#从命令行管理文件系统权限" class="headerlink" title="从命令行管理文件系统权限"></a>从命令行管理文件系统权限</h2><h3 id="更改文件和目录权限"><a href="#更改文件和目录权限" class="headerlink" title="更改文件和目录权限"></a>更改文件和目录权限</h3><p>​	chmod命令可从命令行更改文件和目录权限。chmod命令可以解释为“更改模式”，因为文件的模式是吻技安权限的另一个名称。chmod命令在要更改的文件或目录列表后面列出了权限说明。您可以通过符号或八进制（数字）表示法设置权限指令。</p>
<h3 id="通过符号法更改权限"><a href="#通过符号法更改权限" class="headerlink" title="通过符号法更改权限"></a>通过符号法更改权限</h3><p>​	使用chmod命令修改文件和目录权限。以下示例可以帮助您了解chmod命令的用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> <span class="built_in">who</span>/what/which file|directory</span><br></pre></td></tr></table></figure>

<p>​	who是用户的类，如下表所示。如果您不提供用户类，则chmod命令将使用all组作为默认值。</p>
<table>
<thead>
<tr>
<th>who</th>
<th>集合</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>user</td>
<td>文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group</td>
<td>文件所属组成员</td>
</tr>
<tr>
<td>o</td>
<td>other</td>
<td>既不是文件所有者也不是文件所属组成员的用户</td>
</tr>
<tr>
<td>a</td>
<td>all</td>
<td>所有前面三组</td>
</tr>
</tbody></table>
<p>​	what 是修改which的操作符，如下表中所示。</p>
<table>
<thead>
<tr>
<th>what</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>add</td>
<td>向文件添加权限。</td>
</tr>
<tr>
<td>-</td>
<td>remove</td>
<td>从文件删除权限。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>set exactly</td>
<td>精确设置所提供的文件权限。</td>
</tr>
</tbody></table>
<p>​	which是模式，指定文件或目录的权限，如下表所示。</p>
<table>
<thead>
<tr>
<th>which</th>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>read</td>
<td>文件的读取权限。目录的列出权限。</td>
</tr>
<tr>
<td>w</td>
<td>write</td>
<td>文件或目录的写入权限。</td>
</tr>
<tr>
<td>x（小写）</td>
<td>execute</td>
<td>文件的执行权限。允许进入目录，以及访问该目录中的文件和子目录。</td>
</tr>
<tr>
<td>X（大写）</td>
<td>special execute</td>
<td>目录的执行权限，或者文件的执行权限（如果是文件，则该文件需要至少有一个执行权限，否则不会生效）</td>
</tr>
</tbody></table>
<p>​	用于更改文件权限的符号使用字母代表不同的权限组：u表示用户，g表示组，o表示其他，a表示全部。</p>
<p>​	使用符号法时，您不需要设置一组全新的权限。取而代之，您可以更改现有的一个或多个权限，或者使用等号（&#x3D;）来替换一组权限的整个集合。</p>
<p>​	权限自身由单个字母来表示：r表示读取，w表示写入，x表示执行。只有文件是目录或者以为用户、组或其他人设置了执行权限，您才可以使用大写X作为权限标志来添加执行权限。</p>
<p>​	以下列表显示了使用符号方法更改权限的一些示例：</p>
<p>​	对于document.pdf文件，为组和其他添加删除、读取和写入权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 <span class="built_in">dir</span>]# <span class="built_in">chmod</span> go+rw document.pdf</span><br></pre></td></tr></table></figure>

<p>​	对于myscript.sh文件，为所有人添加执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 <span class="built_in">dir</span>]# <span class="built_in">chmod</span> a+x myscript.sh</span><br></pre></td></tr></table></figure>

<p>​	您可以使用chmod命令-R选项，以递归方式对整个目录树中的文件设置权限。例如下一个命令的递归方式为拥有myfolder目录的组成员以及其中的文件和目录添加读取、写入和执行权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> -R g+rwx /root/myfolder/</span><br></pre></td></tr></table></figure>

<p>​	您还可以使用chmod命令-R选项以及X选项，以符号方式设置权限。使用chmod命令X选项，您可以对目录设置执行（搜索）权限，以便在不更改大部分文件权限的情况下，访问这些目录的内容。不过，使用X选项是要谨慎，因为如果某个文件设置有任何执行权限，则X选项也将会对该文件设置指定的执行权限。</p>
<p>​	例如，以下命令会以递归方式为组所有者设置对demodir目录及其所有子文件和目录的读、写权限，但将仅向以为用户、组或其他目录设置了执行权限的目录和文件应用组执行权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> -R g+rwX demodir/</span><br></pre></td></tr></table></figure>



<h3 id="通过八进制法更改权限"><a href="#通过八进制法更改权限" class="headerlink" title="通过八进制法更改权限"></a>通过八进制法更改权限</h3><p>​	您可以使用chmod命令，通过八进制法（而非符号法）来更改文件权限。在以下实例中，#字符代表以为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod ### file|directory</span><br></pre></td></tr></table></figure>

<p>​	如果使用八进制法，您可以用三位（火灾设置高级权限时为四位）八进制数来表示权限。单个八进制数字可以表示0-7的任何单个值。</p>
<p>​	在权限的三位八进制表示法中，每一位数字表示一个访问级别，从左至右为：用户、组和其他。要确定每个数字：</p>
<ul>
<li>从0开始。</li>
<li>如果要为此访问级别添加读取权限，请加4。</li>
<li>如果要添加写入权限，请加2。</li>
<li>如果要添加执行权限，请加1。</li>
</ul>
<p>​	有经验的管理员通常使用八进制权限，因为它们更容易对单个或匹配的文件实施权限变更。并且仍然提供完整的权限控制。</p>
<p>​	以下列表显示了使用八进制法更改权限的一些示例：</p>
<p>​	对于sample.txt文件，为用户设置读取和写入权限，并为组和其他人设置读取权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chmod</span> 644 sample.txt</span><br></pre></td></tr></table></figure>

<p>​	对sampledor目录，为用户设置读取、写入和执行权限，为组设置读取和执行权限，而为其他人设置权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chmod</span> 750 sampledor</span><br></pre></td></tr></table></figure>



<h3 id="更改文件和目录的用户或组所有权"><a href="#更改文件和目录的用户或组所有权" class="headerlink" title="更改文件和目录的用户或组所有权"></a>更改文件和目录的用户或组所有权</h3><p>​	用户拥有其创建的文件。默认情况下，新文件的组所有权为创建该文件的主要用户组。在RedHat Linux 中，用户的主要组通常为仅有该用户作为成员的私有组。要根据组成员资格授予文件的访问权限，可能需要更改拥有该文件的组。</p>
<p>​	只有root用户能够更改拥有文件的用户。但是，文件的所有者和root用户可以设置组所有权。root用户可以将文件所有权授予任何组。但只有普通用户是目标组的成员才能更改文件的组所有权。</p>
<p>​	您可以使用chown（更改所有者）命令更改文件所有权。例如，要将app.conf的所有权授予user01用户，您可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user01 app.conf</span><br></pre></td></tr></table></figure>

<p>​	chown命令 -R 选项可以递归更改整个目录树的所有权。以下命令可将Pictures目录以及其下的所有文件和子目录的所有权授予给user01用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> -R user01 Pictures</span><br></pre></td></tr></table></figure>

<p>​	也可以使用chown命令更改文件的组所有权，只需要在组名称之前加上冒号（:）。例如，以下命令将Pictures目录的组所有权更改为user02：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> :user02 Pictures</span><br></pre></td></tr></table></figure>

<p>​	您可以使用chown命令也可以同时更改所有者和组，使用owner:group语法即可。例如，要将Pictures目录的所有权更改到user03用户，同时将组所有权更改为user04，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user03:user04 Pictures</span><br></pre></td></tr></table></figure>

<p>​	有些用户并不使用chown命令，而是使用chgrp命令来更改组所有权。该命令的作用与chown类似，不同之处在于，您只能用它来更改组所有权，而组名前也不需要加冒号（:）。</p>
<p>​	<code>重要：您可能会遇到chown用句点而不是冒号来分割所有者和组的情况：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user03.user04 Pictures</span><br></pre></td></tr></table></figure>

<p>​	<code>虽然同样可以更改成功，但RedHat官方不建议使用此语法，而应始终使用冒号。因为句点是用户名中有效的字符，因此chown命令可能会误解您的意图。同时命令可能会将用户和组解释为文件名。取而代之，仅可在同时设置用户和组时使用冒号字符。</code></p>
<h2 id="管理默认权限和文件访问"><a href="#管理默认权限和文件访问" class="headerlink" title="管理默认权限和文件访问"></a>管理默认权限和文件访问</h2><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>​	特殊权限是除了基本用户、组和其他类型之外的第四种特权类型。顾名思义，特殊权限提供了额外的访问相关功能，超出了基本权限类型允许的范畴。本章节介绍特殊权限的影响，具体参见下表的总结。</p>
<p><strong>特殊权限对文件和目录的影响</strong></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>u+s（suid）</td>
<td>以拥有文件的用户身份，而不是以允许文件的用户身份执行文件。</td>
<td>无影响。</td>
</tr>
<tr>
<td>g+s（sgid）</td>
<td>已拥有文件的组身份执行文件。</td>
<td>目录中创建的文件的组所有者与目录的组所有者相匹配。</td>
</tr>
<tr>
<td>o+t（sticky）</td>
<td>无影响。</td>
<td>对目录具有写入访问权限的用户仅可以删除其所拥有的文件，而无法删除或强制保存到其他用户所拥有的文件。</td>
</tr>
</tbody></table>
<p>​	对可执行文件的setuid权限表示，将以拥有该文件的用户的身份运行命令，而不是以运行命令的用户身份，以passwd为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user01@foundation0 demodir]$ <span class="built_in">ls</span> -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x. 1 root root 32648 Aug 10  2021 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的s字符辨别出setuid权限，此处通常是x字符（所有者执行权限）。如果所有者不具有执行权限，这个字符将由大写的S字符取代。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如该文件所有者的执行权限x是存在的</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwxr-xr-x. 1 root root 32648 Aug 10  2021 passwd</span><br><span class="line"><span class="comment"># 此时为所有者设置setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">chmod</span> 4755 passwd</span><br><span class="line"><span class="comment"># 则x将替换为小写的s，表示该文件具有执行权限以及setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwsr-xr-x. 1 root root 32648 Aug 10  2021 passwd</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前文件所有者无该x权限。</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rw-r--r--. 1 root root 32648 Aug 10  2021 passwd</span><br><span class="line"><span class="comment"># 此时为所有者无x权限去设置setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">chmod</span> 4644 passwd</span><br><span class="line"><span class="comment"># 则由大写的S取代。</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwSr--r--. 1 root root 32648 Aug 10  2021 passwd</span><br></pre></td></tr></table></figure>

<p>​	对于目录的setgid特殊权限，表现在该目录中创建的文件将继承该父目录的组所有权，而不是从创建用户继承组所有权。此功能通常用于协作目录，将文件从默认的私有组自动更改为共享组，或者当文件始终都应由特定的组所使用时使用。这种行为的一个示例是&#x2F;run&#x2F;log&#x2F;journal目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -ld /run/log/journal/</span><br><span class="line">drwxr-sr-x+ 3 root systemd-journal 60 May 22 09:41 /run/log/journal/</span><br></pre></td></tr></table></figure>

<p>​	如果对可执行文件设置了setgid，则命令将以拥有该文件的用户的身份运行，而不是运行命令的用户身份。此情况类似于setuid的工作方式。以locate命令为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l /usr/bin/locate </span><br><span class="line">-rwx--s--x. 1 root slocate 41032 Aug 10  2021 /usr/bin/locate</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的s字符来表别出setgid，此处通常是x字符（组执行权限）。如果组不具有执行权限，这个字符将由大写的S字符取代。</p>
<p>​	最后，针对目录的粘滞位将对目录中的文件删除设置特殊限制。只有文件的所有者（及root用户）才能删除该目录中的文件。一个示例是&#x2F;tmp目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -ld /tmp/</span><br><span class="line">drwxrwxrwt. 21 root root 4096 May 22 16:17 /tmp/</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的t字符辨别出粘滞位权限，此处通常是x字符（其他人执行权限）。如果其他人不具备执行权限，这个字符将由大写的T字符取代。</p>
<p>​	<strong>设置特殊权限</strong></p>
<ul>
<li>符号：setuid&#x3D;u+s；setgid&#x3D;g+s；粘滞位&#x3D;o+t</li>
<li>八进制：添加在三个序位前；setuid&#x3D;4；setgid&#x3D;2；粘滞位&#x3D;1</li>
</ul>
<p>​	特殊权限示例通过使用符号法在example目录中添加setgid位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-xr-x. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> g+s example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	通过使用符号法删除example目录上的setuid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> u-s example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	使用八进制法，对example目录设置setgid位，并为用户和组添加读取、写入和执行权限，但其他用户不具备任何访问权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxr--r--. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> 2770 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxrws---. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	使用八进制法，对example目录删除setgid位，并未用户和组添加读取、写入和执行权限，但其他人不具备任何访问权限。请注意，使用八进制法删除特殊权限时，您需要在权限值的开头添加额外的0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxrws---. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> 00770 example </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example</span><br><span class="line">drwxrwx---. 2 user02 user04 6 May 22 17:09 example</span><br></pre></td></tr></table></figure>



<h3 id="默认文件权限"><a href="#默认文件权限" class="headerlink" title="默认文件权限"></a>默认文件权限</h3><p>​	在创建时，文件被分配初始权限。有两个因素会影响这些初始权限。其一是您要创建的是常规文件还是目录。其二是当前的umask，它代表用户文件创建掩码。</p>
<p>​	如果创建目录，则其初始八进制权限为0777（drwxrwxrwx）。如果您创建常规文件，则其初始八进制权限为0666（-rw-rw-rw-）。必须始终不为常规文件添加执行权限。这一步可使攻击者更难破坏系统，创建和运行恶意文件</p>
<p>​	此外，shell会话会设置umask，进一步限制文件的初始权限。umask是一个八进制位掩码，可以清除由进程创建的新文件和目录的权限。如果在umask中设置了一个位，则新文件中的对应的权限将被清楚。例如，umask 0002 可清楚其他用户的写入位。前导零表示特殊权限、用户和组权限未被清楚。umask为0077时，清楚新创建文件的所有组和其他权限。</p>
<p>​	不带参数运行umask命令可显示当前shell的umask值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">umask</span> </span><br><span class="line">0022</span><br></pre></td></tr></table></figure>

<p>​	通过一个八进制参数使用umask命令，可以更改当前shell的umask。该参数应当是与新umask值对应的八进制值。umask中第一个特殊权限的前导零均可以省略。例如，umask 077与umask 0077相同。</p>
<p>​	Bash shell用户的系统默认 umask值在 &#x2F;etc&#x2F;login.defs和&#x2F;etc&#x2F;bashrc文件中定义。普通用户可以在其主目录的 .bash_profile 或 .bashrc 文件中覆盖系统默认值。</p>
<p>​	<code>重要：在RedHat Linux 8和更早的版本中，如果用户账户的UID为200或更大的值，并且用户名和账户的主要组相同，则默认的umask为0002.否则，其默认的umask为0022.</code></p>
<p>​	<code>红帽RedHat Linux 9正更改了这一设定，所有账户的umask都为0022。当您启动登录shell时，您的umask为0022。但是，当您启动交互式非登录shell时（例如当您在图形UI中启动gnome-terminal时），如果您账户的UID为200或更大值，并且您的主要组与您的用户账户同名，则您的umask为0002。未来RedHat会将所有用户都更改为同样的0022。</code></p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250522182353825.png" alt="image-20250522182353825"></p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250522182245664.png" alt="image-20250522182245664"></p>
<h3 id="umask使用程序对权限的影响"><a href="#umask使用程序对权限的影响" class="headerlink" title="umask使用程序对权限的影响"></a>umask使用程序对权限的影响</h3><p>​	以下示例说明umask如何影响文件合目录的权限。查看当前shell中文件和目录的默认umask权限。<code>重要：假设umask当前值为0022。</code></p>
<p>​	如果您创建常规文件，则其初始八进制权限为0666（二进制表示为 000 110 110 110）。然后0022的umask（000 000 010 010）将禁用组合其他对象的写入权限位。因此，所有者对文件具有读取和写入权限，组合其他对象设置为读取权限（000 110 100 100）.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> </span><br><span class="line">0022</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> test.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l test.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk 0 May 23 14:40 test.txt</span><br></pre></td></tr></table></figure>

<p>​	如果创建目录，则其初始的八进制权限为0777（000 111 111 111）.然后umask为0022（000 000 010 010）将禁用组和其他对象的写入权限位。因此所有者对目录具有读取、写入和执行权限，组合其他对象设置为读取和执行权限（000 111 101 101）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> </span><br><span class="line">0022</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> default</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld default/</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk 6 May 23 14:44 default/</span><br></pre></td></tr></table></figure>

<p>​	通过将umask值设置为0，其他用户的文件权限将从读取改为读取和写入。其他用户的目录权限将从读取和执行改为读取、写入和执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 0</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> zero.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l zero.txt </span><br><span class="line">-rw-rw-rw-. 1 kiosk kiosk 0 May 23 17:21 zero.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> zero </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld zero</span><br><span class="line">drwxrwxrwx. 2 kiosk kiosk 6 May 23 17:22 zero</span><br></pre></td></tr></table></figure>

<p>​	要屏蔽其他用户的所有文件和目录权限，请将umask值设置为007。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 007</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l seven.txt </span><br><span class="line">-rw-rw----. 1 kiosk kiosk 0 May 23 17:23 seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> seven</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld seven</span><br><span class="line">drwxrwx---. 2 kiosk kiosk 6 May 23 17:23 seven</span><br></pre></td></tr></table></figure>

<p>​	umask为027可确保用户对新文件具有读写权限，组具有读取权限。组对新目录具有读取和执行权限，而其他用户则没有任何权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 027</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> two-seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l two-seven.txt</span><br><span class="line">-rw-r-----. 1 kiosk kiosk 0 May 23 17:27 two-seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> two-seven</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld two-seven</span><br><span class="line">drwxr-x---. 2 kiosk kiosk 6 May 23 17:28 two-seven</span><br></pre></td></tr></table></figure>



<h3 id="更改默认权限"><a href="#更改默认权限" class="headerlink" title="更改默认权限"></a>更改默认权限</h3><p>​	在RedHat Linux 9中，&#x2F;etc&#x2F;logindefs文件为用户设置默认的umask。默认情况下，其umask行指定的默认umask为0022。</p>
<p>​	在RedHat Linux 9.0和9.1中，这只影响登录shell。如果您启动新的终端窗口或以其他方式启动交互式飞登录shell，&#x2F;etc&#x2F;bashrc中的设置仍然适用。对于这些shell，如果账户UID为200或更大值，并且用户名和主要组名相同，就会向账户分配一个值为0002的umask。否则，其umask为0022。</p>
<p>​	root用户可以通过在&#x2F;etc&#x2F;profile.d&#x2F;目录中添加local-umask.sh的shell启动脚本来更改交互式非登录shell的默认umask。以下示例显示了一个local-umask.sh文件。</p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250523175818661.png" alt="image-20250523175818661"></p>
<p>​	对于UID大于199且用户名和主要组相匹配的用户，上面的示例会将umask设置为0007，其余全部设置为0022。（前导零可以省略）如果想将所有人的umask都设置为0022，可以使用以下内容创建该文件。</p>
<p>总结：交互式非登录bashrc生效，交互式登录bash_profile生效。</p>
<p>​	可以通过shopt login_shell验证是否是登录还是非登录，如果为on则表示当前是登录式，off则是非登录式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ shopt login_shell </span><br><span class="line">login_shell    	on</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第四章节</title>
    <url>/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="创建、查看和编辑文本文件"><a href="#创建、查看和编辑文本文件" class="headerlink" title="创建、查看和编辑文本文件"></a>创建、查看和编辑文本文件</h1><h2 id="将输出重定向到文件或程序"><a href="#将输出重定向到文件或程序" class="headerlink" title="将输出重定向到文件或程序"></a>将输出重定向到文件或程序</h2><p>标准输入、标准输出和标准错误</p>
<p>​	运行中的程序或进程会读取输入并写入输出。从shell提示符运行命令时，通常会从键盘读取其输入，并将输出发送到终端窗口。</p>
<p>​	进程使用称为文件描述符的编号通道来获取输入并发送输出。所有进程在开始时至少要有三个文件描述符。标准输入（通道0）从键盘读取输入。标准输出（通道1）将正常输出发送到终端。标准错误（通道2）将错误消息发送到终端。</p>
<p>​	如果程序打开连接至其他文件的单独连接，则可能要使用更大编号的文件描述符。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310171941393.png" alt="image-20250310171941393"></p>
<blockquote>
<p>​													进程I&#x2F;O通道（文件描述符）</p>
</blockquote>
<p>​	下表总结了有关文件夫描述符的信息：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>通道名称</th>
<th>描述</th>
<th>默认连接</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
<td>仅读取</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>标准输出</td>
<td>终端</td>
<td>仅写入</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>标准错误</td>
<td>终端</td>
<td>仅写入</td>
</tr>
<tr>
<td>3</td>
<td>filename</td>
<td>其他文件</td>
<td>无</td>
<td>读取或写入</td>
</tr>
</tbody></table>
<h2 id="将输出重定向到文件"><a href="#将输出重定向到文件" class="headerlink" title="将输出重定向到文件"></a>将输出重定向到文件</h2><p>​	输入&#x2F;输出（I&#x2F;O）重定向可给更改进程获取其输入或输出的方式。进程可以执行文件读取或写入，而不从键盘获取输入，也不将输出和错误发送到终端。通过重定向，您可以将消息保存到文件，而不在终端上显示输出。或者，您也可以使用重定向丢弃输出或错误输出，这样它们就不会显示在终端上或保存下来。</p>
<p>​	您可以重定向进程stdout以阻止进程输出显示在终端上。如果您将stdout重定向到某个文件，单该文件不存在，则会为您创建该文件。如果文件确实存在，但是您选择的重定向不是附加到文件，则重定向会覆盖文件原有内容。要丢弃进程的输出，您可以重定向到空的&#x2F;dev&#x2F;null特殊文件，该文件会静默丢弃重定向到该进程的通道输出。</p>
<p>​	如下表，仅对stdout重定向不会阻止stderr错误消息显示在终端上。</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>视觉辅助</th>
</tr>
</thead>
<tbody><tr>
<td>&gt; file</td>
<td>重定向stdout以覆盖文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180118758.png" alt="image-20250310180118758"></td>
</tr>
<tr>
<td>&gt;&gt; file</td>
<td>重定向stdout以追加到文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180306263.png" alt="image-20250310180306263"></td>
</tr>
<tr>
<td>2&gt; file</td>
<td>重定向stderr以覆盖文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180426539.png" alt="image-20250310180426539"></td>
</tr>
<tr>
<td>2&gt; &#x2F;dev&#x2F;null</td>
<td>重定向stderr错误消息到&#x2F;dev&#x2F;null，从而丢弃它</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180600483.png" alt="image-20250310180600483"></td>
</tr>
<tr>
<td>&gt; file 2&gt;&amp;1 和 &amp;&gt; file</td>
<td>重定向stdout和stderr以覆盖同一文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180738265.png" alt="image-20250310180738265"></td>
</tr>
<tr>
<td>&gt;&gt; file 2&gt;&amp;1 和 &amp;&gt;&gt; file</td>
<td>重定向stdout和stderr以追加到同一文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180849243.png" alt="image-20250310180849243"></td>
</tr>
<tr>
<td>&gt; file 2&gt; file</td>
<td>分别将stdout和stderr以覆盖到不同的文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310181244864.png" alt="image-20250310181244864"></td>
</tr>
<tr>
<td>&gt;&gt; file 2&gt;&gt; file</td>
<td>分别将stdout和stderr以追加到不同的文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310181402294.png" alt="image-20250310181402294"></td>
</tr>
</tbody></table>
<h2 id="输出重定向示例"><a href="#输出重定向示例" class="headerlink" title="输出重定向示例"></a>输出重定向示例</h2><p>​	通过重定向来简化许多日常管理任务。在是思考下列示例时，请参考前面表格。</p>
<p>​	在&#x2F;tmp&#x2F;saved-timestamp文件中保存时间戳以供日后参考。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> &gt; /tmp/saved-timestamp</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/saved-timestamp</span><br><span class="line">Tue Mar 18 04:54:43 PM CST 2025</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将&#x2F;var&#x2F;log&#x2F;secure文件的最后100行复制到&#x2F;tmp&#x2F;last-100-secure文件，这里需要使用root账户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> -n 100 /var/log/secure &gt; /tmp/last-100-secure</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>

<p>​	将所有四个step文件内容连接为一个，并保存到&#x2F;tmp&#x2F;all-four-steps-in-one文件中，没有该step文件可自行创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> step1.txt step2.txt step3.txt step4.txt </span><br><span class="line">step1</span><br><span class="line">step2</span><br><span class="line">step3</span><br><span class="line">step4</span><br><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> step1.txt step2.txt step3.txt step4.txt &gt; /tmp/all-four-steps-in-one</span><br><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> /tmp/all-four-steps-in-one</span><br><span class="line">step1</span><br><span class="line">step2</span><br><span class="line">step3</span><br><span class="line">step4</span><br><span class="line">[root@foundation0 step]#</span><br></pre></td></tr></table></figure>

<p>​	列出主目录的隐藏文件名和常规文件名，并输出保存到my-file-names文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -a &gt; my-file-names</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> my-file-names </span><br><span class="line">.....忽略.....</span><br><span class="line">ClassroomSetup-RHCSA-9.0-1.r2022052407gitdd6fbd2.txt</span><br><span class="line">ClassroomSetup-RHCSA-9.0-1.r2022092007git75b8165.txt</span><br><span class="line">ClassroomTroubleshooting-9.x-7.r2022112118git21c9ff2.txt</span><br><span class="line">.cshrc</span><br><span class="line">.dbus</span><br><span class="line">foundation0-config-9.x-7.r2022112118git21c9ff2.noarch.rpm</span><br><span class="line">foundation0-config-post.log</span><br><span class="line">.....忽略.....</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	在现有的&#x2F;tmp&#x2F;many-lines-of-information文件中附加一行内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /tmp/many-lines-of-information</span><br><span class="line">hahaha</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">echo</span> <span class="string">&quot;new line of information&quot;</span> &gt; /tmp/many-lines-of-information</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /tmp/many-lines-of-information</span><br><span class="line">new line of information</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	接下来几个命令会产生错误消息，因为普通用户无法访问某些系统目录。观察错误消息的重定向。</p>
<p>​	在终端上查看普通命令输出时，将find命令的错误重定向到&#x2F;tmp&#x2F;errors文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd 2&gt; /tmp/errors</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors</span><br><span class="line">...忽略...</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	将进程输出保存到&#x2F;tmp&#x2F;output文件，并将错误消息保存到&#x2F;tmp&#x2F;errorss文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/output 2&gt; /tmp/errors</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/output </span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors </span><br><span class="line">...忽略...</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	将进程输出保存到&#x2F;tmp&#x2F;output文件，并丢弃错误消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/output 2&gt; /dev/null </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/output </span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors</span><br><span class="line"><span class="built_in">cat</span>: /tmp/errors: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将输出和生成的错误消息一起存储到&#x2F;tmp&#x2F;all-message-output文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/all-message-output 2&gt;&amp;1</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/all-message-output </span><br><span class="line">find: ‘/etc/pki/rsyslog’: Permission denied</span><br><span class="line">find: ‘/etc/dhcp’: Permission denied</span><br><span class="line">find: ‘/etc/ssh/sshd_config.d’: Permission denied</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">find: ‘/etc/lvm/archive’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">/etc/passwd</span><br><span class="line">find: ‘/etc/grub.d’: Permission denied</span><br><span class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将输出和生成的错误附加到&#x2F;tmp&#x2F;all-message-output文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt;&gt; /tmp/all-message-output 2&gt;&amp;1</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="构建管道"><a href="#构建管道" class="headerlink" title="构建管道"></a>构建管道</h2><p>​	管道是一个或多个命令的序列，永竖线字符（|）分割。管道将第一个命令的标准输出连接到下一个命令的标准输入。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250318180725621.png" alt="image-20250318180725621"></p>
<p>​	在某个进程输出到终端之前，使用管道来操作另一个进程并格式化进程的输出。可以想象一下，数据正在通过一个管道从一个进程“流”向另一个进程，并且在其流过的管道中每个命令都会对其做出些改动。</p>
<p>​	<code>注意：管道和I/O重定向都可以操作标准输出和输入。重定向会向文件发送标准输出或从文件获取标准输入。管道会将一个进程的标准输出发送到另一个进程的标准输入。</code></p>
<h2 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h2><p>​	以下列表显示了一些管道示例：</p>
<p>​	将ls命令的输出重定向到less命令，以在终端上以一次一屏的方式显示输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> /usr/bin/ | less</span><br></pre></td></tr></table></figure>

<p>​	将ls命令的输出重定向到wc -l命令，以统计ls收到的行数并将这个值显示在终端上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> | <span class="built_in">wc</span> -l</span><br><span class="line">23</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将ls -t命令的输出重定向到head命令，以显示前十行，并将最终结果重定向到&#x2F;tmp&#x2F;first-ten-changed-files文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 &gt; /tmp/first-ten-changed-files</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/first-ten-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="管道、重定向和附加到文件"><a href="#管道、重定向和附加到文件" class="headerlink" title="管道、重定向和附加到文件"></a>管道、重定向和附加到文件</h2><p>​	如果将重定向与管道组合，shell会首先设置整个管道，然后重定向输入&#x2F;输出。如果在管道的中间使用重定向，则输出将转至文件，而不会前往管道中的下一个命令。</p>
<p>​	在以下示例中，ls命令的输出将转至&#x2F;tmp&#x2F;saved-output文件，并且less命令不在终端上显示任何内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> &gt; /tmp/saved-output | less</span><br></pre></td></tr></table></figure>

<p>​	tee命令克服了这个限制。在管道中，tee将其标准输入复制到其标准输出中，并且还将标准输出重定向到指定的命令参数的文件。如果您将数据想象成流经管道的水，那么可将tee视觉化为管道中的T形接头，它负责输出在两个方向上的流向，所以该命令也称为“三通”。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250318180625486.png" alt="image-20250318180625486"></p>
<h2 id="使用tee命令的管道示例"><a href="#使用tee命令的管道示例" class="headerlink" title="使用tee命令的管道示例"></a>使用tee命令的管道示例</h2><p>​	以下示例将ls命令的输出重定向到&#x2F;tmp&#x2F;saved-output文件，并且将它传递到less命令，以便在终端上一次一屏的方式显示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> | <span class="built_in">tee</span> /tmp/saved-output | less</span><br></pre></td></tr></table></figure>

<p>​	如果在管道末尾使用tee命令，则终端将显示管道中的命令输出，同时将其保存到文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 | <span class="built_in">tee</span> /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br></pre></td></tr></table></figure>

<p>​	使用tee命令配合-a选项将内容追加到文件，并非是覆盖它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 | <span class="built_in">tee</span> -a /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">...忽略...</span><br><span class="line">Templates</span><br><span class="line">ssh.sh</span><br><span class="line">...忽略...</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	注意：您可以使用管道来重定向比标准错误，但不能使用合并重定向操作符（&amp;&gt;和&amp;&gt;&gt;）执行此操作。以下示例是通过管道重定向标准输出和标准错误的正确方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc/ -name passwd 2&gt;&amp;1 | less</span><br></pre></td></tr></table></figure>



<h1 id="从shell提示符编辑文本文件"><a href="#从shell提示符编辑文本文件" class="headerlink" title="从shell提示符编辑文本文件"></a>从shell提示符编辑文本文件</h1><h2 id="使用vim编辑文件"><a href="#使用vim编辑文件" class="headerlink" title="使用vim编辑文件"></a>使用vim编辑文件</h2><p>​	Linux的基本设计原则是支持将信息和配置设置存储再基于文件的文件中。这些文件可以采用各种结构，如设置列表、INI格式、结构化XML或YAML等等。以基于文本的结构存储文件的优点是可以使用任何简单的文本编辑器轻松的完成编辑。</p>
<h2 id="VIM编辑器的优势"><a href="#VIM编辑器的优势" class="headerlink" title="VIM编辑器的优势"></a>VIM编辑器的优势</h2><p>​	当系统使用纯文本shell提示符时，您应该知道如何至少一个文本编辑器来编辑文本。然后您可以从终端窗口，或是通过ssh或web控制台远程登录的方式来编辑基于文本的配置文件。您不需要访问图形桌面，就能编辑服务器上的文件，而且该服务器可能根本不需要运行图形桌面环境。</p>
<p>​	学习vim的关键在于，它几乎总是默认安装再服务器上，用于编辑基于文本的文件。可移植操作系统接口或POSIX标准制定了Linux上vi编辑器，许多其他类UNIX操作系统大致如此。</p>
<p>​	vim还经常被用作vi在其他标准操作系统或发行版上实现。例如，macOS目前默认是Vim的轻量级安装。因此，面向Linux学习vim技能也可能在别处有用。</p>
<h2 id="VIM入门"><a href="#VIM入门" class="headerlink" title="VIM入门"></a>VIM入门</h2><p>​	您可以使用如下两个软件包中的任何一个，在红帽Linux中安装vim编辑器。两个软件包为编辑基于文本的文件提供了不通的功能和vim命令。</p>
<p>​	通过vim-minimal软件包，您可以安装具有核心功能的vi编辑器。这是一个轻量级安装，仅包含核心功能和基本vi命令。您可以使用vi命令打开文本进行编辑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ vi filename</span><br></pre></td></tr></table></figure>

<p>​	或者您可以使用vim-enhanced软件包安装vim编辑器。此软件包提供一套更完整的功能、一个在线帮助系统和一个教程系统。使用vim命令，在这种增强模式下启动vim编辑文本文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ vim filename</span><br></pre></td></tr></table></figure>

<p>​	如果安装了vim-enhanced，则会设置一个shell别名，普通用户可设置一个shell别名，以便在运行vi命令时自动获取vim命令。此别名不适合于root用户及其UID小于200的用户（这些用户供系统服务使用）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ alias vi=&quot;vim&quot;</span><br><span class="line">[kiosk@foundation0 ~]$ alias </span><br><span class="line">...忽略...</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">...忽略...</span><br></pre></td></tr></table></figure>

<p>​	如果安装了vim-enhanced，并且普通用户想要使用vi命令，则它们可能必须使用\vi命令来临时覆盖别名。您可以使用\vi –version和vim –version来比较两个命令的功能集。</p>
<h2 id="VIM操作模式"><a href="#VIM操作模式" class="headerlink" title="VIM操作模式"></a>VIM操作模式</h2><p>​	vim编辑器提供各种操作模式，如命令模式、扩展命令模式、编辑模式和可视模式。作为vim用户，您要始终了解当前的模式，因为击键在不同模式下具有不通的效果。</p>
<p>​	<img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250319110333114.png" alt="image-20250319110333114"></p>
<p>​	第一次打开vim时，它会以命令模式启动，可用于导航、剪切和粘贴，以及其他文本修改。按所需的案件可访问特定的编辑模式。</p>
<ul>
<li><p>按i建进入插入模式，之后键入的所有文本将变为文件内容。按Esc键返回到命令模式。</p>
</li>
<li><p>按v键进入可视模式，可在其中选择多个字符进行文本操作。使用shift+V选择多行，使用 Ctrl+V可选择文本块。要退出可视模式，请按v、sheift+V或ctrl+V键。</p>
</li>
<li><p>按：键启动扩展命令模式，可执行的任务包含写入文件（保存文件），以及退出vim编辑器等。</p>
<p><code>注意：如果您不确定所使用的模式，可以按几次Esc来返回到命令模式。在命令模式重复按Esc键是安全的。</code></p>
</li>
</ul>
<h2 id="最低程度的基于vim工作流"><a href="#最低程度的基于vim工作流" class="headerlink" title="最低程度的基于vim工作流"></a>最低程度的基于vim工作流</h2><p>​	vim具有高效的组合击键操作，可进行高级编辑任务。虽说熟能生巧，但vim功能可能会难道新用户。</p>
<p>​	工贸建议学习一下vim键和命令。</p>
<ul>
<li>u键可撤销最近的编辑内容。</li>
<li>x键可删除单子字符。</li>
<li>:w 命令可写入（保存）文件，并停留在命令模式中以进行之后更多的编辑任务。</li>
<li>:wq 命令可写入（保存）文件并退出vim编辑页。</li>
<li>:q! 命令可退出vim，同时放弃一次写入以来进行的所有更改。</li>
</ul>
<p>​	学习这些命令有助于vim用户完成任何编辑任务</p>
<h2 id="重排现有文本"><a href="#重排现有文本" class="headerlink" title="重排现有文本"></a>重排现有文本</h2><p>​	在vim中，您可以通过使用y和p命令字符来执行拖拉和放置（复制和粘贴）。将光标定位到要选择的第一个字符，然后进去可视模式（按住v）。使用键盘左右箭头选择要操作的字符。选中所要操作的字符后，按y将所选内容拖拉（复制）到内存中。将光标定位到新位置，然后按p将所选内容放置（粘贴）到光标处。</p>
<h2 id="vim中的可视模式"><a href="#vim中的可视模式" class="headerlink" title="vim中的可视模式"></a>vim中的可视模式</h2><p>​	可视化模式可用于突出显示和操作不同行和列中的文本。您可以使用以下组合键在vim中进入可视模式。</p>
<ul>
<li>字符模式： v</li>
<li>行模式：shift+v</li>
<li>块（列）模式：ctrl+v</li>
</ul>
<p>字符模式可突出西安市文本块中的句子。屏幕底部会出现VISUAL一词。按v可进入可视字符模式。按shift+v可进入行模式。底部会出现VISUAL LINE一词。</p>
<p>可视块模式非常适合于操作数据文件。从光标处按Ctrl+v键进入可视块。屏幕底部会出现VISUAL BLOCK。使用左右箭头键可以来突出选择要更改的部分。</p>
<h2 id="vim配置文件"><a href="#vim配置文件" class="headerlink" title="vim配置文件"></a>vim配置文件</h2><p>​	&#x2F;etc&#x2F;vimrc和<del>&#x2F;.vimr配置文件分别用来该表整个系统或特定用户的vim编辑器行为。在这些配置文件中您可以指定行为，如默认的制表符间距、语法突出显示、颜色方案等。在使用yaml等具有严格语法要求的语言时，修改vim编辑器的行为非常有用。请考虑以下</del>&#x2F;.vimrc文件，他将在编辑yaml文件时将默认制表位（有ts字符表述）原先的四个空格，修改为两个空格。该文件还包括set number参数，可在表记所有文件时显示行号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> .vimrc </span><br><span class="line">autocmd FileType yaml setlocal ts=2</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	其余更多参数资料可使用man vim（5）进行查看。</p>
<h1 id="更改shell环境"><a href="#更改shell环境" class="headerlink" title="更改shell环境"></a>更改shell环境</h1><h2 id="shell变量用法"><a href="#shell变量用法" class="headerlink" title="shell变量用法"></a>shell变量用法</h2><p>​	使用Bash Shell时，您可以设置shell变量，来帮助运行命令或修改shell的行为。它们会自动复制到从改shell运行的程序中。您可以使用变量来更轻松的运行带有长参数的命令，或者将常用设置应用于该shell运行的命令。</p>
<p>​	shell变量对于特定的shell会话是唯一的。如果您打开两个终端窗口，或者通过两个独立的登录会话登录同以远程服务器，那么您在运行两个shell。每个shell都会有自己的一组shell变量值。</p>
<h2 id="为变量分配值"><a href="#为变量分配值" class="headerlink" title="为变量分配值"></a>为变量分配值</h2><p>​	使用以下语法将值分配给shell变量，VARIABLENAME（变量名）、value（变量值）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ VARIABLENAME=value</span><br></pre></td></tr></table></figure>

<p>​	变量名可以包含大写或小写、数字和下划线字符（_）。例如以下命令可设置shell变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ COUNT=40</span><br><span class="line">[kiosk@foundation0 ~]$ first_name=LiWeiHu</span><br><span class="line">[kiosk@foundation0 ~]$ file1=/tmp/abc</span><br><span class="line">[kiosk@foundation0 ~]$ _ID=RH124</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	请记住，此更改仅会影响在其中运行命令的shell环境中，而不影响您可能在在服务器上运行的其他任何shell。</p>
<p>​	您可以使用set命令列出当前设置的所有shell变量。（它还会列出所有shell喊出，您可以忽略它们）要提高可读性，您可以将输出通过管道传输到less命令，以便一次一页的查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ set | less</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250319162742725.png" alt="image-20250319162742725"></p>
<p>​	</p>
<h2 id="使用变量扩展检索值"><a href="#使用变量扩展检索值" class="headerlink" title="使用变量扩展检索值"></a>使用变量扩展检索值</h2><p>​	您可以使用变量扩展来指代您设置的变量值。要使用变量扩展，您在变量名前加上美元符号（$）。</p>
<p>例如：以下命令可将变量COUNT设置为40.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ COUNT=40</span><br></pre></td></tr></table></figure>

<p>如果echo COUNT，他会显示COUNT字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> COUNT</span><br><span class="line">COUNT</span><br></pre></td></tr></table></figure>

<p>如果输入echo $COUNT，他会显示COUNT变量的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$COUNT</span></span><br><span class="line">40</span><br></pre></td></tr></table></figure>

<p>您也可以使用变量来指代多个命令的长文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ file1=/tmp/tmp.Z9s32js242</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> <span class="variable">$file1</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> <span class="variable">$file1</span></span><br><span class="line">/tmp/tmp.Z9s32js242</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> <span class="variable">$file1</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> <span class="variable">$file1</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/tmp/tmp.Z9s32js242&#x27;</span>: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	重要：您始终可以在变量扩展中使用花括号，尽管它们通常是不必要的。</p>
<p>​		在以下示例中，echo命令尝试扩展不存在的变量COUNTx，但不返回任何内容。该命令也不会报告任何错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> new <span class="variable">$COUNTx</span></span><br><span class="line">new</span><br></pre></td></tr></table></figure>

<p>​		如果变量名旁边有任何尾随字符，可以使用花括号来划定变量名称的界限。在以下示例中，echo命令现在扩展了COUNT变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> new <span class="variable">$&#123;COUNT&#125;</span>x</span><br><span class="line">new 40x</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用Shell变量配置Bash"><a href="#使用Shell变量配置Bash" class="headerlink" title="使用Shell变量配置Bash"></a>使用Shell变量配置Bash</h2><p>​	一些shell变量在Bash启动时设置。您可以修改它们来调整shell的行为。</p>
<p>​	例如，HISTFILE、HISTFILESIZE和HISTTIMEFORMAT等shell变量可影响shell历史记录的history命令。HISTFILE变量指定要将shell历史记录保存到哪个文件，默认为~&#x2F;.bash_history。HISTTIMEFORMAT变量定义历史记录中每个命令的时间戳格式。默认情况下，此变量不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ history </span><br><span class="line">   15  vim filename</span><br><span class="line">   16  vim --version</span><br><span class="line">   17  \vi --version</span><br><span class="line">   18  alias </span><br><span class="line">   19  alias vi=&quot;vim&quot;</span><br><span class="line">   20  alias </span><br><span class="line">   21  vim filename </span><br><span class="line">[kiosk@foundation0 ~]$ HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">[kiosk@foundation0 ~]$ history </span><br><span class="line">   15  2025-03-19 10:16:06 vim filename</span><br><span class="line">   16  2025-03-19 10:17:37 vim --version</span><br><span class="line">   17  2025-03-19 10:17:43 \vi --version</span><br><span class="line">   18  2025-03-19 10:21:55 alias </span><br><span class="line">   19  2025-03-19 10:23:06 alias vi=&quot;vim&quot;</span><br><span class="line">   20  2025-03-19 10:23:10 alias </span><br><span class="line">   21  2025-03-19 11:31:39 vim filename </span><br></pre></td></tr></table></figure>

<p>​	另一个示例是PS1变量，该变量控制shell提示符的外观。如果更改此值，他将改变shell提示符的外观。bash（1）man page的“PROMPTING”部分列出了提示符支持的多个特殊字符扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ PS1=<span class="string">&quot;bash\$ &quot;</span></span><br><span class="line">bash$ PS1=<span class="string">&quot;[\u@\h \w]\$ &quot;</span></span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	由于PS1变量设置的值是提示符，红帽建议以空格结尾。另外每当变量值包含某种形式的空格（包括空格、制表符（TAB）或回车）时，该值必须用单引号或双引号括起来。如果省略引号，可能会出现意外结果。前面的PS1变量符合尾随空格建议和引号规则。</p>
<h2 id="使用环境变量配置程序"><a href="#使用环境变量配置程序" class="headerlink" title="使用环境变量配置程序"></a>使用环境变量配置程序</h2><p>​	shell提供了一个环境，供您从该shell中运行程序。例如，此环境包括有关文件系统上当前工作目录的信息、传递给程序的命令行选项，以及环境变量的值。程序可以使用这些环境变量来更改其行为或其默认设置。</p>
<p>​	如果shell变量不是环境变量，则只有shell可以使用它。但是如果shell变量是环境变量，则shell和从该shell运行的任何程序都可以使用该变量。</p>
<p>​	您可以将shell中定义的任何变量分配为环境变量，方法是将它们用export命令导出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ EDITOR=vim</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$EDITOR</span></span><br><span class="line">vim</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> EDITOR</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span></span><br><span class="line">...忽略...</span><br><span class="line"><span class="built_in">declare</span> -x EDITOR=<span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	另一个重要的环境变量是PATH。PATH变量包含一个含有程序目录的冒号分割列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/home/kiosk/.local/bin:/home/kiosk/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	当您运行如ls等命令时，shell会按顺序逐一在这些目录中查找可执行文件ls，并且允许它找到的第一个匹配文件。（在经典的系统中，此文件位于&#x2F;usr&#x2F;bin&#x2F;ls）。</p>
<p>​	那您可以轻松地将目录附加到PATH变量。例如，您可能希望像常规命令一样允许&#x2F;home&#x2F;user&#x2F;sbin中一些可执行程序或脚本。您可以将&#x2F;home&#x2F;user&#x2F;sbin目录加到当前会话的PATH中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ export PATH=$&#123;PATH&#125;:/home/kiosk/sbin</span><br><span class="line">[kiosk@foundation0 ~]$ cat &gt; /home/kiosk/sbin/haha &lt;&lt; EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;这是/home/kiosk/sbin目录下的一个可执行文件&quot;</span><br><span class="line">EOF</span><br><span class="line">[kiosk@foundation0 ~]$ haha</span><br><span class="line">这是/home/kiosk/sbin目录下的一个可执行文件</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	要列出特定的shell的所有环境变量，请运行env命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ env</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">...忽略...</span><br><span class="line">PATH=/home/kiosk/.local/bin:/home/kiosk/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/kiosk/sbin</span><br><span class="line">SELINUX_LEVEL_REQUESTED=</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="设置默认文本编辑器"><a href="#设置默认文本编辑器" class="headerlink" title="设置默认文本编辑器"></a>设置默认文本编辑器</h2><p>​	EDITOR环境变量是指定要用于命令行程序的默认文本编辑器。如果不指定，很多系统会使用vi或者vim，您也可以覆盖原有选项，这里可以换成nano编辑器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> EDITOR=nano</span><br></pre></td></tr></table></figure>





<h2 id="自动设置变量"><a href="#自动设置变量" class="headerlink" title="自动设置变量"></a>自动设置变量</h2><p>​	当Bash启动时，会运行几个含有shell命令的文本文件，以初始化shell环境。要在shell启动时自动设置shell或环境变量，您可以编辑Bash启动脚本。也就是配置永久变量或环境变量。</p>
<p>​	运行的确切脚本取决于shell是交互式还是非交互式的，以及是登录还是非登录shell。用户直接在交互式shell中输入命令，而非交互式shell则是在后台运行且无需用户干预，例如脚本。当用户通过终端本地登录或通过SSH协议远程登录时，将调用登录shell。非登录shell从现有会话调用，例如从GNOME GUI打开终端。</p>
<p>​	对于交互式登录shell，&#x2F;etc&#x2F;profile和<del>&#x2F;.bash_profile文件配置Bash环境，&#x2F;etc&#x2F;profile和</del>&#x2F;.bash_profile文件也分别提供&#x2F;etc&#x2F;bashrc和<del>&#x2F;.bashrc文件。对于交互式非登录shell，只有&#x2F;etc&#x2F;bashrc和</del>&#x2F;.bashrc文件配置Bash环境。&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc文件适用于整个系统（全局Bash环境），而<del>&#x2F;.bash_profile和</del>&#x2F;.bashrc文件则是特定用户的（局部用户Bash环境）。非交互式shell调用BASH_ENV变量定义的任何文件。默认情况下不定义此变量。</p>
<p>​	要创建可供所有交互式shell使用的变量，请编辑<del>&#x2F;.bashrc文件。若也要在用户登录后使用的变量，可在</del>&#x2F;.bash_profile文件中定义。</p>
<p>​	例如，若要更改通过SSH登录时的默认编辑器，您可以修改~&#x2F;.bash_profile文件中的EDITOR变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&quot;export EDITOR=nano&quot;</span> &gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：若要调整作用于所有用户账户的设置，最佳的方式是带有.sh扩展名的文件，并在改文件中包含对应的/etc/porfile.d目录中更改。要在/etc/porfile.d目录中创建文件，请以root用户身份登录。</code></p>
<h2 id="Bash-别名"><a href="#Bash-别名" class="headerlink" title="Bash 别名"></a>Bash 别名</h2><p>​	Bash别名是其他Bash命令的快捷方式。例如，如果必须繁琐的键入一个长命令，您可以创建一个较短的别名来调用它。使用alias命令来创建别名。例如，一下示例为echo命令创建hello别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ alias hello=&#x27;echo &quot;Hello, this is a long string.&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>​	然后，您可以运行hello命令，它会调用echo命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ hello </span><br><span class="line">Hello, this is a long string.</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将别名添加到用户的~&#x2F;.bashrc文件中，以便它们在任何交互shell中可用。</p>
<h2 id="取消设置和取消导出变量于别名"><a href="#取消设置和取消导出变量于别名" class="headerlink" title="取消设置和取消导出变量于别名"></a>取消设置和取消导出变量于别名</h2><p>​	要取消设置和取消导出变量，请使用unset命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$file1</span></span><br><span class="line">/tmp/tmp.Z9sdai2W2c</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">unset</span> file1 </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$file1</span></span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	要取消导出变量但不取消设置它，请使用export -n命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> -n PS1</span><br></pre></td></tr></table></figure>



<p>​	要取消设置别名，请使用unalias命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">unalias</span> hello </span><br><span class="line">[kiosk@foundation0 ~]$ hello</span><br><span class="line">bash: hello: <span class="built_in">command</span> not found...</span><br><span class="line">^C</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第五章节</title>
    <url>/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="管理本地用户和组"><a href="#管理本地用户和组" class="headerlink" title="管理本地用户和组"></a>管理本地用户和组</h1><h2 id="什么是用户？"><a href="#什么是用户？" class="headerlink" title="什么是用户？"></a>什么是用户？</h2><p>​	用户账户在可以运行命令的不同人员和程序之间提供安全界限。</p>
<p>​	用户使用用户名想人类用户标识自己并加强操作的便利性。在内部，系统通过分配的唯一标识号（用户ID或UID）来区分不同的用户账户。在大多数情况下，如果有人使用用户账号，则系统会位改用户分配一个机密密码，以证明他们是登录的授权用户。</p>
<p>​	用户账户构成了系统安全的基础。系统中的每个进程（运行的程序）都作为一个特定用户运行。每个文件都有一个特定用户作为其所有者。借助文件所有权，系统可以对文件的用户实施访问控制。与运行进程相关联的用户可确定该进程可访问的文件和目录。</p>
<p>​	用户账户有以下三种主要类型：超级用户、系统用户和普通用户。</p>
<ul>
<li>超级用户账户负责管理系统。超级用户的名称为root，其账户的UID为0.超级用户具有完全的系统访问权限。</li>
<li>系统用户账户提供支持服务进程使用。这些进程（或守护进程）通常不需要以超级用户身份运行。系统会为它们分配非特权账户，确保其文件和其他资源不受彼此以及系统上普通用户的影响。用户无法使用系统用户账户以交互式登录。</li>
<li>大多数用户都有用于日常工作的普通用户账户。与系统用户一样，普通用户对系统具有有限的访问权限。</li>
</ul>
<p>​	使用id命令可显示有关当前已登录用户的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	要查看有关其他用户的基本信息，请将用户作为参数传递给id命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">id</span> redhat01 </span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01)</span><br><span class="line">[kiosk@foundation0 home]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ls -l命令可查看文件的所有者。使用ls -ld命令可查看目录的所有者，而不是该目录的内容。在以下出书中，第三列显示所有者的用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l test1.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk 1 Mar  6 16:46 test1.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld Music/</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk 6 Feb  1  2023 Music/</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ps命令可查看进程信息。默认为仅显示当前shell中的进程。使用ps命令-a选项可查看与某一终端相关的所有进程。使用ps命令-u选项可查看与进程关联的用户。在以下输出中，第一列显示用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps -au</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">kiosk       2342  0.0  0.0 374120  5872 tty2     Ssl+ 14:28   0:00 /usr/libexec/gdm-wayland-session --register-s</span><br><span class="line">kiosk       2352  0.0  0.1 521392 19632 tty2     Sl+  14:28   0:00 /usr/libexec/gnome-session-binary</span><br><span class="line">kiosk       3200  0.0  0.0 224212  5800 pts/0    Ss+  14:29   0:00 bash</span><br><span class="line">kiosk       4447  0.0  0.0 224228  5768 pts/6    Ss   14:35   0:00 -bash</span><br><span class="line">kiosk       4918  1.5  0.0 224096  5556 pts/7    Ss+  15:13   0:00 -bash</span><br><span class="line">kiosk       4952  0.0  0.0 225500  3648 pts/6    R+   15:13   0:00 ps -au</span><br></pre></td></tr></table></figure>

<p>​	以上命令输出按名称显示用户名，但操作系统内部利用UID来跟踪用户。用户名到UID的映射在账户信息数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;passwd文件存储有关本地用户的信息。</p>
<p>​	&#x2F;etc&#x2F;passwd文件的每一行都包含了有关某个用户的信息。该文件划分为7个以上的冒号分割的字段。以下是来自&#x2F;etc&#x2F;passwd行的示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">redhat01:x:1001:1001:User One:/home/redhat01:/bin/bash</span><br></pre></td></tr></table></figure>

<p>​	代码块的每个部分，用冒号分割</p>
<ul>
<li>redhat01：此为用户的用户名</li>
<li>x：用户的加密密码历来存储在这里；但在此是一个占位符。</li>
<li>1001：此用户账户的UID编号</li>
<li>1001：此用户账户的主要组的GID编号。本章节稍后将对组进行讨论</li>
<li>User One：此用户的简短注释、描述或真实姓名等。</li>
<li>&#x2F;home&#x2F;redhat01：用户的主目录，以及登录shell启动时的初始工作目录。</li>
<li>&#x2F;bin&#x2F;bash：此用户的默认shell程序，在登陆时运行，一些账户使用&#x2F;sbin&#x2F;nologin shell来禁止该用户使用交互式登录。</li>
</ul>
<h2 id="什么是组"><a href="#什么是组" class="headerlink" title="什么是组"></a>什么是组</h2><p>​	组是需要共享文件和其他系统资源访问权限的用户集合。组可用于向一组用户授予文件访问权限，而非向一个用户授予访问权限。</p>
<p>​	与用户一样，组也具有组名以便识别。在内部，系统通过分配的唯一标识号（组ID或GID）来区分不同的组。组名到GID映射在组账户信息身份管理数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;group文件存储有关本地组的信息。</p>
<p>​	&#x2F;etc&#x2F;group文件的每行都包含了有关某个组的信息。每个组条目被分为四个以冒号分割的字段。以下来自&#x2F;etc&#x2F;group行的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...忽略...</span><br><span class="line">redhat01:x:1001:user01,user02</span><br></pre></td></tr></table></figure>

<p>​	考虑代码块的每个部分用冒号分割：</p>
<ul>
<li>redhat01：此组的名称</li>
<li>x：以前的组密码字段；现在是一个占位符。</li>
<li>1001：此组的GID编号。</li>
<li>user01,user02：属于此组成员的用户列表，作为一个补充组。</li>
</ul>
<h2 id="主要组和补充组"><a href="#主要组和补充组" class="headerlink" title="主要组和补充组"></a>主要组和补充组</h2><p>​	每一个用户有且只有一个主要组。对于本地用户而言，这个组按照GID列在&#x2F;etc&#x2F;passwd文件中。主要组拥有用户创建的文件。</p>
<p>​	在创建普通用户时，会创建一个与用户名同名的组，作为该用户的主要组。该用户是这个私有组的唯一成员。这种组成员资格设计简化了文件权限的管理，默认为区隔不同的用户组。</p>
<p>​	用户还可以拥有多个补充组。补充组中的成员资格存储在&#x2F;etc&#x2F;group文件中。根据所在组身份具有访问权限，将授予用户对文件的访问权限，不论这些组是主要组还是补充组。例如，如果user01用户有一个主要组user01以下两个补充组wheel和webadmin，那么该用户就可以读取这三个组中任何一个组，有权读取的文件。</p>
<p>​	id命令可以显示用户的组成员资格。在以下示例中，kiosk用户具有组kiosk作为自己的主要组（gid）。groups项列出此用户的所以组成员资格，而且用户还具有libvirt组作为补充组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="获取超级用户访问权限"><a href="#获取超级用户访问权限" class="headerlink" title="获取超级用户访问权限"></a>获取超级用户访问权限</h1><h2 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h2><p>​	大多数操作系统具有一个超级用户，该用户拥有系统的全部权限。在红帽Linux中，此为root用户。此用户的特权高于文件系统上的一般特权，您可以使用它来管理系统。若要执行诸如安装或删除软件以及管理系统文件和目录任务，必须将特权升级到root用户。</p>
<p>​	通常，普通用户中只有root用户才能控制大部分设备，但也有一些例外。例如，普通用户可以控制可移动设备，如USB设备。因此，虽然普通用户可以添加和删除文件并可管理可移动的设备，但默认情况下，只有root用户才能管理硬盘。</p>
<p>​	尽管如此，这种无限制的特权也带来了职责问题。root用户拥有足以破坏系统的无限制特权：删除文件和目录、删除用户账户，以及添加后门等。一旦root用户账户被盗，系统将处于危险之中，您也可能会失去管理控制。红帽建议系统管理员始终以普通用户身份登录，仅在需要时升级到root用户特权。</p>
<p>​	Linux上root账户大致相当于Windows上的本地Admininstrator账户。在Linux中，大多数系统管理员都作为无特权的用户登录，然后使用特种工具临时获得root特权。</p>
<p>​	<code>警告：Windows用户可能熟悉以本地Administrator用户身份登录以执行系统管理员职责的做法。如今不建议这样做，用户通过Administrator组中的成员资格来获取执行管理的特权。RHEL中同样如此，红帽建议系统管理员不要直接以root身份登录。取而代之，系统管理员以普通用户身份登录，然后使用其他机制（例如：su、sudo或policykit）临时获得超级用户特权。</code></p>
<h2 id="切换用户账户"><a href="#切换用户账户" class="headerlink" title="切换用户账户"></a>切换用户账户</h2><p>​	通过使用su命令，用户可以切换至另一个用户账户。如果从普通用户账户运行su命令并将另一用户账户作为参数，则必须提供要切换到的用户账户密码。以root用户身份运行su时，则无需输入用户密码。</p>
<p>​	本示例从kiosk账户运行su命令来切换到redhat01账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ su redhat01</span><br><span class="line">Password: <span class="comment"># redhat01的密码</span></span><br><span class="line">[redhat01@foundation0 kiosk]$ <span class="built_in">id</span></span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[redhat01@foundation0 kiosk]$</span><br></pre></td></tr></table></figure>

<p>​	如果省略用户名作为su命令的参数，则默认情况下su 或 su - 命令会尝试切换到root。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 kiosk]$ su -</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Apr  3 18:01:23 CST 2025 on pts/6</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	命令su将启动非登录shell，而命令su - （带有短划线选项）会启动登录shell。两个命令的主要区别在于，su - 会将shell环境变量设置为如同该用户身份重新登录一样，而su以该用户身份启动shell，但使用的是原始用户环境变量设置。</p>
<p>​	<code>注意：su命令最常用于获得另一个用户身份（通常root）运行的命令行界面（shell提示符）。但是，您还可以通过su命令结合-c选项，以另一个用户身份运行任意程序。具体su命令更多选项可通过man su(1)查看</code></p>
<h2 id="通过sudo运行命令"><a href="#通过sudo运行命令" class="headerlink" title="通过sudo运行命令"></a>通过sudo运行命令</h2><p>​	出于安全原因，在某些情况下，系统管理员会将root用户配置为没有有限的密码。因此，用户无法使用密码直接以root身份登录系统。此外，您也无法使用su来获取交互式shell。在这种情况下，您可以使用sudo命令来获取root访问权限。</p>
<p>​	与su命令不同，sudo通常要求用户输入自己的密码以进行身份验证，而不是输入他们正尝试访问的用户账户的密码。也就是说，用户使用sudo命令以root身份运行命令时，是不需要知道root密码。相反，他们将使用自己的密码来验证访问权限。</p>
<p>​	下表总结了su、su - 和sudo命令之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>su</th>
<th>su -</th>
<th>sudo</th>
</tr>
</thead>
<tbody><tr>
<td>成为新用户</td>
<td>是</td>
<td>是</td>
<td>权限升级的命令</td>
</tr>
<tr>
<td>环境</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>需要密码</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>特权</td>
<td>与新用户相同</td>
<td>与新用户相同</td>
<td>有配置定义</td>
</tr>
<tr>
<td>记录的活动</td>
<td>仅su命令</td>
<td>仅su命令</td>
<td>权限升级的命令</td>
</tr>
</tbody></table>
<p>​	此外，您可以将sudo配置为允许特定用户像某个其他用户一样运行任何命令，或仅允许以该用户是否允许部分命令。例如，如果您将sudo命令配置为允许redhat01用户以root身份允许usermod命令，那么您可以允许一下命令来锁定或解锁用户账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> usermod -L redhat01 </span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[kiosk@foundation0 home]$ su - redhat01 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br><span class="line">[kiosk@foundation0 home]$</span><br></pre></td></tr></table></figure>

<p>​	如果某用户尝试以另一用户身份允许命令，但sudo配置不允许，则bash会阻止该命令，记录这次尝试，并向root发送一封邮件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> -f /var/log/secure</span><br><span class="line">Apr 17 15:53:04 foundation0 su[2569]: pam_unix(su-l:auth): authentication failure; <span class="built_in">logname</span>=kiosk uid=1000 euid=0 <span class="built_in">tty</span>=/dev/pts/0 ruser=kiosk rhost=  user=redhat01</span><br></pre></td></tr></table></figure>

<p>​	sudo的另一个好处是默认将所有执行的命令记录到&#x2F;var&#x2F;log&#x2F;secure中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# tail -f /var/log/secure</span><br><span class="line">Apr 17 15:50:06 foundation0 sudo[2373]:   kiosk : command not allowed ; TTY=pts/0 ; PWD=/home ; USER=root ; COMMAND=/sbin/usermod -L redhat01</span><br></pre></td></tr></table></figure>

<p>​	在红帽Linux中，wheel组所有成员都可以使用自己的密码通过sudo以任何用户身份允许命令，包括root在内</p>
<h2 id="通过Sudo获取交互式Root-Shell"><a href="#通过Sudo获取交互式Root-Shell" class="headerlink" title="通过Sudo获取交互式Root Shell"></a>通过Sudo获取交互式Root Shell</h2><p>​	要通过sudo访问root账户，请使用sudo -i命令。此命令将切换root账户并运行该用户的默认shell及关联的交互式登录脚本。要在没有交互式脚本的情况下运行shell，请使用sudo -s命令。</p>
<p>​	例如，管理员可以获取kiosk实例上root用户的交互式shell，方法是使用SSH公钥身份验证作为普通用户kiosk登录，在运行sudo -i命令获取root用户的shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> -i</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="配置Sudo"><a href="#配置Sudo" class="headerlink" title="配置Sudo"></a>配置Sudo</h2><p>​	&#x2F;etc&#x2F;sudoers文件是sudo命令的主要配置文件。如果多个管理员试图编辑该文件，为了避免出现问题，您只能特殊的visudo命令进行编辑。visudo编辑器也会验证该文件，确保没有语法错误。</p>
<p>​	例如，以下来自&#x2F;etc&#x2F;sudoers文件的这一行可为wheel组成员启用sudo访问权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>

<ul>
<li>%wheel字符串是规则所应用到的用户或组。词语wheel前的%符号指定该是对一个组进行权限的设置。</li>
<li>ALL&#x3D;(ALL:ALL)命令指定在具有此文件的任何主机上（第一个ALL），wheel组中的用户可以在系统上以任何其他用户（第二个ALL）和任何其他组（第三个ALL）运行命令。</li>
<li>最后的ALL命令指定wheel组中的用户可以运行任何命令。</li>
</ul>
<p>​	默认情况下，&#x2F;etc&#x2F;sudoers文件还包含&#x2F;etc&#x2F;sudoers.d目录中所有文件的内容，作为配置文件的一部分。通过使用这种层次结构，您只需将相应的文件放入该目录中，即可为用户添加sudo访问权限。</p>
<p>​	<code>注意：将配置文件放在/etc/sudoers.d目录下比较方便。将文件复制到目录中或从目录中删除文件，即可启用或禁用sudo访问权限。通常每个文件都会以用户或组来进行命名，当要启用或是禁用时，只需将文件在该目录中复制或删除即可。避免一个文件长篇大论，难以维护</code></p>
<p>​	要为redhat01用户启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;redhat01文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /etc/sudoers.d/redhat01 </span><br><span class="line">redhat01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要为group01组启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;group01文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/group01</span><br><span class="line">%group01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要使games组中的用户能够以operator用户身份运行id命令，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;games文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/games</span><br><span class="line">%games ALL=(operator) /bin/id</span><br></pre></td></tr></table></figure>

<p>​	此外，也可以设置sudo，以允许用户通过使用NOPASSWD:ALL命令在不输入密码的前提下以其他用户身份允许命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/ansible</span><br><span class="line">%ansible ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p>​	虽然授权用户或组这种级别的访问权限存在明显的安全风险，但系统会将这种做法用于云实例、虚拟机和调配系统，以配置服务器。您必须谨慎地保护具有此访问权限的账户，并且要求使用SSH公钥身份验证，以便远程系统上的用户能访问它。</p>
<h1 id="管理本地用户账户"><a href="#管理本地用户账户" class="headerlink" title="管理本地用户账户"></a>管理本地用户账户</h1><h2 id="从命令行创建用户"><a href="#从命令行创建用户" class="headerlink" title="从命令行创建用户"></a>从命令行创建用户</h2><p>​	useradd username命令可以创建名为username的用户。它会设置用户的主目录和账户信息，并为名为username的用户创建一个私有组。此时，该账户尚未设置有效密码，用户也要设置了密码后才能登录。</p>
<p>​	useradd –help 命令将显示可用于覆盖默认设置的基本选项。大多数情形中，您可以将相同的选项用于usermod命令，以修改现有用户。</p>
<p>​	在红帽linux9中，useradd命令为新用户分配的第一个大于或等于1000的可用UID，除非您通过-u选项进行明确指定。</p>
<h2 id="从命令行修改现有的用户"><a href="#从命令行修改现有的用户" class="headerlink" title="从命令行修改现有的用户"></a>从命令行修改现有的用户</h2><p>​	usermod –help命令显示用于修改账户的基本选项。一些常见的选项如下：</p>
<table>
<thead>
<tr>
<th>usermod选项</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>-a，–append</td>
<td>与-G选项一起使用，将补充组添加到用户当前的组成员集合中，而不是将补充组集合替换为新的集合。</td>
</tr>
<tr>
<td>-c，–comment COMMENT</td>
<td>将COMMENT文本添加到注释字段。</td>
</tr>
<tr>
<td>-d，–home HOME_DIR</td>
<td>为用户账户指定一个主目录。</td>
</tr>
<tr>
<td>-g， –gid GROUP</td>
<td>为用户账户指定主要组。</td>
</tr>
<tr>
<td>-G，–groups GROUPS</td>
<td>为用户账户指定补充组，多个补充组用逗号分割列表。</td>
</tr>
<tr>
<td>-L， –lock</td>
<td>锁定用户账户。</td>
</tr>
<tr>
<td>-m，–move-home</td>
<td>将用户的主目录移送到新的位置。您必须将它于-d选项搭配使用。</td>
</tr>
<tr>
<td>-s，–shell SHELL</td>
<td>为用户账户指定特定的登录shell。</td>
</tr>
<tr>
<td>-U，–unlock</td>
<td>解锁用户账户。</td>
</tr>
</tbody></table>
<h2 id="从命令行删除用户"><a href="#从命令行删除用户" class="headerlink" title="从命令行删除用户"></a>从命令行删除用户</h2><p>​	userdel username 命令从&#x2F;etc&#x2F;passwd中删除用户的详细信息，但用户的主目录保持不变。userdel -r username 命令从&#x2F;etc&#x2F;passwd 中删除用户，同时删除用户的主目录。</p>
<p>​	<code>警告：如果您在不指定userdel -r 选项的情况下删除用户，则用户的文件归为未分配的UID所有。如果您创建了一个用户，并且该用户被分配了已删除用户的UID，则新账户将用有这些文件，这存在安全风险。通常，组织安全策略不允许删除用户账户，而是锁定它们不被使用，以避免这种情况。</code></p>
<p>​	以下示例演示了这如何导致信息泄露：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 kiosk]# useradd user01</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3 user01   user01     78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">[root@foundation0 ~]# userdel user01 </span><br><span class="line"><span class="comment"># 为加-r选项，此时用户的主目录处于未分配状态，他之前所属用户UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 创建用户，-u 指定该用户的UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user02</span><br><span class="line"><span class="comment"># 由于于之前的user01的UID一致，user01的主目录则自动归属为user02</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 10:57 user01</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 11:02 user02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>请注意，user02现在拥有之前归为user01所属的所有文件。root用户可以使用find / -nouser -o -nogroup 命令来查找无人拥有的文件和目录。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# userdel user02 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 11:02 user02</span><br><span class="line"><span class="comment"># nouser表示没有归属用户的条件，nogroup表示没有归属用户的组，-o选项表示【或】的意思，用于多个条件的拼接</span></span><br><span class="line">[root@foundation0 ~]# find / -nouser -o -nogroup </span><br><span class="line">...忽略...</span><br><span class="line">/home/user01/.mozilla</span><br><span class="line">/home/user01/.mozilla/extensions</span><br><span class="line">/home/user01/.mozilla/plugins</span><br><span class="line">/home/user01/.bash_logout</span><br><span class="line">/home/user01/.bash_profile</span><br><span class="line">/home/user01/.bashrc</span><br><span class="line">/home/user02</span><br><span class="line">....忽略....</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="从命令行设置密码"><a href="#从命令行设置密码" class="headerlink" title="从命令行设置密码"></a>从命令行设置密码</h2><p>​	passwd username 命令可为username用户设置初始密码，或更改其现有密码。root用户可以将密码设置为任何值。如果密码不符合最低建议标准，终端会显示消息；不顾哦，之后您可以重新键入该新密码，passwd也会成功更新该密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user01</span><br><span class="line">useradd: warning: the home directory /home/user01 already exists.</span><br><span class="line">useradd: Not copying any file from skel directory into it.</span><br><span class="line">Creating mailbox file: File exists</span><br><span class="line"><span class="comment"># 为用户设置初始密码，密码：123456，虽会提示密码过于简单，未通过字典检查，但再次确认密码后任然可以成功设置。</span></span><br><span class="line">[root@foundation0 home]# passwd user01 </span><br><span class="line">Changing password <span class="keyword">for</span> user user01.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	<code>建议普通用户必须选择至少八个字符长的密码。不要使用字典词语、用户名或旧密码。</code></p>
<h2 id="UID范围"><a href="#UID范围" class="headerlink" title="UID范围"></a>UID范围</h2><ul>
<li>UID 0：超级用户(root)账户UID。</li>
<li>UID 1-200：静态分配给系统进程的系统账户UID。</li>
<li>UID 201-999：分配给不拥有此系统上文件的系统进程的UID。需要非特权UID的软件将从这个可用池中动态分配UID。</li>
<li>UID 1000+：分配给普通非特权用户的UID范围。</li>
</ul>
<p>注意：RedHat6及更早的版本对系统用户使用的范围1-499的UID，对普通用户使用高于500的UID。您可以在&#x2F;etc&#x2F;login.defs文件中更改useradd和groupadd默认范围。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250513112428467.png" alt="image-20250513112428467"></p>
<h1 id="管理本地组账户"><a href="#管理本地组账户" class="headerlink" title="管理本地组账户"></a>管理本地组账户</h1><h2 id="从命令行创建组"><a href="#从命令行创建组" class="headerlink" title="从命令行创建组"></a>从命令行创建组</h2><p>​	groupadd命令用于创建组。不带选项时，groupadd命令会使用&#x2F;etc&#x2F;login.defs文件中通过GID_MIN和GID_MAX 变量指定的范围内的下一个可用GID。默认情况下，该命令分配的GID值大于任何其他现有的GID，即使有较低的值可用。</p>
<p>​	groupadd 命令 -g选项指定该组使用的特定GID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupadd -g 10000 group1</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">....忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：由于创建用户时会自动为该用户生成一个私有组（GID 1000+），一些管理员会留出了一个单独的GID范围，用于创建补充组来满足其目的。但是，这种额外的管理是不必要的，因为用户的UID和主要组GID是不需要是相同的数字。</code></p>
<p>​	groupadd 命令 -r 选项用于创建系统组。与普通一样，系统组使用&#x2F;etc&#x2F;login.defs文件中列出的有效系统GID范围内的GID。&#x2F;etc&#x2F;login.defs文件中的SYS_GID_MIN和SYS_GID_MAX配置项定义系统GID的范围。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group2:x:976:</span><br></pre></td></tr></table></figure>



<h2 id="从命令行修改现有的组"><a href="#从命令行修改现有的组" class="headerlink" title="从命令行修改现有的组"></a>从命令行修改现有的组</h2><p>​	groupmod 命令可以更改现有组的属性。groupmod命令-n选项可指定组的新名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -n group002 group2 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:976:</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	注意组名称从group2更改为group002，groupmod命令-g选项可更改GID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -g 975 group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:975:</span><br></pre></td></tr></table></figure>

<p>​	注意GID从原来的976变更为975.</p>
<h2 id="从命令行删除组"><a href="#从命令行删除组" class="headerlink" title="从命令行删除组"></a>从命令行删除组</h2><p>​	groupdel 命令可删除组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupdel group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：如果删除的组是现有用户的主要组，则您无法删除它。于使用userdel命令类似，首先检查以确保找到该组拥有的文件，避免信息泄露</code></p>
<h2 id="从命令行更改组成员资格"><a href="#从命令行更改组成员资格" class="headerlink" title="从命令行更改组成员资格"></a>从命令行更改组成员资格</h2><p>​	组成员资格通过用户管理进行控制。使用usermod -g命令来更改用户的主要组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01)</span><br><span class="line">[root@foundation0 home]# usermod -g group01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	使用usermod -aG命令，将用户太你家到某一补充组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# usermod -aG user01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01)</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：usermod命令的-a选项可启用附加模式。不带-a选项时，命令会从当前未包含在 -G 选项列表中的任何补充组从该用户中删除。</code></p>
<h2 id="比较主要组和补充组成员资格"><a href="#比较主要组和补充组成员资格" class="headerlink" title="比较主要组和补充组成员资格"></a>比较主要组和补充组成员资格</h2><p>​	用户的主要组是在&#x2F;etc&#x2F;passwd文件中查看的用户账户和组。一个用户一次只能属于一个主要组。</p>
<p>​	用户的补充组是为用户配置的额外组，可在&#x2F;etc&#x2F;group文件中的用户条目中查看。一个用户可以属于任意数量的补充组，以有效实施文件访问和权限。</p>
<p>​	对于配置基于组的文件权限而言，用户的主要组和补充组之间没有区别。如果用户所属的组被分配了特定文件的访问权限，则该用户有权访问这些文件。</p>
<p>​	用户的主要组和补充组成员资格之间唯一的区别体现在用户创建文件时。新文件必须具有用户所有者和组所有者，这是在文件创建时分配的。用户的主要组用于新文件的组所有权，除非被选项命令覆盖。</p>
<h2 id="临时更改您的主要组"><a href="#临时更改您的主要组" class="headerlink" title="临时更改您的主要组"></a>临时更改您的主要组</h2><p>​	只有用户的主要组才会用于新文件创建属性。但是，您可以暂时将主要组切换到另一个组，但只能从您所属的补充组中去选择。如果您要手动或以脚本方式创建多个新文件，并希望创建时将不通的组分配为所有者，则可以切换组。</p>
<p>​	在此shell会话中，使用newgrp命令来切换主要组。您可以在所属的任何主要组或补充组之间却换，但一次只能由一个组是主要组。如果您注销并重新登录，主要组将回复为默认值。此示例将user01用户中的补充组user01临时切换为主要组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[user01@foundation0 ~]$ newgrp </span><br><span class="line">group1  user01  </span><br><span class="line">[user01@foundation0 ~]$ newgrp user01 </span><br><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01),10000(group1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="管理用户密码"><a href="#管理用户密码" class="headerlink" title="管理用户密码"></a>管理用户密码</h1><h2 id="影子密码和密码策略"><a href="#影子密码和密码策略" class="headerlink" title="影子密码和密码策略"></a>影子密码和密码策略</h2><p>​	加密的密码最初存储在全局可读的&#x2F;etc&#x2F;passwd文件中。这曾认为是最妥善的，直到对加密密码的字典式攻击变得常见。加密后的密码已移至&#x2F;etc&#x2F;shadow文件，只有root用户可以读取该文件。</p>
<p>​	与&#x2F;etc&#x2F;passwd文件一样，每个用户在&#x2F;etc&#x2F;shadow文件中都有一个条目。&#x2F;etc&#x2F;shadow文件中的示例条目具有九个以冒号分割的字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redhat01:$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0:20195:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>​	以此代码块为例，每个字段用冒号分割：</p>
<ul>
<li>redhat01：用户账户名称。</li>
<li>$6$N4i94UcIEydv…省略：用户的加密密码，$6开头（SHA-512）加密。</li>
<li>20195：上次更改密码时间距离纪元的天数；纪元是UTC时区的1970-01-01。</li>
<li>0：自上次更改密码以来到用户可再次更改密码之前必须经过的最短天数。</li>
<li>99999：在密码过期之前不进行密码更改的最长天数。空字段表示密码永不过期，自最后一次修改密码截至多少天过期。</li>
<li>7：在密码过期前提前多少天警告用户。</li>
<li>空：自密码过期之日起，在账户自动锁定前能够活动的天数，宽限天数。</li>
<li>空：密码到期之日距离纪元的天数。空字段表示密码永不过期，密码过期天数。</li>
<li>空：保留字段，预留给未来使用。</li>
</ul>
<h2 id="加密密码的格式"><a href="#加密密码的格式" class="headerlink" title="加密密码的格式"></a>加密密码的格式</h2><p>​	加密密码字段中存储了三段信息：所用的哈希算法、salt及加密哈希值。每段信息由美元符号（$）字符分割。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0</span><br></pre></td></tr></table></figure>

<ul>
<li>$6：此密码所使用的哈希算法。6表示SHA-512,这是RedHat默认算法；1表示MD5，而5则表示SHA-256。</li>
<li>$N4i94UcIEydvTFzp：用于加密密码的salt；最初是随机选择的。</li>
<li>$pf9W0C4I6w4BFxyK&#x2F;ver…忽略：用户密码的加密后的哈希；将salt和未加密密码组合并加密，生成密码哈希。</li>
</ul>
<p>​	将salt与密码组合的主要原因是为了防止使用预先计算的密码哈希列表攻击。添加salt会改变生成的哈希值，使预先计算的列表毫无用处。如果攻击者获得了使用salt的&#x2F;etc&#x2F;shadow文件的副本，则它们需要通过暴力破解来猜测密码，这将花费更多的时间和精力。</p>
<h2 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h2><p>​	用户尝试登录时，系统在&#x2F;etc&#x2F;shadow文件中查询用户的条目，将用户的salt和键入的未加密密码组合，在使用制定的哈希算法加密组合。如何加密组合后的结果与已加密的哈希匹配，则用户键入了正确的密码。如果结果与已加密的密码不符合，则用户键入了错误的密码，登录尝试也会失败。这种方式允许系统半段用户是否键入了正确的密码，同时又不以用于登录的密码形式来存储密码。</p>
<h2 id="配置密码期限"><a href="#配置密码期限" class="headerlink" title="配置密码期限"></a>配置密码期限</h2><p>​	下图显示了相关的密码期限参数，可以通过chage命令对起调整实施密码期限策略。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250520145616305.png" alt="image-20250520145616305"></p>
<p>​	以下示例演示使用chage命令修改redhat01用户的密码策略。该命令定义密码修改间隔最短期限（-m）为0天，密码最长有效期（-M）为90天，警告期（-W）7天，以及过期后宽限（-I）14天后自动过期为不活动状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -m 0 -M 90 -W 7 -I 14 redhat01</span><br><span class="line">[root@foundation0 ~]# chage -l redhat01 </span><br><span class="line">Last password change					: Apr 17, 2025</span><br><span class="line">Password expires					: Jul 16, 2025</span><br><span class="line">Password inactive					: Jul 30, 2025</span><br><span class="line">Account expires						: never</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 90</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	假设您在RedHat上管理用户密码策略。user01用户是系统中的新用户，您要设置自定义密码期限策略。您希望将账户的到期之间设置为，即日起30天后到期，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> +%F</span><br><span class="line">2025-05-20</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F</span><br><span class="line">2025-06-19</span><br><span class="line">[root@foundation0 ~]# chage -E $(<span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F) user01</span><br><span class="line">[root@foundation0 ~]# chage -l user01 | grep <span class="string">&quot;Account expires&quot;</span></span><br><span class="line">Account expires						: Jun 19, 2025</span><br></pre></td></tr></table></figure>

<ul>
<li>使用date命令获取当前时间，并通过+%F选项，调整date命令输出的日期格式。</li>
<li>使用date命令的-d选项以及“+30 days”参数获取即日起30天后的日期，并转换日期格式。</li>
<li>使用chage命令的-E选项，将获得的截至日期作为参数赋予该选项。</li>
<li>使用chage命令的-l选项，并且通过grep命令筛选出命令输出结果中的“Account expires”行，最终查看user01用户的过期时间成功设置为30天后。</li>
</ul>
<p>​	几天后，您在&#x2F;var&#x2F;log&#x2F;secure日志文件中发现user01用户有一个奇怪的行为。用户尝试使用sudo与其他用户的文件交互。您怀疑用户可能忘记关闭在另一台计算机上工作时打开的ssh会话。您希望user01用户在下次登录时更改密码，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -d 0 user01 </span><br><span class="line">[root@foundation0 ~]# chage -l user01</span><br><span class="line">Last password change					: password must be changed</span><br><span class="line">Password expires					: password must be changed</span><br><span class="line">Password inactive					: password must be changed</span><br><span class="line">Account expires						: Jun 19, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	此时user01的密码策略中提示，用户必须修改密码的结果，下次用户登录时就必须要求修改密码了。</p>
<p>​	<code>注意：date命令可以计算未来的时间。-u选项报告UTC时间。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# date -d &quot;+5 days&quot; -u +%F</span><br><span class="line">2025-05-25</span><br></pre></td></tr></table></figure>

<p>​	您可以在&#x2F;etc&#x2F;login.defs文件中更改默认密码期限配置。PASS_MAX_DAYS和PASS_MIN_DAYS选项分别设置密码的默认最长和最短期限。PASS_WARN_AGE设置密码的默认警告期限。默认密码期限策略中的任何更改都会影响更改后新创建的用户。现有用户继续使用就密码期限设置，而非新密码设置。</p>
<h2 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h2><p>​	您可以使用usermod命令来修改用户的账户到期日期。例如，usermod命令-L选项可锁定用户账户，并且该用户无法登录系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L user03</span><br><span class="line">[kiosk@foundation0 ~]$ su - user03 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br></pre></td></tr></table></figure>

<p>​	如果用户在特定日期从公司离职，您可以通过usermod命令锁定并使其到期。该日期必须是从1970-01-01的天开始算起，或者使用YYYY-MM-DD格式。以下示例中，usermod命令于2025-05-21锁定user03用户并使其过期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L -e 2025-05-21 user03 </span><br><span class="line">[root@foundation0 ~]# chage -l user03 </span><br><span class="line">Last password change					: May 20, 2025</span><br><span class="line">Password expires					: never</span><br><span class="line">Password inactive					: never</span><br><span class="line">Account expires						: May 21, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	账户锁定后，您可以防止用户使用密码向系统进行验证。简易使用此方法防止前员工访问账户。使用usermod命令-U选项可以重新启用账户的访问权限。</p>
<h2 id="非登录Shell"><a href="#非登录Shell" class="headerlink" title="非登录Shell"></a>非登录Shell</h2><p>​	nologin shell用作不打算以交互方式登录系统的用户账户的代替shell。从安全角度来看，在账户不需要登录系统时，禁止账户登录系统是一个明智的选择。例如，邮件服务器可能需要账户来存储邮件，需要密码供用户通过检索邮件所用的邮件客户端进行身份验证。用户不需要直接登录该系统。</p>
<p>​	这种情况的常用解决方案是将用户的登录shell设置为&#x2F;sbin&#x2F;nologin。如果用户试图直接登录系统，nologin shell将关闭该连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -s /sbin/nologin user03 </span><br><span class="line">[root@foundation0 ~]# su - user03</span><br><span class="line">Last login: Tue May 20 14:49:37 CST 2025 on pts/0</span><br><span class="line">Last failed login: Tue May 20 14:51:02 CST 2025 on pts/0</span><br><span class="line">There were 4 failed login attempts since the last successful login.</span><br><span class="line">This account is currently not available.</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：nologin shell可以防止以交互式使用系统，但不会阻止访问。如果用户使用密码进行身份验证，它们有时可以通过身份验证，并使用web应用、文件传输程序或邮件读取程序等应用上传或检索文件。</code></p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
</search>
