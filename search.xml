<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7.9搭建SoftEtherVPN</title>
    <url>/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/</url>
    <content><![CDATA[<center><font size="7">Centos7.9搭建SoftEtherVPN</font></center>







<h1 id="为什么要使用SoftEtherVPN？"><a href="#为什么要使用SoftEtherVPN？" class="headerlink" title="为什么要使用SoftEtherVPN？"></a>为什么要使用SoftEtherVPN？</h1><p>​	在日常工作中，我们的企业应用都是存放在内网，当遇到紧急情况需要处理服务故障或其他事情时，跑到现场是令人头疼的事情，来回花费的时间系统故障恢复响应速度会造成不可估量的损失。</p>
<p>​	因此我们就需要一个能让我有台电脑随时随地能访问到内网服务的东西，这就叫做VPN。</p>
<p>​	虚拟专用网络（英文：Virtual Private Network），简称虚拟专网（VPN），其主要功能是在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现。</p>
<p>​	让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>
<h1 id="SoftEtherVPN搭建"><a href="#SoftEtherVPN搭建" class="headerlink" title="SoftEtherVPN搭建"></a>SoftEtherVPN搭建</h1><p>​	接下来我们就开始搭建一个属于自己的VPN工具，能让我们在日常工作中减轻大量的负担，为了很好的演示这个服务，本次博主将斥巨资购买一台海外服务器，作为本教程章节。</p>
<h2 id="云服务购买详情"><a href="#云服务购买详情" class="headerlink" title="云服务购买详情"></a>云服务购买详情</h2><p>​	国内有很多云服务厂商，例如我们常知道的：华为云、阿里云、腾讯云、亚马逊等主流云平台厂商。本次将采用在阿里云给大家进行演示。</p>
<p>​	<strong>阿里云官网：<a href="https://www.aliyun.com/activity/1111/2025?utm_content=se_1022108959">https://www.aliyun.com/activity/1111/2025?utm_content=se_1022108959</a></strong></p>
<p>​	进入到阿里云官网后，需要先进行一个登录，拥有一个自己的账号。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106100335424.png" alt="image-20251106100335424"></p>
<p>​	搜索框搜索【ECS弹性云服务器】，进入到该界面后，点击【立即购买】。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106103351454.png" alt="image-20251106103351454"></p>
<p>​	进入到【快速购买】界面，选择您怼云服务器的基础配置要求，重点是【付费类型】如果您是长期稳定的项目建议采用包年包月，以及宽带计费也是如此，如果您的业务量较小，也可以采用【按量付费】，按量的计费价格大概在：云服务器：1小时&#x3D;0.1-0.8元左右的价格，流量则是：0.5&#x3D;1GB的价格。</p>
<p>​	选择好配置后下单即可。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106103648648.png" alt="image-20251106103648648"></p>
<p>​	我之前是以及下单过了的，我采用的计费方式是按量计费，您可根据您的实际业务来选择最优惠的方案。</p>
<p>​	下完单后您就拥有了自己的服务器了，点击控制台，进去当服务实例。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106104116301.png" alt="image-20251106104116301"></p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106104155090.png" alt="image-20251106104155090"></p>
<p>​	根据如下图，了解大概的云服务列表，以及服务器密码重置，远程连接等操作。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106104708035.png" alt="image-20251106104708035"></p>
<p>​	进入到【网络与安全组】，由于服务对外是443端口，当然您也可以设置成其他的，您需要对安全组规则进行设置放行，否则公网外无法访问到您的这个端口，会被拦截掉的。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106105047030.png" alt="image-20251106105047030"></p>
<p>​	到这云服务器的基本配置就够了， 接下来看我们要进行具体的搭建环节了。</p>
<h2 id="部署SoftEtherVPN"><a href="#部署SoftEtherVPN" class="headerlink" title="部署SoftEtherVPN"></a>部署SoftEtherVPN</h2><p>​	首先我们需要先进入到如下官网，分别下载服务端、管理端、客户端。</p>
<p>​	SoftEtherVPN官网**<a href="http://www.softether.org/5-download">http://www.softether.org</a>**</p>
<ul>
<li>服务端：用于接收客户端的连接请求及流量数据转发等功能。</li>
<li>管理端：用于管理如用户账号、虚拟HUB等。</li>
<li>客户端：用户客户主机连接服务端，请求访问外部网络。</li>
</ul>
<p>​	进入官网后，点击Download，选择Download SoftEther VPN进到下载界面。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106110159331.png" alt="image-20251106110159331"></p>
<p>​	这里我们分别要下载这三个组件。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106110426984.png" alt="image-20251106110426984"></p>
<p>​	具体选择可参考下图。</p>
<p>​	服务端是在Linux系统搭建的，所有我们这里选择Linux版本的进行下载，并且我们服务器是intel 64位的，这里请根据自己的服务器进行相应的版本选择。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106110613434.png" alt="image-20251106110613434"></p>
<p>​	管理端后客户端我们都在我们自己的Windows电脑上进行管理和使用，所以都选择Windows版本。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106110806647.png" alt="image-20251106110806647"></p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106110856309.png" alt="image-20251106110856309"></p>
<p>​	下载完成后，将服务端的压缩包上传到服务器并进行解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ ~]# ll</span><br><span class="line">total 8208</span><br><span class="line">-rw-r--r-- 1 root root 8400628 Nov  5 20:50 softether-vpnserver-v4.44-9807-rtm-2025.04.16-linux-x64-64bit.tar.gz</span><br><span class="line">drwxrwxrwx 9 root root    4096 Nov  6 11:08 vpnserver</span><br><span class="line">[root@iZrj996egor2taj2i6x23sZ ~]# tar -zxvf softether-vpnserver-v4.44-9807-rtm-2025.04.16-linux-x64-64bit.tar.gz</span><br></pre></td></tr></table></figure>

<p>​	解压完成后，进入到解压目录，进行程序编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ ~]# <span class="built_in">cd</span> vpnserver/</span><br><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# make</span><br></pre></td></tr></table></figure>

<p>​	编译完成后执行如下命令，启动VPN程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# ./vpnserver start</span><br></pre></td></tr></table></figure>

<p>​	启动完成后，执行如下命令，进入控制台。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# ./vpncmd</span><br><span class="line">vpncmd <span class="built_in">command</span> - SoftEther VPN Command Line Management Utility</span><br><span class="line">SoftEther VPN Command Line Management Utility (vpncmd <span class="built_in">command</span>)</span><br><span class="line">Version 4.44 Build 9807   (English)</span><br><span class="line">Compiled 2025/04/16 04:50:46 by buildsan at crosswin with OpenSSL 3.0.9</span><br><span class="line">Copyright (c) 2012-2025 SoftEther VPN Project. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">By using vpncmd program, the following can be achieved. </span><br><span class="line"></span><br><span class="line">1. Management of VPN Server or VPN Bridge </span><br><span class="line">2. Management of VPN Client</span><br><span class="line">3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</span><br><span class="line"></span><br><span class="line">Select 1, 2 or 3: 1【选择1】</span><br><span class="line"></span><br><span class="line">Specify the host name or IP address of the computer that the destination VPN Server or VPN Bridge is operating on. </span><br><span class="line">By specifying according to the format <span class="string">&#x27;host name:port number&#x27;</span>, you can also specify the port number. </span><br><span class="line">(When the port number is unspecified, 443 is used.)</span><br><span class="line">If nothing is input and the Enter key is pressed, the connection will be made to the port number 8888 of localhost (this computer).</span><br><span class="line">Hostname of IP Address of Destination: 【默认回车443，当然您也可以修改】</span><br><span class="line"></span><br><span class="line">If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name. </span><br><span class="line">If connecting by server admin mode, please press Enter without inputting anything.</span><br><span class="line">Specify Virtual Hub Name: 【默认回车】</span><br><span class="line"></span><br><span class="line">Connection has been established with VPN Server <span class="string">&quot;localhost&quot;</span> (port 443).</span><br><span class="line"></span><br><span class="line">You have administrator privileges <span class="keyword">for</span> the entire VPN Server.</span><br><span class="line"></span><br><span class="line">VPN Server&gt; ServerPasswordSet 【执行该命令设置管理员密码】</span><br><span class="line"></span><br><span class="line">密码    : ***     <span class="comment">#123【密码可自由设置】</span></span><br><span class="line">确认输入: ***  　　<span class="comment">#123【密码可自由设置】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令成功完成。</span><br><span class="line">VPN Server&gt; HubCreate  HUB   　　　　【创建一个HUB】</span><br><span class="line"></span><br><span class="line">密码    : ***    <span class="comment">#123【密码可自由设置】</span></span><br><span class="line">确认输入: ***     <span class="comment">#123【密码可自由设置】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br><span class="line">VPN Server&gt;<span class="built_in">exit</span>   【退出】</span><br></pre></td></tr></table></figure>

<p>​	查看443端口是否正常启用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# netstat -atunp | grep 443</span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      2056/vpnserver      </span><br><span class="line">tcp        0      0 172.27.167.62:443       111.121.105.13:5806     ESTABLISHED 2056/vpnserver      </span><br><span class="line">tcp        0      0 172.27.167.62:443       111.121.105.13:7722     ESTABLISHED 2056/vpnserver      </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      2056/vpnserver</span><br></pre></td></tr></table></figure>

<p>​	关闭防火墙。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# systemctl stop firewalld.service</span><br><span class="line">[root@iZrj996egor2taj2i6x23sZ vpnserver]# systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>安装好客户端和管理端。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106112007112.png" alt="image-20251106112007112"></p>
<p>打开VPN管理端工具，有默认连接的点编辑没有就新建连接。</p>
<ul>
<li>主机名：填写您服务端的公网IP。</li>
<li>端口：默认就是443，如您有修改请填写您修改后的端口号。</li>
<li>虚拟HUB名及密码：上诉创建的HUB用户名、密码是当时设置的VPN管理员密码。</li>
</ul>
<p>​	确认无误后点击确定后进行连接。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106112219571.png" alt="image-20251106112219571"></p>
<p>​	进入【管理虚拟HUB】界面。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106113406783.png" alt="image-20251106113406783"></p>
<p>​	进入到用户管理，建立Vpn客户账户</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150115484.png" alt="image-20251106150115484"></p>
<p>​	设置用户名和密码，点击完成即可。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150208108.png" alt="image-20251106150208108"></p>
<p>​	返回到这个界面，启动NAT。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150246951.png" alt="image-20251106150246951"></p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150307674.png" alt="image-20251106150307674"></p>
<p>​	这样就完成了整个VPN的搭建了。</p>
<h1 id="连接VPN"><a href="#连接VPN" class="headerlink" title="连接VPN"></a>连接VPN</h1><p>​	打开Client客户端，点击</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150702940.png" alt="image-20251106150702940"></p>
<p>​	建立连接。</p>
<ul>
<li>主机名：您的公网IP。</li>
<li>端口：默认443。</li>
<li>需你HUB名：之前设置的是HUB。如设置了其他的请如实填写。</li>
<li>用户名、密码：管理端维护的用户名和密码。</li>
</ul>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106150813652.png" alt="image-20251106150813652"></p>
<p>​	最后双击或右键点击连接即可。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106151055323.png" alt="image-20251106151055323"></p>
<p>​	连接信息中弹出我们获取到了服务端分配给我们的内网IP，之后我们就可以愉快玩耍了。</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106151133699.png" alt="image-20251106151133699"></p>
<p>​	这里我随便访问一个原本我访问不到的网址。</p>
<p>​	完美访问运行，就问你哈布哈拉少，祝我们都越学越刑！！！！</p>
<p><img src="/2025/11/06/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Centos7.9%E6%90%AD%E5%BB%BASoftEtherVPN/image-20251106152745578.png" alt="image-20251106152745578"></p>
]]></content>
      <categories>
        <category>Linux常见问题</category>
      </categories>
      <tags>
        <tag>Linux常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux根目录磁盘扩容</title>
    <url>/2025/05/20/02-Linux%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/Linux%E6%A0%B9%E6%8C%82%E8%BD%BD%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="Linux根目录磁盘扩容"><a href="#Linux根目录磁盘扩容" class="headerlink" title="Linux根目录磁盘扩容"></a>Linux根目录磁盘扩容</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>假设目前我们的根目录磁盘使用率已达到100%，此刻我们的磁盘总容量为95G，并且通过lsblk发现了我新插入，即将要用于扩容到根目录的50G磁盘【nvme0n2】，环境已具备，即将开始扩容操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前根目录磁盘使用情况</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">df</span> -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs               4.0M     0  4.0M    0% /dev</span><br><span class="line">tmpfs                  1.9G     0  1.9G    0% /dev/shm</span><br><span class="line">tmpfs                  777M  9.8M  767M    2% /run</span><br><span class="line">/dev/mapper/rhel-root   95G  4.9G   90G    6% /</span><br><span class="line">/dev/nvme0n1p2         960M  264M  697M   28% /boot</span><br><span class="line">/dev/nvme0n1p1         599M  7.1M  592M    2% /boot/efi</span><br><span class="line">tmpfs                  389M   52K  389M    1% /run/user/42</span><br><span class="line">tmpfs                  389M  100K  389M    1% /run/user/0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前服务器盘符使用情况</span></span><br><span class="line">[root@localhost ~]# lsblk </span><br><span class="line">NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sr0            11:0    1 1024M  0 rom  </span><br><span class="line">nvme0n1       259:0    0  100G  0 disk </span><br><span class="line">├─nvme0n1p1   259:1    0  600M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p2   259:2    0    1G  0 part /boot</span><br><span class="line">└─nvme0n1p3   259:3    0 98.4G  0 part </span><br><span class="line">  ├─rhel-root 253:0    0 94.5G  0 lvm  /</span><br><span class="line">  └─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]</span><br><span class="line">nvme0n2       259:4    0   50G  0 disk</span><br></pre></td></tr></table></figure>



<h3 id="根目录磁盘扩容"><a href="#根目录磁盘扩容" class="headerlink" title="根目录磁盘扩容"></a>根目录磁盘扩容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为新磁盘创建一个分区，p（主分区）、默认回车、w（退出并保存分区）</span></span><br><span class="line">[root@localhost ~]# fdisk /dev/nvme0n2 </span><br><span class="line"></span><br><span class="line">欢迎使用 fdisk (util-linux 2.37.4)。</span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">设备不包含可识别的分区表。</span><br><span class="line">创建了一个磁盘标识符为 0x31c8cf52 的新 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">分区类型</span><br><span class="line">   p   主分区 (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)：p</span><br><span class="line">分区号 (1-4, 默认  1): </span><br><span class="line">第一个扇区 (2048-104857599, 默认 2048): </span><br><span class="line">最后一个扇区，+/-sectors 或 +size&#123;K,M,G,T,P&#125; (2048-104857599, 默认 104857599): </span><br><span class="line"></span><br><span class="line">创建了一个新分区 1，类型为“Linux”，大小为 50 GiB。</span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 查看分区是否创建成功，新分区名称为【nvme0n2p1】</span></span><br><span class="line">[root@localhost ~]# lsblk -f </span><br><span class="line">NAME          FSTYPE      FSVER    LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sr0                                                                                            </span><br><span class="line">nvme0n1                                                                                        </span><br><span class="line">├─nvme0n1p1   vfat        FAT32          C427-1A51                               591.8M     1% /boot/efi</span><br><span class="line">├─nvme0n1p2   xfs                        93d050f3-c57c-44e8-a059-c029b36cced1    696.4M    27% /boot</span><br><span class="line">└─nvme0n1p3   LVM2_member LVM2 001       k059oe-foEY-M2YG-cKsQ-YqYB-xHgk-S3b5cs                </span><br><span class="line">  ├─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  └─rhel-swap swap        1              18d4dd2e-af9f-4f75-b78b-a9335fda999d                  [SWAP]</span><br><span class="line">nvme0n2                                                                                        </span><br><span class="line">└─nvme0n2p1</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将新分区创建为PV</span></span><br><span class="line">[root@localhost dev]# pvcreate /dev/nvme0n2p1 </span><br><span class="line">  Physical volume <span class="string">&quot;/dev/nvme0n2p1&quot;</span> successfully created.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看PV是否创建成功，可以看到【nvme0n1p3】是我现在根磁盘用的90多G的容量，而【nvme0n2p1】是新加进来的50G容量</span></span><br><span class="line">[root@localhost dev]# pvs</span><br><span class="line">  PV             VG   Fmt  Attr PSize   PFree  </span><br><span class="line">  /dev/nvme0n1p3 rhel lvm2 a--   98.41g   4.00m</span><br><span class="line">  /dev/nvme0n2p1      lvm2 ---  &lt;50.00g &lt;50.00g</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询VG现有使用情况，可以看到VG空闲内容已经不够了</span></span><br><span class="line">[root@localhost dev]# vgs</span><br><span class="line">  VG    <span class="comment">#PV #LV #SN Attr   VSize   VFree  </span></span><br><span class="line">  rhel    1   2   0 wz--n-  98.41g   4.00m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为根磁盘的VG增加空闲容量，将新的PV容量增加到这个VG</span></span><br><span class="line">[root@localhost dev]# vgextend rhel /dev/nvme0n2p1 </span><br><span class="line">  Volume group <span class="string">&quot;rhel&quot;</span> successfully extended</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看vg扩容是否成功，VG已经从原先的98G变成了148G，空闲50G可用</span></span><br><span class="line">[root@localhost dev]# vgs</span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize    VFree </span></span><br><span class="line">  rhel   2   2   0 wz--n- &lt;148.41g 50.00g</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看VG剩余数据块有多少【Free  PE / Size       12800 / 50.00 GiB】剩余12800个数据块</span></span><br><span class="line">[root@localhost dev]# vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               rhel</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  4</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;148.41 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              37992</span><br><span class="line">  Alloc PE / Size       25192 / &lt;98.41 GiB</span><br><span class="line">  Free  PE / Size       12800 / 50.00 GiB</span><br><span class="line">  VG UUID               3mFZRu-uZbm-pyEC-xAp8-42Zj-rxjz-uClt98</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看现有LV容量大小，root（根磁盘容量）、swap（swap容量）</span></span><br><span class="line">[root@localhost dev]# lvs</span><br><span class="line">  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  root rhel -wi-ao---- &lt;94.49g                                                    </span><br><span class="line">  swap rhel -wi-ao----  &lt;3.92g</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩容LV，对【/dev/rhel/root】扩容，【-l +12800】 对该LV增加12800个数据块</span></span><br><span class="line"><span class="comment"># 或者也可用根据GiB来进行增加，则使用该命令【lvextend /dev/rhel/root -L +50GiB】</span></span><br><span class="line">[root@localhost dev]# lvextend /dev/rhel/root -l +12800 </span><br><span class="line">  Size of logical volume rhel/root changed from &lt;94.49 GiB (24189 extents) to &lt;144.49 GiB (36989 extents).</span><br><span class="line">  Logical volume rhel/root successfully resized.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看根目录是文件系统，可以看到，我们原先的和新增的磁盘分区都是xfs文件系统类型</span></span><br><span class="line">[root@localhost dev]# lsblk -f</span><br><span class="line">NAME          FSTYPE      FSVER    LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sr0                                                                                            </span><br><span class="line">nvme0n1                                                                                        </span><br><span class="line">├─nvme0n1p1   vfat        FAT32          C427-1A51                               591.8M     1% /boot/efi</span><br><span class="line">├─nvme0n1p2   xfs                        93d050f3-c57c-44e8-a059-c029b36cced1    696.4M    27% /boot</span><br><span class="line">└─nvme0n1p3   LVM2_member LVM2 001       k059oe-foEY-M2YG-cKsQ-YqYB-xHgk-S3b5cs                </span><br><span class="line">  ├─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  └─rhel-swap swap        1              18d4dd2e-af9f-4f75-b78b-a9335fda999d                  [SWAP]</span><br><span class="line">nvme0n2                                                                                        </span><br><span class="line">└─nvme0n2p1   LVM2_member LVM2 001       BK4L6G-1Lt3-FuPS-5UTS-R0bm-fTIC-f2F60g                </span><br><span class="line">  └─rhel-root xfs                        ab92f8e8-23f6-4944-b113-f4d1273dd2ad     89.6G     5% /</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重载文件系统：根据你的文件系统选择重载所使用的方式</span></span><br><span class="line"><span class="comment"># 1、xfs使用【xfs_growfs /dev/rhel/root】</span></span><br><span class="line"><span class="comment"># 2、ext使用【resize2fs /dev/rhel/root】</span></span><br><span class="line">[root@localhost dev]# xfs_growfs /dev/rhel/root </span><br><span class="line">meta-data=/dev/mapper/rhel-root  isize=512    agcount=4, agsize=6192384 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0</span><br><span class="line">data     =                       bsize=4096   blocks=24769536, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=16384, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 24769536 to 37876736</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看磁盘容量，此时根目录的文件大小则从原来的95变成了145G</span></span><br><span class="line">[root@localhost dev]# <span class="built_in">df</span> -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs               4.0M     0  4.0M    0% /dev</span><br><span class="line">tmpfs                  1.9G     0  1.9G    0% /dev/shm</span><br><span class="line">tmpfs                  777M  9.7M  768M    2% /run</span><br><span class="line">/dev/mapper/rhel-root  145G  5.3G  140G    4% /</span><br><span class="line">/dev/nvme0n1p2         960M  264M  697M   28% /boot</span><br><span class="line">/dev/nvme0n1p1         599M  7.1M  592M    2% /boot/efi</span><br><span class="line">tmpfs                  389M   52K  389M    1% /run/user/42</span><br><span class="line">tmpfs                  389M   36K  389M    1% /run/user/0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux常见问题</category>
      </categories>
      <tags>
        <tag>Linux常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第一章</title>
    <url>/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="初时微服务"><a href="#初时微服务" class="headerlink" title="初时微服务"></a>初时微服务</h1><p>​	在了解Kubernetes之前，我们需要先认识什么是微服务，并且它与传统的单体式架构的区别以及优劣处。</p>
<p>​	微服务它是将一个庞大的应用系统拆分成为多个小块的独立服务，再把这些独立的小块服务进行串联起来的一种架构设计，它是具有比传统架构：内聚更强，更加敏捷。</p>
<p>​	类似于蜂巢，将多个不同的服务聚合为一个功能强大的应用服务。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250605170824165.png" alt="image-20250605170824165"></p>
<h2 id="基于微服务的系统架构"><a href="#基于微服务的系统架构" class="headerlink" title="基于微服务的系统架构"></a>基于微服务的系统架构</h2><p>​	微服务的核心思路就是拆分。将单体项目的问题，通过把项目拆分为一个个小项目，如下图：</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250606110721445.png" alt="image-20250606110721445"></p>
<h2 id="传统单体架构VS微服务架构"><a href="#传统单体架构VS微服务架构" class="headerlink" title="传统单体架构VS微服务架构"></a>传统单体架构VS微服务架构</h2><p>​	例如一个电商系统，电商系统中具备着很多功能，比如：登录、人员账号、商品库存、订单、购物车等等，随着业务功能的迭代，项目的业务越来越复杂，开发人员越来越多，相应的开发、编译、部署、水平扩展等都会受到不同程度的限制。</p>
<p>​	传统架构中，你商城系统中所有的前端后端，以及所有的服务都部署在一台服务器上，那么这台服务器的性能要求就会随着你的业务复杂度，以及客户访问量急剧增加。如果系统中要对收藏功能进行更新，那么你需要提前发布公告对客户说明凌晨几点到早上几点将停机维护升级，这不光是对客户的体验感极度下降，同时我们的开发、运维等人员还要通宵达旦的对系统进行升级。</p>
<p>​	而在微服务架构中，它将功能拆分成多个不同的组件，一个功能对应一个组件，你的前端和后端是分离的，你的登录、人员账号、库存等等功能都是每个不同的组件，它们是秒级分别部署在不同的容器中，当你需要对收藏功能进行升级时，你只需要发布在某一时间段收藏夹功能暂不可用，但不会影响到你其他的业务，并且他的部署是秒级的，客户根本感受不到升级带来的影响，最有可能的也就是在的升级的同一秒，客户点击了这个功能，下一秒又恢复了，客户都只会认为是自己网络当时卡了一下。</p>
<p>​	下图是应用架构是发展史。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250605172934284.png" alt="image-20250605172934284"></p>
<table>
<thead>
<tr>
<th></th>
<th>单体架构</th>
<th>微服务架构</th>
</tr>
</thead>
<tbody><tr>
<td>迭代速度</td>
<td>较慢</td>
<td>快</td>
</tr>
<tr>
<td>部署频率</td>
<td>较慢不经常部署，部署风险高</td>
<td>经常发布，部署风险小</td>
</tr>
<tr>
<td>系统性能</td>
<td>吞吐量小</td>
<td>吞吐量大</td>
</tr>
<tr>
<td>系统扩展</td>
<td>扩展性差</td>
<td>扩展性强</td>
</tr>
<tr>
<td>技术栈多样性</td>
<td>单一、封闭</td>
<td>多样、开放</td>
</tr>
<tr>
<td>运维</td>
<td>简单</td>
<td>运维复杂</td>
</tr>
<tr>
<td>部署</td>
<td>容易部署</td>
<td>较难部署</td>
</tr>
<tr>
<td>架构复杂度</td>
<td>复杂度不高</td>
<td>复杂度高</td>
</tr>
<tr>
<td>查错</td>
<td>简单</td>
<td>定位问题困难</td>
</tr>
<tr>
<td>管理成本</td>
<td>主要用于开发成本</td>
<td>服务治理、运维</td>
</tr>
</tbody></table>
<h1 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h1><p>​	容器是一个可以将应用程序以指定格式打包并运行在一个操作系统相关联的环境种的方法，和虚拟机不同的是，容器并不会打包整个操作系统，而只打包允许该应用程序所必须的库和依赖设置等，这将使得容器具备高效率、轻量化、系统隔离性，以上特性将会确保无论在何处部署，容器内允许的应用都会保持完全一致，不会出现所谓的开发在他的环境没问题，但是到生产怎么就出现一堆异常的情况。</p>
<p>​	主流容器工具：Container、Docker、Podman……..</p>
<h2 id="传统应用部署痛点"><a href="#传统应用部署痛点" class="headerlink" title="传统应用部署痛点"></a>传统应用部署痛点</h2><p>​	在传统应用部署中，我们经常会遇到以下问题：</p>
<ul>
<li>环境不一致：导致开发环境中是没问题，但是应用到生产中可能会出现一堆奇奇怪怪的问题。</li>
<li>依赖管理复杂：例如该服务器上你将部署你的两类应用，应用一可能需要jdk1.6，应用二可能需要JDK1.8，这就导致一台服务器上两个应用需要的依赖版本不同，导致管理复杂，问题频出的情况。</li>
<li>资源利用率低：传统服务器或虚机需要一套完整的操作系统，占用大量的磁盘及内存等资源，但你的应用并不是每时每刻都需要着这么大的资源，这就导致资源大量时间处于空闲浪费状态。</li>
<li>部署复杂：部署多套应用时，每套应用你可能需要重复的手动部署虚机、配置环境、安装依赖等，花费时间长效率低切易出错。</li>
</ul>
<h2 id="容器化技术解决方案"><a href="#容器化技术解决方案" class="headerlink" title="容器化技术解决方案"></a>容器化技术解决方案</h2><p>​	容器化技术通过以下方式解决以上传统部署的通点：</p>
<ul>
<li>环境标准化：将开发环境中的最小操作系统及依赖等打包在一起，确保在任何一个环境中都能一致的运行。</li>
<li>轻量级：容器共享宿主机的操作系统内核及资源，比虚机机更轻量。</li>
<li>快速部署：容器可以在几秒内启动，大大提高部署、升级、重启效率，相对传统部署中的升级就是一次大型手术风险，容器化容错率和效率更为高效。</li>
<li>可移植：构建一次容器镜像，到处可运行。</li>
</ul>
<h2 id="容器化的核心理念"><a href="#容器化的核心理念" class="headerlink" title="容器化的核心理念"></a>容器化的核心理念</h2><p>​	容器化遵循“不氪变基础设施”的理念：</p>
<ul>
<li>应用和环境被打包成不可变的镜像</li>
<li>每次部署都使用相同的镜像</li>
<li>配置通过环境变量或配置文件注入</li>
<li>问题修复通过重构镜像而非修改运行中的容器</li>
</ul>
<h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><p><strong>镜像（image）</strong></p>
<p>​	<strong>定义</strong>：镜像是一个只读的模板，包含了运行应用所需的所有内容：代码、运行时、库文件、环境变量和配置文件。</p>
<p>​	<strong>特点</strong>：</p>
<ul>
<li><strong>分层存储</strong>：镜像由多个层组成，每一层代表一次修改。</li>
<li><strong>只读性</strong>：镜像本身是只读的，不能直接修改。</li>
<li><strong>可复用</strong>：同一个镜像可以创建多个容器。</li>
<li><strong>版本管理</strong>：通过标签（tag）进行版本管理</li>
</ul>
<p>类似与镜像就是一个安装程序或模板，它定义了应用运行的所需的一切，但本身是不可直接运行的。</p>
<p><strong>容器（container）</strong></p>
<p>​	<strong>定义</strong>：容器是镜像的运行实力，是一个轻量级、可移植的执行环境。</p>
<p>​	<strong>特点</strong>：</p>
<ul>
<li><strong>隔离性</strong>：每个容器都有自己的文件系统、网络和进程。</li>
<li><strong>临时性</strong>：容器可以被创建、启动、停止、删除。</li>
<li><strong>可写层</strong>：容器在镜像基础上添加了可写层。</li>
<li><strong>进程级</strong>：容器内通常运行一个主进程。</li>
</ul>
<p><strong>仓库（Repository）</strong></p>
<p><strong>定义</strong>：仓库是存储和分发镜像的地方，可以包含一个镜像的多个版本。</p>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>公共仓库</strong>：如 Docker Hub，任何人都可以使用</li>
<li><strong>私有仓库</strong>：企业内部搭建，用于存储私有镜像</li>
<li><strong>官方仓库</strong>：由软件官方维护的镜像仓库</li>
</ul>
<h1 id="离线部署docker"><a href="#离线部署docker" class="headerlink" title="离线部署docker"></a>离线部署docker</h1><table>
<thead>
<tr>
<th>操作系统</th>
<th>Red Hat Enterprise Linux release 9.4 (Plow)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Docker版本</strong></td>
<td><strong>28.2.2</strong></td>
</tr>
</tbody></table>
<p>​	<code>Docker离线安装包下载地址：https://download.docker.com/linux/static/stable/x86_64/</code></p>
<p>​	<code>阿里云rpm安装包下载地址：https://developer.aliyun.com/mirror/?spm=a2c6h.25603864.0.0.5d256733vSKLL6</code></p>
<p>​	在虚拟机中创建安装包存放目录，之后利用工具将安装包上传到该目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# <span class="built_in">mkdir</span> -p /opt/softapp/</span><br><span class="line">[root@localhost softapp]# tree /opt/</span><br><span class="line">/opt/</span><br><span class="line">└── softapp</span><br><span class="line">    └── docker-28.2.2.tgz</span><br><span class="line"></span><br><span class="line">1 directory, 1 file</span><br></pre></td></tr></table></figure>

<p>​	解压docker安装包，会产生docker的一个新目录，新目录内包含以下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# tar -zxvf /opt/softapp/docker-28.2.2.tgz -C /opt/softapp/</span><br><span class="line">docker/</span><br><span class="line">docker/containerd-shim-runc-v2</span><br><span class="line">docker/containerd</span><br><span class="line">docker/docker</span><br><span class="line">docker/runc</span><br><span class="line">docker/ctr</span><br><span class="line">docker/dockerd</span><br><span class="line">docker/docker-init</span><br><span class="line">docker/docker-proxy</span><br><span class="line">[root@localhost softapp]# tree /opt/softapp/docker</span><br><span class="line">/opt/softapp/docker</span><br><span class="line">├── containerd</span><br><span class="line">├── containerd-shim-runc-v2</span><br><span class="line">├── ctr</span><br><span class="line">├── docker</span><br><span class="line">├── dockerd</span><br><span class="line">├── docker-init</span><br><span class="line">├── docker-proxy</span><br><span class="line">└── runc</span><br><span class="line"></span><br><span class="line">0 directories, 8 files</span><br></pre></td></tr></table></figure>

<p>​	将解压出来的文件拷贝到&#x2F;usr&#x2F;bin工作目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# <span class="built_in">cp</span> /opt/softapp/docker/* /usr/bin/</span><br></pre></td></tr></table></figure>

<p>​	由于此刻docker未加入systemd守护进程，所以此刻利用cat重定向将docker加入守护进程，并做开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost system]# <span class="built_in">cat</span> &gt; /etc/systemd/system/docker.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Docker Application Container Engine</span></span><br><span class="line"><span class="string">Documentation=https://docs.docker.com</span></span><br><span class="line"><span class="string">After=network-online.target firewalld.service</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="string"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="string"># for containers run by docker</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock --selinux-enabled=false --default-ulimit nofile=65536:65536</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -s HUP $MAINPID</span></span><br><span class="line"><span class="string"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="string"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line"><span class="string">LimitNOFILE=infinity</span></span><br><span class="line"><span class="string">LimitNPROC=infinity</span></span><br><span class="line"><span class="string">LimitCORE=infinity</span></span><br><span class="line"><span class="string"># Uncomment TasksMax if your systemd version supports it.</span></span><br><span class="line"><span class="string"># Only systemd 226 and above support this version.</span></span><br><span class="line"><span class="string">#TasksMax=infinity</span></span><br><span class="line"><span class="string">TimeoutStartSec=0</span></span><br><span class="line"><span class="string"># set delegate yes so that systemd does not reset the cgroups of docker containers</span></span><br><span class="line"><span class="string">Delegate=yes</span></span><br><span class="line"><span class="string"># kill only the docker process, not all processes in the cgroup</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string"># restart the docker process if it exits prematurely</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">StartLimitBurst=3</span></span><br><span class="line"><span class="string">StartLimitInterval=60s</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	为文件添加执行权限，并重载守护进程，将docker添加开机自启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost system]# <span class="built_in">chmod</span> +x /etc/systemd/system/docker.service</span><br><span class="line">[root@localhost system]# systemctl daemon-reload</span><br><span class="line"><span class="comment">## 设置开启自启并立即启动</span></span><br><span class="line">[root@localhost system]# systemctl <span class="built_in">enable</span> --now docker.service</span><br></pre></td></tr></table></figure>

<p>​	验证docker是否安装及启动成功，并且版本核对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost system]# systemctl status docker.service </span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/docker.service; enabled; preset: disabled)</span><br><span class="line">     Active: active (running) since Mon 2025-06-16 15:49:25 CST; 57min ago</span><br><span class="line">....忽略....</span><br><span class="line">[root@localhost system]# docker --version</span><br><span class="line">Docker version 28.2.2, build e6534b4</span><br></pre></td></tr></table></figure>

<p>​	由于dockerHab镜像都位于国外，国内无法直接拉取官网的镜像仓库，所以我们需要配置一个国内的加速器，也就是镜像仓库地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line">[root@localhost opt]# <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">    &quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	配置docker命令补全功能，在配置该功能前需先检查您的服务器是否具有bash-completion软件包，如有则跳过安装bash-completion步骤，如没有请先安装bash-completion软件包：</p>
<p>​	<strong>bash-completion下载地址</strong>：<code>https://developer.aliyun.com/mirror/?spm=a2c6h.25603864.0.0.5d256733vSKLL6</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装bash-completion</span></span><br><span class="line">rpm -ivh /opt/softapp/bash-completion-2.11-4.el9.noarch.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置你root用户的bashrc源码文件</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">cat</span> &lt;&lt;<span class="string">EOT &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="string">if [ -f /etc/bash_completion ]; then</span></span><br><span class="line"><span class="string">    . /etc/bash_completion</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">mkdir</span> -p ~/.local/share/bash-completion/completions</span><br><span class="line">[root@localhost ~]# docker completion bash &gt; ~/.local/share/bash-completion/completions/docker</span><br><span class="line"><span class="comment"># 生效配置文件</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 如不行则重启服务器已生效</span></span><br><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure>

<p>​	安装完Docker后，我们可以简单的拉取一个镜像来验证某一个地址加速地址是否有效，以及docker功能是否可以正常使用（docker为命令，pull为拉取镜像的选项，docker…&#x2F;为仓库地址的前缀，nginx为镜像名称，latest为最新的版本号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost system]# docker pull docker.m.daocloud.io/nginx:latest</span><br><span class="line">latest: Pulling from nginx</span><br><span class="line">dad67da3f26b: Pull complete </span><br><span class="line">3b00567da964: Pull complete </span><br><span class="line">56b81cfa547d: Pull complete </span><br><span class="line">1bc5dc8b475d: Pull complete </span><br><span class="line">979e6233a40a: Pull complete </span><br><span class="line">d2a7ba8dbfee: Pull complete </span><br><span class="line">32e44235e1d5: Pull complete </span><br><span class="line">Digest: sha256:6784fb0834aa7dbbe12e3d7471e69c290df3e6ba810dc38b34ae33d3c1c05f7d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.m.daocloud.io/nginx:latest</span><br><span class="line">docker.m.daocloud.io/nginx:latest</span><br></pre></td></tr></table></figure>



<h1 id="容器的使用"><a href="#容器的使用" class="headerlink" title="容器的使用"></a>容器的使用</h1><h2 id="创建第一个容器"><a href="#创建第一个容器" class="headerlink" title="创建第一个容器"></a>创建第一个容器</h2><p>​	创建一个名字为job-1的容器，基础镜像使用busybox</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker run --name job-1 docker.m.daocloud.io/library/busybox</span><br></pre></td></tr></table></figure>

<p>​	<strong>参数解析</strong></p>
<ul>
<li><code>docker</code>二进制命令。</li>
<li><code>run</code>运行一个容器。</li>
<li><code>--name</code>为容器指定命名。</li>
<li><code>docker.m.daocloud.io/library/busybox</code>指定使用的基础镜像，如果本地镜像存在则直接运行，如不存在则从镜像仓库中拉取后运行</li>
</ul>
<p>​	容器创建完成后，可以使用docker命令ps选项查看当前运行的容器，但是此刻我们发现，刚才我们运行了一个名为job-1的容器，并且也成功了，但是我们使用ps查看时未发现容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure>

<p>​	在使用docker ps -a 命令查看所有的容器，此时我们就可以看到刚才我们创建名为job-1的容器了，但是他的状态是<code>Exited</code>停止状态，那是因为容器相当于一个任务，上面的命令要求的是运行一个容器，当他运行完成后，后台进程停止，也没有其他任何进程在运行了，容器也就自然停止了，所以容器他是一个临时性的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                                  COMMAND   CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">322d27f38ffd   docker.m.daocloud.io/library/busybox   <span class="string">&quot;sh&quot;</span>      10 minutes ago   Exited (0) 10 minutes ago             job-1</span><br></pre></td></tr></table></figure>



<h2 id="创建一个可持续运行的容器"><a href="#创建一个可持续运行的容器" class="headerlink" title="创建一个可持续运行的容器"></a>创建一个可持续运行的容器</h2><p>​	根据上述的实验我们发现容器他是一个临时的，但是在实际业务中，我的服务不可能一启动就停止，那么我们这里就需要来介绍如何运行一个可持续运行的容器。</p>
<p>​	此时我们运行一个本身就具有可持续后台进程的nginx镜像，运行后发现该容器运行的nginx的进程跑到宿主机前台持续运行中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker run  --name job-2 docker.m.daocloud.io/nginx:latest </span><br><span class="line">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class="line">/docker-entrypoint.sh: Looking <span class="keyword">for</span> shell scripts <span class="keyword">in</span> /docker-entrypoint.d/</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br><span class="line">10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf</span><br><span class="line">10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 <span class="keyword">in</span> /etc/nginx/conf.d/default.conf</span><br><span class="line">/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh</span><br><span class="line">/docker-entrypoint.sh: Configuration complete; ready <span class="keyword">for</span> start up</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: using the <span class="string">&quot;epoll&quot;</span> event method</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: nginx/1.27.5</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) </span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: OS: Linux 5.14.0-427.13.1.el9_4.x86_64</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 65536:65536</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: start worker processes</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: start worker process 29</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: start worker process 30</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: start worker process 31</span><br><span class="line">2025/06/19 03:55:18 [notice] 1#1: start worker process 32</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	这里我们可以再开一个ssh会话来验证job-2的容器是否在持续运行中，状态未up说明没问题，该容器此刻是可以持续运行的。</p>
<p>[root@localhost softapp]# docker ps<br>CONTAINER ID   IMAGE                               COMMAND                   CREATED         STATUS         PORTS     NAMES<br>5815a4228c1d   docker.m.daocloud.io&#x2F;nginx:latest   “&#x2F;docker-entrypoint.…”   3 minutes ago   Up 3 minutes   80&#x2F;tcp    job-2</p>
<p>​	那是因为这个nginx镜像文件中指定了，该容器在运行时，会执行一个nginx -g daemon off的命令，这个是nginx服务启动的命令，-g表示在前台运行并输出日志，daemon off表示关闭守护进程。</p>
<p>​	如要查看容器中具体干了些什么，比如他在运行时会执行什么命令。</p>
<p>​	<strong>可以使用docker命令，inspect选项，【容器名】</strong>，他的输出格式为josn格式，并且信息很多，我们可以利用Linux的一些知识，筛选出我们想要看的内容，grep -A 表示输出Cmd条件后10行，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker inspect job-2 | grep -A 10 Cmd </span><br><span class="line">            <span class="string">&quot;Cmd&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;daemon off;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;Image&quot;</span>: <span class="string">&quot;docker.m.daocloud.io/nginx:latest&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Volumes&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;WorkingDir&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Entrypoint&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/docker-entrypoint.sh&quot;</span></span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>



<p>​	但是这样我们会遇到另外一个问题，虽然我们知道只要容器只要挂着一个进程不停，容器就会一直持续运行，但是nginx镜像他是直接占用了宿主机的一个ssh前台进程，如果我们Ctrl+c停止掉，容器也会停止掉。</p>
<p>​	可以使用docker命令，run选项，-d选项将容器置与后台持续运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker run -d --name job-3 docker.m.daocloud.io/nginx:latest </span><br><span class="line">c0e8f1e16d3119f29be09cfe5d83b8429ea08f32f6918f02d7e309b433d3c91a</span><br><span class="line">[root@localhost softapp]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                               COMMAND                   CREATED          STATUS          PORTS     NAMES</span><br><span class="line">c0e8f1e16d31   docker.m.daocloud.io/nginx:latest   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   22 seconds ago   Up 21 seconds   80/tcp    job-3</span><br></pre></td></tr></table></figure>





<h2 id="尝试进入容器"><a href="#尝试进入容器" class="headerlink" title="尝试进入容器"></a>尝试进入容器</h2><p>​	进入正在运行的容器内部，我们可以使用exec选项和 -it选项进入到容器内部，可查看容器内部是个什么样子，与我们正常的操作系统有什么不同，以及他是如何运行服务的，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker <span class="built_in">exec</span> -it job-3 /bin/bash</span><br><span class="line"><span class="comment"># 进入容器后，ssh的前导符则会变为容器的ID，以便区分，退出则Ctrl+D或exit命令</span></span><br><span class="line">root@c0e8f1e16d31:/# </span><br></pre></td></tr></table></figure>

<p><strong>命令解析：</strong></p>
<ul>
<li>docker：二进制命令。</li>
<li>exec：在正在运行的容器中运行命令。</li>
<li>-it：以交互方式建立容器伪终端。</li>
<li>job-3：容器名或容器ID。</li>
<li>&#x2F;bin&#x2F;bash：容器中执行打开bash命令</li>
</ul>
<p>​	进入容器后我们可以发现常用的ll，top，ps -ef等等命令都不存在，那是因为最后我们介绍过，容器他是轻量化的一个服务打包，他不是最全的，他只包含了满足服务运行最基本的文件操作系统，以支撑例如nginx的运行条件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c0e8f1e16d31:/# ll</span><br><span class="line">bash: ll: <span class="built_in">command</span> not found</span><br><span class="line">root@c0e8f1e16d31:/# top</span><br><span class="line">bash: top: <span class="built_in">command</span> not found</span><br><span class="line">root@c0e8f1e16d31:/# ip</span><br><span class="line">bash: ip: <span class="built_in">command</span> not found</span><br><span class="line">root@c0e8f1e16d31:/# ifconfig</span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">root@c0e8f1e16d31:/# <span class="built_in">ls</span></span><br><span class="line">bin  boot  dev	docker-entrypoint.d  docker-entrypoint.sh  etc	home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@c0e8f1e16d31:/# <span class="built_in">cd</span> /usr/share/nginx/html</span><br><span class="line">root@c0e8f1e16d31:/usr/share/nginx/html# <span class="built_in">ls</span></span><br><span class="line">50x.html  index.html</span><br><span class="line">root@c0e8f1e16d31:/usr/share/nginx/html# curl 127.0.0.1 80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">^C</span><br><span class="line">root@c0e8f1e16d31:/usr/share/nginx/html# <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>







<h1 id="镜像的使用"><a href="#镜像的使用" class="headerlink" title="镜像的使用"></a>镜像的使用</h1><h2 id="镜像概述"><a href="#镜像概述" class="headerlink" title="镜像概述"></a>镜像概述</h2><p>​	镜像是一个用于创建容器的只读模板，镜像中包含着很多额外的参数定于，比如：我们基于centos文件系统构建一个服务这里把他称之为基础层，在这个centos文件系统上我们要再加上我们的服务，例如nginx、tomcat等等，以及他们所需的依赖，每次修改或新增都会增加一个镜像层，从而构建出我们期望的业务镜像。</p>
<p>​	同时镜像可以有公共镜像仓库或DockerFile自定义获得镜像。并将镜像推送到自己本地仓库或自己私有的镜像仓库进行存储，一遍以后重复构建更新、部署使用。</p>
<h2 id="公共镜像仓库"><a href="#公共镜像仓库" class="headerlink" title="公共镜像仓库"></a>公共镜像仓库</h2><p>​	Docker Hub是全球最大的公共镜像仓库，许多开源厂商都会将各自的官方开源镜像上传到Hub上供人拉取，这个服务是允许公众连接、创建、拉取、上传镜像使用，虽然便利但注意这是公共开源的仓库，不建议使用云端镜像仓库存放私有镜像，避免被别人拉取泄露。</p>
<p><strong>Docker Hub官网地址：</strong><code>https://docker.czc.cloudns.biz/</code></p>
<h2 id="私有镜像仓库"><a href="#私有镜像仓库" class="headerlink" title="私有镜像仓库"></a>私有镜像仓库</h2><p>​	私有镜像仓库的用于与公共镜像仓库类似，唯一的区别就是该仓库是你独自搭建在你内网中的镜像仓库，除了你自己和你授权的人外，无人能访问该镜像仓库，以及无法从你的镜像仓库中拉取任何镜像，具体操作后续介绍。</p>
<p>​	<strong>常用的私有仓库服务工具</strong>：Docker Hub、Harbor</p>
<h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><p>​	不管是从公共镜像还是本地镜像拉取下来的镜像都存放在我们宿主机的本地镜像库中，只有拉取到本地镜像库后，才可以从本地镜像库中使用镜像去创建容器，查看我们现在以及拉取存在的镜像有哪些可以通过images进行查看。</p>
<p>​	<strong>格式</strong>：docker images [镜像名]</p>
<p>​	不带镜像名则所有进项全部展示，当镜像过多时，我们可以加上镜像名去搜索我们想要看到的镜像，便于查找。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker images</span><br><span class="line">REPOSITORY                             TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">job-02                                 latest    a38262e3f7e4   23 minutes ago   4.28MB</span><br><span class="line">job-01                                 latest    af8d6c46c922   30 minutes ago   4.28MB</span><br><span class="line">nginx                                  1.2       e76f04ecad6a   7 hours ago      192MB</span><br><span class="line">nginx                                  v1        a5ca0b814874   4 days ago       192MB</span><br><span class="line">docker.m.daocloud.io/nginx             latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">nginx                                  latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">docker.m.daocloud.io/library/busybox   latest    6d3e4188a38a   9 months ago     4.28MB</span><br><span class="line">[root@localhost softapp]# docker images nginx:v1</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">nginx        v1        a5ca0b814874   5 days ago   192MB</span><br></pre></td></tr></table></figure>





<h2 id="构建镜像的方式"><a href="#构建镜像的方式" class="headerlink" title="构建镜像的方式"></a>构建镜像的方式</h2><p><strong>docker commit</strong></p>
<p>​	在使用容器镜像中，容器本身发生了修改，您想将当前状态下的容器制作为一个镜像，则可以使用commit（提交）选项将当前容器的状态保存到本地镜像仓库，以便后续的快速部署搭建。</p>
<p><strong>DockerFile</strong>（推荐）</p>
<p>​	从零开始搭建你的镜像服务，在创建镜像前需要将该镜像的所有配置、依赖、基础镜像等自行编写进脚本中，生成的镜像可直接用于业务部署，但是对技术要求有难度，这个后续单独讨论。</p>
<h2 id="commit镜像构建"><a href="#commit镜像构建" class="headerlink" title="commit镜像构建"></a>commit镜像构建</h2><p>​	结合上述运行容器和进入容器的方式，运行并修改一个容器内容，然后利用commit打包当前状态下的容器为一个新的镜像，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 运行一个nginx镜像，容器名为job-01</span></span><br><span class="line">[root@localhost ~]# docker run -d --name job-01 nginx:latest </span><br><span class="line">fca794f38cf76b39a92348d1d81bf3d98deb564b365d8cfb540e810a1e4e298b</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">[root@localhost ~]# docker <span class="built_in">exec</span> -it job-01 /bin/bash</span><br><span class="line"><span class="comment"># 修改容器内nginx首页的样式内容</span></span><br><span class="line">root@fca794f38cf7:/# <span class="built_in">echo</span> 这是一个版本为1.2的nginx容器 &gt;/usr/share/nginx/html/index.html</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">root@fca794f38cf7:/usr/share/nginx/html# 键入【Ctrl+D】</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># commit将修改后的job-01容器保存为新的镜像，镜像名称及版本为nginx:1.2</span></span><br><span class="line">[root@localhost ~]# docker commit job-01 nginx:1.2</span><br><span class="line">sha256:e76f04ecad6a841c2f2023fb11f0bd873d6a06c411ea488d661e7e2557cb2952</span><br><span class="line"><span class="comment"># 验证新镜像是否存在</span></span><br><span class="line">[root@localhost ~]# docker images nginx:1.2</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">nginx        1.2       e76f04ecad6a   55 seconds ago   192MB</span><br><span class="line"><span class="comment"># 使用新容器创建一个新的名为job-02的容器，并在容器内访问nginx的80端口，验证修改后的内容是否在新镜像中有效</span></span><br><span class="line">[root@localhost ~]# docker run -d --name job-02 nginx:1.2 </span><br><span class="line">3c1b5719206b5def9adde8a3b0d76490208226ee41facab45082d6c37c195426</span><br><span class="line">[root@localhost ~]# docker <span class="built_in">exec</span> -it job-02 /bin/bash</span><br><span class="line"><span class="comment"># 验证成功，此刻已成功将基础镜像定制成我们特有的业务镜像</span></span><br><span class="line">root@3c1b5719206b:/# curl 127.0.0.1:80</span><br><span class="line">这是一个版本为1.2的nginx容器</span><br><span class="line">root@3c1b5719206b:/# </span><br></pre></td></tr></table></figure>











<h1 id="DockerFile的使用"><a href="#DockerFile的使用" class="headerlink" title="DockerFile的使用"></a>DockerFile的使用</h1><p>​	DockerFile是一个文本文件，包含了构建Docker镜像所有的指令。</p>
<h2 id="使用DockerFile定制镜像"><a href="#使用DockerFile定制镜像" class="headerlink" title="使用DockerFile定制镜像"></a>使用DockerFile定制镜像</h2><p>​	在一个空目录下，创建一个名为Dockerfile的文本文件，并添加一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &quot;这是一个本地构建的Nginx镜像&quot; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p><strong>FROM</strong>：定制的镜像都基于FROM的镜像来构建的，也就是基础镜像，后续的所有操作都是建立在这个基础镜像上去进行修改定制。</p>
<p><strong>RUN</strong>：用于在基础镜像上执行的相应定制化执行shell命令，需要允许的命令可以有一下两种格式写法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一：</span></span><br><span class="line">RUN &lt;命令行&gt;</span><br><span class="line"><span class="comment">#方式二：</span></span><br><span class="line">RUN [<span class="string">&quot;二进制命令&quot;</span>,<span class="string">&quot;选项/参数&quot;</span>,<span class="string">&quot;选项/参数&quot;</span>]</span><br><span class="line">例如：每一个逗号分割代表一个单词，空格分割</span><br><span class="line">RUN [<span class="string">&quot;tail&quot;</span>,<span class="string">&quot;-n&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;test.txt&quot;</span>]等效与 RUN <span class="built_in">tail</span> -n 10 test.txt</span><br></pre></td></tr></table></figure>

<p><strong><code>注意：Dockerfile的指令每一行都会在这个镜像上新建一层，所以在书写Dockerfile指令时，避免书写过多没必要的指令，会造成镜像容量过大。</code></strong></p>
<p>该命令只会创建三层：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN dnf install wget</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br></pre></td></tr></table></figure>

<p>合理使用【\】换行，【&amp;&amp;】符号多个命令拼接，组成一条命令，这样可以避免重复RUN指令，该条命令则只会生成两层。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN dnf install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; tar -zxvf ./redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure>



<h2 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h2><p>​	在DockerFile文件目录下进行构建操作。</p>
<p>​	以下示例通过DockerFile构建一个名为nginx:v1(镜像名称:镜像标签&#x2F;版本号)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker build -t nginx:v1 .</span><br><span class="line">DEPRECATED: The legacy builder is deprecated and will be removed <span class="keyword">in</span> a future release.</span><br><span class="line">            Install the buildx component to build images with BuildKit:</span><br><span class="line">            https://docs.docker.com/go/buildx/</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  300.2MB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; 1e5f3c5b981a</span><br><span class="line">Step 2/2 : RUN <span class="built_in">echo</span> <span class="string">&quot;这是一个本地构建的Nginx镜像&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> bbb2493f7b99</span><br><span class="line"> ---&gt; Removed intermediate container bbb2493f7b99</span><br><span class="line"> ---&gt; a5ca0b814874</span><br><span class="line">Successfully built a5ca0b814874</span><br><span class="line">Successfully tagged nginx:v1</span><br><span class="line"><span class="comment"># images查看本地镜像，nginx:v1已经构建完成</span></span><br><span class="line">[root@localhost softapp]# docker images</span><br><span class="line">REPOSITORY                             TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">nginx                                  v1        a5ca0b814874   31 seconds ago   192MB</span><br><span class="line">nginx                                  latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">docker.m.daocloud.io/nginx             latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">docker.m.daocloud.io/library/busybox   latest    6d3e4188a38a   8 months ago     4.28MB</span><br></pre></td></tr></table></figure>

<p><strong><code>注意：文件名称一定要是Dockerfile，否则会出现我这样的报错，找不到Dockerfile文件。</code></strong></p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250619175141092.png" alt="image-20250619175141092"></p>
<p>​	<strong>解析：在构建镜像的时候，有时候会使用到本机的文件，比如我们需要将本地的文件复制到这个镜像里，docker build得知这个路径后，会将路径下的所有内容打包，由于docker的允许模式是C&#x2F;S。C是我们本机，也称为宿主机，S是docker引擎，实际的构建过程是在docker引擎内完成的，这个时候是无法用到我们宿主机的文件，这就是为什么build得知路径后会将路径下的内容都打包到引擎中，命令中最后的点（.）就是指的这个上下文路径，所以路径中不要防无用的文件，避免构建过慢。</strong></p>
<h2 id="DockerFile常用指令集"><a href="#DockerFile常用指令集" class="headerlink" title="DockerFile常用指令集"></a>DockerFile常用指令集</h2><table>
<thead>
<tr>
<th>Dockerfile指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像，用于后续的指令定制构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定Dockerfile的作者（已启用，推荐使用LABEL）</td>
</tr>
<tr>
<td>LABEL</td>
<td>添加镜像的元数据\描述，采用键值对的形式</td>
</tr>
<tr>
<td>RUN</td>
<td>在构建过程中，在镜像需要执行的命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定镜像创建容器运行时默认需要运行的命令（可覆盖基础镜像的CMD）</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定镜像创建容器运行时主要的命令。（不可被覆盖）</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明容器运行时监听特定的网络端口，供宿主机及外部进行访问容器内的访问。</td>
</tr>
<tr>
<td>ENV</td>
<td>在容器中设置环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>将文件、目录或远程URL复制到镜像中，如果文件属于tar、gizp等压缩文件会自动为您解压。</td>
</tr>
<tr>
<td>COPY</td>
<td>将文件或目录复制到镜像中。</td>
</tr>
<tr>
<td>VOLUME</td>
<td>为容器创建与宿主机磁盘的挂载点，供在宿主机即可操作容器内的重要文件数据。</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定后续镜像构建中的指令执行时的工作目录，如不存在则会自动创建（类似于Linux中的cd命令，不同的是目录不存在会自动创建）</td>
</tr>
<tr>
<td>USER</td>
<td>指定后续dockerfile指令使用的用户，以及容器运行时服务默认启动的用户，如没有配置默认是root（类似Linux中的su，切换用户）</td>
</tr>
<tr>
<td>ARG</td>
<td>定义构建镜像中的变量（他与ENV不同，ENV是容器中的环境变量，适用于容器中，ARG仅适用于dockerfile脚本文件中，类似ssh脚本中设置的变量）</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发式执行，本身不会执行，触发条件当该镜像被作为基础镜像构建新镜像时触发相应指定的指令操作，RUN或LABEL指令。</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>当容器停止进程调用时，用于发送给容器的信号，例如在使用docker stop，Linux的信号可以参考RedHat章节了解。</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>容器服务的健康检查，容器可能处于启动，但是内部的服务不一定正常运行，需要使用该指令定期检查服务是否存活，如检测失败状态则会标记为unhealthy。</td>
</tr>
<tr>
<td>SHELL</td>
<td>用于修改默认shell环境，通常修改为&#x2F;bin&#x2F;bash或sh</td>
</tr>
</tbody></table>
<h2 id="LABEL指令的使用"><a href="#LABEL指令的使用" class="headerlink" title="LABEL指令的使用"></a>LABEL指令的使用</h2><p>​	为镜像设置一个元数据【标签】，目前常用为作者等一些个性化定制信息，不管是用于镜像的描述，还是镜像的特殊标识区分</p>
<p>​	<strong>格式</strong>：LABEL <key>:<value></value></key></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.2</span><br><span class="line">LABEL author:liweihu</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;这是一个本地构建的Nginx镜像&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>



<h2 id="CMD指令的使用"><a href="#CMD指令的使用" class="headerlink" title="CMD指令的使用"></a>CMD指令的使用</h2><p>​	为镜像设置一个容器启动时默认需要运行的命令，当该命令执行完成后，也就以为容器停止，如果该服务属于持续运行的业务，需要保证该命令能持续运行，例如nginx，后台启动一个nginx服务,该指令可以被docker run创建容器时被参数所覆盖，导致不执行。</p>
<p>​	<strong>格式</strong>：CMD <shell> 或者 CMD [“可执行文件或命令”,”选项&#x2F;参数”,……]</shell></p>
<p>​	<code>以下示例中的CMD是nginx官方镜像写的，他是作用是运行nginx并放在前台运行，已保证容器内始终都会有一个进程或终端在运行，从而达到可持久运行的容器，如果在docker run的使用其他的参数将他覆盖，则容器可能启动既停止。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.2</span><br><span class="line">LABEL author:liweihu</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;这是一个本地构建的Nginx镜像&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="ENTRYPOINT指令的使用"><a href="#ENTRYPOINT指令的使用" class="headerlink" title="ENTRYPOINT指令的使用"></a>ENTRYPOINT指令的使用</h2><p>​	与CMD同样，区别在于ENTRYPOINT不可被覆盖，他作为该镜像启动容器的主要命令。</p>
<p>​	<strong>格式</strong>：ENTRYPOINT [“可执行文件或命令”,”选项&#x2F;参数”,……]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.2</span><br><span class="line">LABEL author:liweihu</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;这是一个本地构建的Nginx镜像&quot;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>重要：当dockerfile中只有CMD时，CMD则是作为启动容器服务的语句使用，同时CMD可被docker run覆盖。</strong></p>
<p>​	<strong>当dockerfile同时存在CMD和ENTRYPOINT时，CMD则不再是启动容器的指令，而是作为参数，传递给ENTRYPOINT去启动容器服务，以下示例来简短验证。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写一个busybox的操作系统，cmd运行一个echo的命令</span></span><br><span class="line">[root@localhost softapp]# <span class="built_in">cat</span> Dockerfile </span><br><span class="line">FROM docker.m.daocloud.io/library/busybox:latest</span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;这是cmd运行的指令&quot;</span></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@localhost softapp]# docker build -t job-01:latest .</span><br><span class="line">DEPRECATED: The legacy builder is deprecated and will be removed <span class="keyword">in</span> a future release.</span><br><span class="line">            Install the buildx component to build images with BuildKit:</span><br><span class="line">            https://docs.docker.com/go/buildx/</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  300.2MB</span><br><span class="line">Step 1/2 : FROM docker.m.daocloud.io/library/busybox:latest</span><br><span class="line"> ---&gt; 6d3e4188a38a</span><br><span class="line">Step 2/2 : CMD <span class="built_in">echo</span> <span class="string">&quot;这是cmd运行的指令&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 6a5441c4a26b</span><br><span class="line"> ---&gt; Removed intermediate container 6a5441c4a26b</span><br><span class="line"> ---&gt; af8d6c46c922</span><br><span class="line">Successfully built af8d6c46c922</span><br><span class="line">Successfully tagged job-01:latest</span><br><span class="line"><span class="comment"># cmd此时做着容器运行的一个命令去运行</span></span><br><span class="line">[root@localhost softapp]# docker run job-01:latest </span><br><span class="line">这是cmd运行的指令</span><br></pre></td></tr></table></figure>

<p>​	当cmd和ENTRYPOINT同时存在时，他们的shell语法得都用json格式，否则无效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当同时存在时，cmd将作为参数赋予ENTRYPOINT去运行容器服务</span></span><br><span class="line">[root@localhost softapp]# <span class="built_in">cat</span> Dockerfile </span><br><span class="line">FROM docker.m.daocloud.io/library/busybox:latest</span><br><span class="line">CMD [<span class="string">&quot;这是cmd运行的指令&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;echo&quot;</span>]</span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@localhost softapp]# docker build -t job-02 .</span><br><span class="line">DEPRECATED: The legacy builder is deprecated and will be removed <span class="keyword">in</span> a future release.</span><br><span class="line">            Install the buildx component to build images with BuildKit:</span><br><span class="line">            https://docs.docker.com/go/buildx/</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  300.2MB</span><br><span class="line">Step 1/3 : FROM docker.m.daocloud.io/library/busybox:latest</span><br><span class="line"> ---&gt; 6d3e4188a38a</span><br><span class="line">Step 2/3 : CMD [<span class="string">&quot;这是cmd运行的指令&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 7aae458a0d54</span><br><span class="line"> ---&gt; Removed intermediate container 7aae458a0d54</span><br><span class="line"> ---&gt; 048f8b333e50</span><br><span class="line">Step 3/3 : ENTRYPOINT [<span class="string">&quot;echo&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> dbc0f5115ef6</span><br><span class="line"> ---&gt; Removed intermediate container dbc0f5115ef6</span><br><span class="line"> ---&gt; a38262e3f7e4</span><br><span class="line">Successfully built a38262e3f7e4</span><br><span class="line">Successfully tagged job-02:latest</span><br><span class="line"><span class="comment">## 运行镜像发现，我们CMD没有给任何可执行命令，但是他任然可以执行这段话。</span></span><br><span class="line"><span class="comment">## 那是因为当cmd和ENTRYPOINT同时存在时，CMD则变换了角色，作为参数传递给ENTRYPOINT去实际执行</span></span><br><span class="line">[root@localhost softapp]# docker run job-02:latest </span><br><span class="line">这是cmd运行的指令</span><br><span class="line">[root@localhost softapp]#</span><br></pre></td></tr></table></figure>

<p>​	所以细心的会发现nginx官方镜像中实际运行nginx容器服务的是ENTRYPOINT，有过Linux基础的应该清楚，$0表示脚本文件名，$1、2……N表示传递过来的参数，所以他通过内置的shell脚本加上cmd的参数载入，以及 </p>
<p>&#x2F;docker-entrypoint.d下的一系列配置脚本，完成了镜像的整个初始化工作有兴趣的可以自行去研究，精力有限这里就不在过多讨论。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250624170300315.png" alt="image-20250624170300315"></p>
<p>​	dockerfile指令很多，感兴趣的可以自行挨个操作实验，本文主要是为了讲解如何用k8s管理好docker等容器服务，docker实际的操作我们会用的非常少，过于复杂的东西了解即可。</p>
<h2 id="删除容器和本地镜像"><a href="#删除容器和本地镜像" class="headerlink" title="删除容器和本地镜像"></a>删除容器和本地镜像</h2><p>​	上诉我们做了很多实验创建了很多容器和镜像，虽然每个镜像都非常小，但是作为管理员过多的镜像对我们运维过程中会造成很多困扰，所以作为管理员还是要定期维护一下我们过期无用的容器和镜像。</p>
<p>​	<strong>删除容器格式</strong>： docker rm 容器ID&#x2F;容器名</p>
<p>​	<strong>注意：当要删除的容器处于运行状态时是不能删除的，需先将其docker stop进行停止，或者在结尾加上–force选项，强制删除，但不建议这样做，容易导致容器服务数据异常，尤其容器是数据库服务。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS     NAMES</span><br><span class="line">354e8728cf31   nginx:1.2   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   26 minutes ago   Up 26 minutes   80/tcp    nifty_cori</span><br><span class="line"><span class="comment"># 删除正在运行的容器，是不可以的，需要先停止容器</span></span><br><span class="line">[root@localhost softapp]# docker <span class="built_in">rm</span> 354e8728cf31 </span><br><span class="line">Error response from daemon: cannot remove container <span class="string">&quot;354e8728cf31&quot;</span>: container is running: stop the container before removing or force remove</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">[root@localhost softapp]# docker stop nifty_cori </span><br><span class="line">nifty_cori</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">[root@localhost softapp]# docker <span class="built_in">rm</span> nifty_cori </span><br><span class="line">nifty_cori</span><br></pre></td></tr></table></figure>



<p>​	<strong>删除镜像格式</strong>： docker rmi 镜像ID&#x2F;镜像名:版本号</p>
<p>​	<strong>注意：如果该镜像正在被一个容器所使用，即使容器是停止的也是无法删除的，需要先将容器停止删除后方可删除镜像。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# docker images</span><br><span class="line">REPOSITORY                             TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">job-02                                 latest    a38262e3f7e4   35 minutes ago   4.28MB</span><br><span class="line">job-01                                 latest    af8d6c46c922   42 minutes ago   4.28MB</span><br><span class="line">nginx                                  1.2       e76f04ecad6a   8 hours ago      192MB</span><br><span class="line">nginx                                  v1        a5ca0b814874   5 days ago       192MB</span><br><span class="line">nginx                                  latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">docker.m.daocloud.io/nginx             latest    1e5f3c5b981a   2 months ago     192MB</span><br><span class="line">docker.m.daocloud.io/library/busybox   latest    6d3e4188a38a   9 months ago     4.28MB</span><br><span class="line"><span class="comment"># 删除两个正在被容器所使用的镜像，删除失败。</span></span><br><span class="line"><span class="comment"># 根据提示容器ID为【546d94800abd、d159e8586dd3】正在使用</span></span><br><span class="line">[root@localhost softapp]# docker rmi job-01:latest job-02:latest </span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;job-01:latest&quot;</span> (must force) - container 546d94800abd is using its referenced image af8d6c46c922</span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;job-02:latest&quot;</span> (must force) - container d159e8586dd3 is using its referenced image a38262e3f7e4</span><br><span class="line"><span class="comment"># 删除占用镜像的容器</span></span><br><span class="line">[root@localhost softapp]# docker <span class="built_in">rm</span> 546d94800abd d159e8586dd3</span><br><span class="line">546d94800abd</span><br><span class="line">d159e8586dd3</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">[root@localhost softapp]# docker rmi job-01:latest job-02:latest </span><br><span class="line">Untagged: job-01:latest</span><br><span class="line">Deleted: sha256:af8d6c46c922db8c8102aab14568a6a4f1d0982871aae32bab41d564654a20c2</span><br><span class="line">Untagged: job-02:latest</span><br><span class="line">Deleted: sha256:a38262e3f7e42c9c344ad005f8034cffbfcd48dd8b67ee94cd55878032c82b5b</span><br><span class="line">Deleted: sha256:048f8b333e508e2005b52f417f6abdda0df351fcb81b52034774cdecfb5635bd</span><br></pre></td></tr></table></figure>





<h1 id="构建Harbor私有镜像仓库"><a href="#构建Harbor私有镜像仓库" class="headerlink" title="构建Harbor私有镜像仓库"></a>构建Harbor私有镜像仓库</h1><p>​	什么是Harbor?Harbor是一个开源注册中心，它通过策略和基于角色的访问控制来保护工件，确保图像经过扫描且不存在漏洞，并将图像标记为可信。Harbor是CNCF的毕业项目，它提供合规性，性能及互操作性，帮助您在 Kubernetes和 Docker等云原生计算平台上，以一致且安全的方式管理工件（镜像），所以本章节咱们采用它来作为我们的私有镜像仓库。</p>
<h2 id="确保您的目标主机满足Harbor安装前提条件"><a href="#确保您的目标主机满足Harbor安装前提条件" class="headerlink" title="确保您的目标主机满足Harbor安装前提条件"></a><strong>确保您的目标主机满足Harbor安装前提条件</strong></h2><p><strong>资源需求</strong></p>
<table>
<thead>
<tr>
<th>资源</th>
<th>最低要求</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>内存</td>
<td>4GB</td>
<td>8GB</td>
</tr>
<tr>
<td>磁盘</td>
<td>40GB</td>
<td>160GB</td>
</tr>
</tbody></table>
<p><strong>服务器软件要求</strong></p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Docker引擎</td>
<td>版本 &gt; 20.10</td>
<td>Docker引擎安装</td>
</tr>
<tr>
<td>Docker Compose</td>
<td>Docker compose &gt; 2.3</td>
<td>Docker compose是Docker引擎的一部分</td>
</tr>
<tr>
<td>OpenSSL</td>
<td>最新（可选）</td>
<td>用于生成Harbor的证书和密钥</td>
</tr>
</tbody></table>
<p><strong>网络端口</strong></p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor门户和核心API在此端口接受HTTPS请求。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor门户和核心API在此端口接受HTTP请求。您可以在配置文件中更改此端口。</td>
</tr>
</tbody></table>
<p><strong>环境配置</strong></p>
<p>​	将宿主机的主机名及Hosts文件修改为您的镜像仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">[root@localhost harbor]# hostnamectl hostname reg.liweihu.cn</span><br><span class="line">[root@localhost harbor]# hostname</span><br><span class="line">liweihu.com</span><br><span class="line"><span class="comment"># 刷新shell</span></span><br><span class="line">[root@localhost harbor]# bash</span><br><span class="line"><span class="comment"># 配置hosts域名解析</span></span><br><span class="line">[root@localhost harbor]# <span class="built_in">echo</span> <span class="string">&quot;192.168.8.135 reg.liweihu.cn&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">[root@localhost harbor]# systemctl <span class="built_in">disable</span> firewalld  &amp;&amp; systemctl stop firewalld</span><br><span class="line"><span class="comment">#关闭selinux服务</span></span><br><span class="line">[root@localhost harbor]# <span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line">[root@localhost harbor]# setenforce 0</span><br><span class="line"><span class="comment">#清空iptables规则</span></span><br><span class="line">[root@localhost harbor]# iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -Z</span><br><span class="line">[root@localhost harbor]# iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>



<h2 id="下载Harbor安装程序"><a href="#下载Harbor安装程序" class="headerlink" title="下载Harbor安装程序"></a>下载Harbor安装程序</h2><p>​	<strong>离线安装包下载地址</strong>：<a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p>
<p>​	离线安装包较大，在线的较小，由于考虑到生产中我们是很少出现服务器能连通互联网的情况，所以我们尽量都用离线的方式来部署。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250625104851320.png" alt="image-20250625104851320"></p>
<h2 id="配置访问Harbor的HTTPS"><a href="#配置访问Harbor的HTTPS" class="headerlink" title="配置访问Harbor的HTTPS"></a><strong>配置访问Harbor的HTTPS</strong></h2><p>​	<strong>生成根CA密钥、证书</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg /]# <span class="built_in">mkdir</span> ~/ca &amp;&amp; <span class="built_in">cd</span> ~/</span><br><span class="line">[root@localhost harbor]# openssl genrsa -out ca.key 4096</span><br><span class="line">[root@localhost harbor]# openssl req -x509 -new -nodes -sha512 -days 3650 \</span><br><span class="line"> -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=Root&quot;</span> \</span><br><span class="line"> -key ca.key \</span><br><span class="line"> -out ca.crt</span><br></pre></td></tr></table></figure>



<p>​	<strong>生成服务器CA密钥、证书</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost harbor]# openssl genrsa -out reg.liweihu.cn.key 4096</span><br><span class="line">[root@localhost harbor]# openssl req -sha512 -new \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=reg.liweihu.cn&quot;</span> \</span><br><span class="line">    -key reg.liweihu.cn.key \</span><br><span class="line">    -out reg.liweihu.cn.csr</span><br></pre></td></tr></table></figure>

<p>​	<strong>生成一个X509 V3扩展文件</strong></p>
<p>​			无论您是使用FQDN还是IP地址来连接您的Harbor主机，都必须创建此文件，以便能够为您的Harbor主机生成符合主题替代名SAN)和x509v3扩展要求的证书。请替换DNS条目以反映您的域名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liweihu softapp]# <span class="built_in">cat</span> &gt; v3.ext &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">authorityKeyIdentifier=keyid,issuer</span></span><br><span class="line"><span class="string">basicConstraints=CA:FALSE</span></span><br><span class="line"><span class="string">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span></span><br><span class="line"><span class="string">extendedKeyUsage = serverAuth</span></span><br><span class="line"><span class="string">subjectAltName = @alt_names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[alt_names]</span></span><br><span class="line"><span class="string">DNS.1=reg.liweihu.cn</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>使用V3.ext文件为您的Harbor主机生成证书</strong></p>
<p>​			将CSR和CRT文件名中的liweihu.com替换为Harbor主机名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liweihu softapp]# openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">    -extfile v3.ext \</span><br><span class="line">    -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">    -<span class="keyword">in</span> reg.liweihu.cn.csr \</span><br><span class="line">    -out reg.liweihu.cn.crt</span><br></pre></td></tr></table></figure>



<h2 id="将证书提供给Harbor和Docker"><a href="#将证书提供给Harbor和Docker" class="headerlink" title="将证书提供给Harbor和Docker"></a>将证书提供给Harbor和Docker</h2><p>​	在生成ca.crt、liweihu.com.crt 和liweihu.com.key文件后，您必须将它们提供给Harbor和Docker，并重新配置Harbor以使用这些文件。</p>
<p>​	1.将服务器证书和密钥复制到Harbor主机上的证书文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# <span class="built_in">mkdir</span> -p /data/cert</span><br><span class="line">[root@localhost softapp]# <span class="built_in">cp</span> reg.liweihu.cn.crt reg.liweihu.cn.key /data/cert/</span><br></pre></td></tr></table></figure>

<p>​	2、将liweihu.com.crt转换为liweihu.com.cert，以便Docker使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# openssl x509 -inform PEM -<span class="keyword">in</span> reg.liweihu.cn.crt -out reg.liweihu.cn.cert</span><br></pre></td></tr></table></figure>

<p>​	3、将服务器证书、私钥和 CA 文件复制到Harbor主机的Docker证书文件夹中。首先必须创建相应的文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# <span class="built_in">mkdir</span> -p /etc/docker/certs.d/reg.liweihu.cn/</span><br><span class="line">[root@localhost softapp]# <span class="built_in">cp</span> reg.liweihu.cn.cert reg.liweihu.cn.key ca.crt /etc/docker/certs.d/reg.liweihu.cn/</span><br></pre></td></tr></table></figure>

<p><strong><code>注意：如果你将默认的nginx的HTTPS端口443映射到不同的端口，请将创建文件夹在按照如下格式进行创建：</code></strong><br><strong>&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;yourdomain.com:port，或&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;你的域名_IP:端口。</strong></p>
<h2 id="配置HarborYML文件"><a href="#配置HarborYML文件" class="headerlink" title="配置HarborYML文件"></a>配置HarborYML文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost softapp]# tar -zxvf /opt/softapp/harbor-offline-installer-v2.13.1.tgz -C /opt/softapp/ &amp;&amp; <span class="built_in">cd</span> /opt/softapp/harbor</span><br><span class="line"></span><br><span class="line">harbor/harbor.v2.13.1.tar.gz</span><br><span class="line">harbor/prepare</span><br><span class="line">harbor/LICENSE</span><br><span class="line">harbor/install.sh</span><br><span class="line">harbor/common.sh</span><br><span class="line">harbor/harbor.yml.tmpl</span><br><span class="line"><span class="comment"># 将配置文件模板复制出来一份</span></span><br><span class="line">[root@localhost harbor]# <span class="built_in">cp</span> /opt/softapp/harbor/harbor.yml.tmpl harbor.yml</span><br><span class="line">[root@localhost harbor]# vim harbor.yml</span><br><span class="line"><span class="comment"># 如果您采用http则#号注释掉https相关参数</span></span><br><span class="line"><span class="comment"># 如果您采用https则#号注释掉http相关参数</span></span><br><span class="line"><span class="comment"># 修改hostname为reg.liweihu.cn【你的仓库域名hosts配置的】</span></span><br><span class="line"><span class="comment"># 修改https处的certificate为/data/cert/reg.liweihu.cn.crt【服务器证书】</span></span><br><span class="line"><span class="comment"># 修改https处的private_key为/data/cert/reg.liweihu.cn.key【服务器密钥】</span></span><br><span class="line"><span class="comment"># 修改harbor_admin_password为admin【Harbor登录密码】</span></span><br></pre></td></tr></table></figure>





<h2 id="部署Docker-compose"><a href="#部署Docker-compose" class="headerlink" title="部署Docker-compose"></a>部署Docker-compose</h2><p>​	下载地址：<a href="https://download.docker.com/linux/rhel/9/x86_64/stable/Packages/">https://download.docker.com/linux/rhel/9/x86_64/stable/Packages/</a></p>
<p>​	rpm安装Docker-compose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost harbor]# rpm -ivh docker-compose-plugin-2.37.3-1.el9.x86_64.rpm </span><br><span class="line">警告：docker-compose-plugin-2.37.3-1.el9.x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID 621e9f35: NOKEY</span><br><span class="line">Verifying...                          <span class="comment">################################# [100%]</span></span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:docker-compose-plugin-0:2.37.3-1.################################# [100%]</span><br></pre></td></tr></table></figure>





<h2 id="运行安装脚本"><a href="#运行安装脚本" class="headerlink" title="运行安装脚本"></a>运行安装脚本</h2><p>​	我们下载过来离线按照包解压后，解压包里还包含的一个解压包，名为：harbor.v2.13.1.tar.gz，这其实就是将原本需要在线下载的镜像一起打包下载到本地，通过本地进行导入。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250626103236674.png" alt="image-20250626103236674"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入镜像包进入本地镜像库</span></span><br><span class="line">[root@localhost harbor]# ./install.sh </span><br><span class="line"></span><br><span class="line">[Step 0]: checking <span class="keyword">if</span> docker is installed ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 28.2.2</span><br><span class="line"></span><br><span class="line">[Step 1]: checking docker-compose is installed ...</span><br><span class="line"></span><br><span class="line">Note: Docker Compose version v2.37.3</span><br><span class="line"></span><br><span class="line">[Step 2]: loading Harbor images ...</span><br><span class="line">......忽略.....</span><br><span class="line"></span><br><span class="line"> ✔ Container nginx              Started                                                                                                                                                                                         4.1s </span><br><span class="line"> ✔ Container harbor-jobservice  Started                                                                                                                                                                                         3.8s </span><br><span class="line">✔ ----Harbor has been installed and started successfully.----</span><br><span class="line"><span class="comment"># 检查本地镜像是否存在</span></span><br><span class="line">[root@localhost harbor]# docker images</span><br><span class="line">REPOSITORY                             TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">...忽略...</span><br><span class="line">goharbor/harbor-exporter               v2.13.1   8323e56fa034   4 weeks ago    127MB</span><br><span class="line">goharbor/redis-photon                  v2.13.1   27079bef6812   4 weeks ago    166MB</span><br><span class="line">goharbor/trivy-adapter-photon          v2.13.1   9d2de710e1bc   4 weeks ago    387MB</span><br><span class="line">goharbor/harbor-registryctl            v2.13.1   1ca7f7dffcb8   4 weeks ago    162MB</span><br><span class="line">goharbor/registry-photon               v2.13.1   251eb949b8fc   4 weeks ago    85.9MB</span><br><span class="line">goharbor/nginx-photon                  v2.13.1   3a0ac2771512   4 weeks ago    151MB</span><br><span class="line">goharbor/harbor-log                    v2.13.1   49f7cdb104f3   4 weeks ago    164MB</span><br><span class="line">goharbor/harbor-jobservice             v2.13.1   b964386ce624   4 weeks ago    174MB</span><br><span class="line">goharbor/harbor-core                   v2.13.1   701038c9f9cf   4 weeks ago    197MB</span><br><span class="line">goharbor/harbor-portal                 v2.13.1   254c145df624   4 weeks ago    159MB</span><br><span class="line">goharbor/harbor-db                     v2.13.1   8645cd204f13   4 weeks ago    273MB</span><br><span class="line">goharbor/prepare                       v2.13.1   eeb5b545352d   4 weeks ago    208MB</span><br><span class="line">...忽略...</span><br></pre></td></tr></table></figure>





<p><strong>生成docker-compose启动项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成docker-compose启动文件，并启动容器</span></span><br><span class="line">[root@localhost harbor]# ./prepare </span><br><span class="line">prepare base <span class="built_in">dir</span> is <span class="built_in">set</span> to /opt/softapp/harbor</span><br><span class="line">Clearing the configuration file: /config/portal/nginx.conf</span><br><span class="line">Clearing the configuration file: /config/log/logrotate.conf</span><br><span class="line">Clearing the configuration file: /config/log/rsyslog_docker.conf</span><br><span class="line">Clearing the configuration file: /config/nginx/nginx.conf</span><br><span class="line">Clearing the configuration file: /config/core/env</span><br><span class="line">Clearing the configuration file: /config/core/app.conf</span><br><span class="line">Clearing the configuration file: /config/registry/passwd</span><br><span class="line">Clearing the configuration file: /config/registry/config.yml</span><br><span class="line">Clearing the configuration file: /config/registry/root.crt</span><br><span class="line">Clearing the configuration file: /config/registryctl/env</span><br><span class="line">Clearing the configuration file: /config/registryctl/config.yml</span><br><span class="line">Clearing the configuration file: /config/db/env</span><br><span class="line">Clearing the configuration file: /config/jobservice/env</span><br><span class="line">Clearing the configuration file: /config/jobservice/config.yml</span><br><span class="line">Generated configuration file: /config/portal/nginx.conf</span><br><span class="line">Generated configuration file: /config/log/logrotate.conf</span><br><span class="line">Generated configuration file: /config/log/rsyslog_docker.conf</span><br><span class="line">Generated configuration file: /config/nginx/nginx.conf</span><br><span class="line">Generated configuration file: /config/core/env</span><br><span class="line">Generated configuration file: /config/core/app.conf</span><br><span class="line">Generated configuration file: /config/registry/config.yml</span><br><span class="line">Generated configuration file: /config/registryctl/env</span><br><span class="line">Generated configuration file: /config/registryctl/config.yml</span><br><span class="line">Generated configuration file: /config/db/env</span><br><span class="line">Generated configuration file: /config/jobservice/env</span><br><span class="line">Generated configuration file: /config/jobservice/config.yml</span><br><span class="line">copy /data/secret/tls/harbor_internal_ca.crt to shared trust ca <span class="built_in">dir</span> as name harbor_internal_ca.crt ...</span><br><span class="line">ca file /hostfs/data/secret/tls/harbor_internal_ca.crt is not exist</span><br><span class="line">copy  to shared trust ca <span class="built_in">dir</span> as name storage_ca_bundle.crt ...</span><br><span class="line">copy None to shared trust ca <span class="built_in">dir</span> as name redis_tls_ca.crt ...</span><br><span class="line">loaded secret from file: /data/secret/keys/secretkey</span><br><span class="line">Generated configuration file: /compose_location/docker-compose.yml</span><br><span class="line">Clean up the input <span class="built_in">dir</span></span><br><span class="line"><span class="comment"># 检查Harbor容器是否正常启动</span></span><br><span class="line">[root@localhost harbor]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                 COMMAND                   CREATED          STATUS                    PORTS                                                                                NAMES</span><br><span class="line">53d7bdcf6d38   goharbor/harbor-jobservice:v2.13.1    <span class="string">&quot;/harbor/entrypoint.…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        harbor-jobservice</span><br><span class="line">4c8477948f20   goharbor/nginx-photon:v2.13.1         <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)   0.0.0.0:80-&gt;8080/tcp, [::]:80-&gt;8080/tcp, 0.0.0.0:443-&gt;8443/tcp, [::]:443-&gt;8443/tcp   nginx</span><br><span class="line">230a18014ab1   goharbor/harbor-core:v2.13.1          <span class="string">&quot;/harbor/entrypoint.…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        harbor-core</span><br><span class="line">500542b8846a   goharbor/harbor-registryctl:v2.13.1   <span class="string">&quot;/home/harbor/start.…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        registryctl</span><br><span class="line">c981c91c8842   goharbor/registry-photon:v2.13.1      <span class="string">&quot;/home/harbor/entryp…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        registry</span><br><span class="line">24fac7ba05eb   goharbor/redis-photon:v2.13.1         <span class="string">&quot;redis-server /etc/r…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        redis</span><br><span class="line">18ddfef136e2   goharbor/harbor-portal:v2.13.1        <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        harbor-portal</span><br><span class="line">585daf92fd4c   goharbor/harbor-db:v2.13.1            <span class="string">&quot;/docker-entrypoint.…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)                                                                                        harbor-db</span><br><span class="line">0291f8c0fff2   goharbor/harbor-log:v2.13.1           <span class="string">&quot;/bin/sh -c /usr/loc…&quot;</span>   16 minutes ago   Up 16 minutes (healthy)   127.0.0.1:1514-&gt;10514/tcp                                                            harbor-log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	验证启动后就可以使用宿主机IP+端口验证一下浏览器是否可能正常Harbor：</p>
<p>​	默认的管理员账号为：admin，他的密码在harbor.yml配置文件中设置找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看管理员默认密码</span></span><br><span class="line">[root@localhost harbor]# grep harbor_admin_password  harbor.yml</span><br><span class="line">harbor_admin_password: Harbor12345</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250626105008459.png" alt="image-20250626105008459"></p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250626105815406.png" alt="image-20250626105815406"></p>
<h2 id="将Harbor服务加入守护进程"><a href="#将Harbor服务加入守护进程" class="headerlink" title="将Harbor服务加入守护进程"></a>将Harbor服务加入守护进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost harbor]# <span class="built_in">cat</span> &gt; /etc/systemd/system/harbor.service &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Harbor</span></span><br><span class="line"><span class="string">After=docker.service systemd-networkd.service systemd-resolved.service</span></span><br><span class="line"><span class="string">Requires=docker.service</span></span><br><span class="line"><span class="string">Documentation=http://github.com/vmware/harbor</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">RestartSec=5</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/docker compose -f /opt/softapp/harbor/docker-compose.yml up</span></span><br><span class="line"><span class="string">ExecStop=/usr/bin/docker compose -f /opt/softapp/harbor/docker-compose.yml down</span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">[root@localhost harbor]# <span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line">[root@localhost harbor]# systemctl <span class="built_in">enable</span> harbor --now</span><br></pre></td></tr></table></figure>



<h2 id="私有镜像的上传及拉取"><a href="#私有镜像的上传及拉取" class="headerlink" title="私有镜像的上传及拉取"></a>私有镜像的上传及拉取</h2><p>​	由于我们采用的是HTTPS协议，之后我们每台docker宿主机需要从这个Harbor私有仓库拉取和上传镜像都需要将我们的服务器证书办法给他们，否则直接拉取会提示未经授权等错误信息。</p>
<p>​	<strong>配置docker加速文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liweihu docker]# <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">    &quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">  &quot;insecure-registries&quot;: [&quot;reg.liweihu.cn&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 按照如下层级目录创建并下发签名文件</span></span><br><span class="line">[root@liweihu docker]# <span class="built_in">pwd</span></span><br><span class="line">/etc/docker</span><br><span class="line">[root@liweihu docker]# tree /etc/docker/certs.d/</span><br><span class="line">certs.d/</span><br><span class="line">└── reg.liweihu.cn</span><br><span class="line">    ├── ca.crt</span><br><span class="line">    ├── reg.liweihu.cn.cert</span><br><span class="line">    └── reg.liweihu.cn.key</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	尝试将本地镜像上传至私有仓库，验证服务是否正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将需要上传的镜像使用tag选项将他的标签修改与仓库一直一致</span></span><br><span class="line">[root@localhost harbor]# docker tag docker.m.daocloud.io/nginx:latest reg.liweihu.cn/library/nginx:1.2</span><br><span class="line"><span class="comment"># 登录私有仓库</span></span><br><span class="line">[root@reg ~]# docker login -u admin -p admin reg.liweihu.cn</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login Succeeded</span><br><span class="line"><span class="comment"># 上传镜像至私有仓库</span></span><br><span class="line">[root@liweihu docker]# docker push reg.liweihu.cn/library/nginx:1.2</span><br><span class="line">The push refers to repository [reg.liweihu.cn/library/nginx]</span><br><span class="line">79604f2021db: Pushed </span><br><span class="line">7e893c1b6ee8: Pushed </span><br><span class="line">463308bed0c9: Pushed </span><br><span class="line">4197a611afec: Pushed </span><br><span class="line">3e96162769d5: Pushed </span><br><span class="line">892e805f6f4f: Pushed </span><br><span class="line">626ab8a5d57b: Pushed </span><br><span class="line">7fb72a7d1a8e: Pushed </span><br><span class="line">1.2: digest: sha256:5eca17f8607d18e0e0059bb6ae5c7cf3627e472a2b14e2a4b1e2011551377286 size: 1986</span><br></pre></td></tr></table></figure>

<p>​	此时就可以再UI界面查看到我们上传的nginx镜像已经上来了，里面有一个版本号为1.2。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250626183001529.png" alt="image-20250626183001529"></p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250626183056142.png" alt="image-20250626183056142"></p>
<h1 id="容器的资源配额"><a href="#容器的资源配额" class="headerlink" title="容器的资源配额"></a>容器的资源配额</h1><p>​	服务在运行的时候都是依赖内存、磁盘、I&#x2F;O，那么我们通过docker run命令创建的容器他是一个完全隔离的一个环境，那么他的资源又是从何而来，每个容器的配额又是多少？</p>
<p>​	通过创建两个容器查看他的资源情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">[root@reg ~]# docker run -d --name job-01 reg.liweihu.cn/library/nginx:1.2 </span><br><span class="line">5416634d099c26bf9e8468b15b2c5aa5845a980244d706a92e7656c47a93dfa0</span><br><span class="line">[root@reg ~]# docker run -d --name job-02 reg.liweihu.cn/library/nginx:1.2 </span><br><span class="line">88566e4d11c95a99289f331b0142cf175b75600a330e17c565c10be65261b23b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式进入容器查看容器内的/proc/meminfo内存文件</span></span><br><span class="line">[root@reg ~]# docker <span class="built_in">exec</span> -it job-01 grep MemTotal /proc/meminfo</span><br><span class="line">MemTotal:        7836684 kB</span><br><span class="line">[root@reg ~]# </span><br><span class="line">[root@reg ~]# docker <span class="built_in">exec</span> -it job-02 grep MemTotal /proc/meminfo</span><br><span class="line">MemTotal:        7836684 kB</span><br><span class="line"><span class="comment"># 查看宿主机的内存配额</span></span><br><span class="line">[root@reg ~]# grep MemTotal /proc/meminfo</span><br><span class="line">MemTotal:        7836684 kB</span><br></pre></td></tr></table></figure>

<p>​	同时实验结论得出，每个容器的内存量全部等于物理宿主机的内存总量，这意味容器的资源都是共享着宿主机的资源，有着更好的性能，同时资源能得到更大的利用，但着也意味着业务量一旦急剧上升，可能会发生资源争抢的情况。</p>
<h2 id="容器内存限额"><a href="#容器内存限额" class="headerlink" title="容器内存限额"></a><strong>容器内存限额</strong></h2><p>​	这是我们要在规划时要提前规避的，可以使用-m或者–memory分配内存限额。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行一个容器，容器内存限额500M</span></span><br><span class="line">[root@reg stress-1.0.4]# docker run -d --name job-03 --memory 500M reg.liweihu.cn/library/nginx:1.2</span><br><span class="line"><span class="comment"># 查看内存限额</span></span><br><span class="line">[root@reg stress-1.0.4]# docker inspect job-03 | grep  Memory</span><br><span class="line">            <span class="string">&quot;Memory&quot;</span>: 524288000</span><br></pre></td></tr></table></figure>

<p>​	之后可以利用了解dockerfile制作一个带有stress服务的镜像进行压力测试，例如：-m限额500M，stress服务压力给到700M，超出后服务会异常宕机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=job-04 -m 500M progrium/stress \--vm 1 --vm-bytes 700M</span><br></pre></td></tr></table></figure>



<h2 id="容器CPU限额"><a href="#容器CPU限额" class="headerlink" title="容器CPU限额"></a><strong>容器CPU限额</strong></h2><p>​	默认情况下，所有的容器有使用相同的CPU资源，并且没有任何限制，这和内存是一样的，一但业务上升同样会引起CPU资源争抢，但和内存不同，CPU是通过指定相对权重值来进行配额的。</p>
<p>​	使用–cpu-shares参数队CPU进行配额，默认情况下这个值是1024。</p>
<p>​	<strong>注意：当前容器中的业务空闲时，其他的容器有权力使用其空闲的CPU，这将确保业务的性能。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg stress-1.0.4]# docker run -d --name cpu-1 --cpu-shares 1024 reg.liweihu.cn/library/nginx:1.2 </span><br><span class="line">de4ba33171bc5307e9e849db71517a1eea62395027de47e4b6e1dbfdb16c992c</span><br></pre></td></tr></table></figure>

<p>​	总结：CPU限额的分配，只有在宿主机资源不足的时候才会生效，并且是根据进程不同的优先级进行的，当其他容器空闲时，忙碌的容器可以获得全部可用CPU资源。</p>
<h2 id="管理容器的I-O配额"><a href="#管理容器的I-O配额" class="headerlink" title="管理容器的I&#x2F;O配额"></a>管理容器的I&#x2F;O配额</h2><p>​	默认情况下，所有的容器都可以使用相同的I&#x2F;O资源（500权重），并且没有任何限制，这和内存、CPU一样，一但I&#x2F;O需求上升，磁盘读写会变得非常迟钝，为了更好的提供服务，我们也要对容器使用硬盘方面进行配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg stress-1.0.4]# docker run -d --name 300io --blkio-weight 300 reg.liweihu.cn/library/nginx:1.2 </span><br><span class="line">ddb0a8ed6abaecde19cacd8c7b905a2f767ced5afab9aa80403659f1d165c183</span><br><span class="line">[root@reg stress-1.0.4]# docker run -d --name 600io --blkio-weight 600 reg.liweihu.cn/library/nginx:1.2 </span><br><span class="line">41d1c2e6c06aef694adb48975a4485d050c38e92aeb366c070ed39d4a9f80639</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">[root@reg stress-1.0.4]# docker <span class="built_in">exec</span> -it 600io /bin/bash</span><br><span class="line"><span class="comment"># 使用如下命令输出大文件，限额600的明显是比300的要快一些</span></span><br><span class="line"><span class="comment"># 限额600的容器，耗时9.94961 s</span></span><br><span class="line">root@41d1c2e6c06a:/usr/local# <span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=test.out bs=1M count=1024</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 9.94961 s, 108 MB/s</span><br><span class="line"></span><br><span class="line">real	0m9.965s</span><br><span class="line">user	0m0.000s</span><br><span class="line">sys	0m9.789s</span><br><span class="line">root@41d1c2e6c06a:/usr/local# </span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 进入限额300的容器，耗时10.4424 s</span></span><br><span class="line">[root@reg stress-1.0.4]# docker <span class="built_in">exec</span> -it 300io /bin/bash</span><br><span class="line">root@ddb0a8ed6aba:/# <span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=test.out bs=1M count=1024</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.4424 s, 103 MB/s</span><br><span class="line"></span><br><span class="line">real	0m10.445s</span><br><span class="line">user	0m0.001s</span><br><span class="line">sys	0m10.270s</span><br><span class="line">root@ddb0a8ed6aba:/#</span><br></pre></td></tr></table></figure>



<h1 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h1><p>​	docker run -it m.daocloud.io&#x2F;docker.io&#x2F;library&#x2F;busybox:latest </p>
<p>​	使用上述命令创建一个容器，尝试ping百度，发现我们在创建容器时并没有添加网卡，也没有设置IP地址，也没有路由，但是我们Ping操作是如何实现的？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg stress-1.0.4]# docker run -it m.daocloud.io/docker.io/library/busybox:latest </span><br><span class="line">/ <span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.baidu.com (157.148.69.151): 56 data bytes</span><br><span class="line">64 bytes from 157.148.69.151: <span class="built_in">seq</span>=0 ttl=127 <span class="keyword">time</span>=254.003 ms</span><br><span class="line">64 bytes from 157.148.69.151: <span class="built_in">seq</span>=1 ttl=127 <span class="keyword">time</span>=46.644 ms</span><br></pre></td></tr></table></figure>









<h2 id="容器原生网络"><a href="#容器原生网络" class="headerlink" title="容器原生网络"></a>容器原生网络</h2><p>​	docker原生提供了以下几种网络类型，如果我们对原生网络不满意，我们还可与创建自定义网络。</p>
<p>​	原生网络分为：none、bridge、host，这些网络在docker安装的时候会自动创建，我们可用通过以下命令来查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg stress-1.0.4]# docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME            DRIVER    SCOPE</span><br><span class="line">9b51f9051068   bridge          bridge    <span class="built_in">local</span></span><br><span class="line">745d3d625feb   harbor_harbor   bridge    <span class="built_in">local</span></span><br><span class="line">df38c270ec3c   host            host      <span class="built_in">local</span></span><br><span class="line">874b65d17e40   none            null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>



<p><strong>bridge网络</strong></p>
<p>​	docker容器默认使用的网络类型，可以通过–network&#x3D;bridge在创建容器时指定。他拥有独立的IP，同时也可以与外部进行通信，那是因为每个容器都会连接到一个内部网络的私有网桥，在安装docker的时候，他会自动为您的生成一个docker0的网桥，通过这个网桥使得内部网络与外部网络进行通信。</p>
<p>​	我们通过示例来理解一下bridge网络，首先我们先在宿主机上查看docker0虚拟网桥的ip段，是与宿主机不同的，这里我们先记住这个ip段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# ip a s</span><br><span class="line">...忽略...</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    <span class="built_in">link</span>/ether 42:25:74:09:22:66 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::4025:74ff:fe09:2266/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...忽略...</span><br></pre></td></tr></table></figure>

<p>​	随后创建一个网络类型为bridge的容器，并进入容器，同样查看他的网卡信息，除了一个lo回环地址外，他还有一个eth0的网卡，这个ip段与上面宿主机查的docker0虚拟网桥的ip段是同一个网段的，最后在容器内ping百度也是正常通信的。</p>
<p>​	结合以下结论可得出，bridge类型的容器，他使用的是docker0虚拟网桥生成出来的IP段，并将这个接口连接到虚拟桥接上，docker的桥接网络通常使用NAT（网络地址转换）来连接到物理网络，使得容器能够通过宿主机IP地址访问外部网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个网络类型为bridge的容器，并进去容器</span></span><br><span class="line">[root@reg ~]# docker run -it --network=bridge m.daocloud.io/docker.io/library/busybox:latest /bin/sh</span><br><span class="line"><span class="comment"># 查看容器的eth0网卡IP。</span></span><br><span class="line">/ <span class="comment"># ip a s</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    <span class="built_in">link</span>/ether 8a:95:50:50:79:0f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">#可以通过</span></span><br><span class="line">/ <span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.baidu.com (183.240.99.169): 56 data bytes</span><br><span class="line">64 bytes from 183.240.99.169: <span class="built_in">seq</span>=0 ttl=127 <span class="keyword">time</span>=40.259 ms</span><br><span class="line">^C</span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">1 packets transmitted, 1 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 40.259/40.259/40.259 ms</span><br><span class="line">/ <span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>none网络</strong></p>
<p>​	如果容器使用的是none网络，那么此容器将不再具备网卡，只具备lo网络，如果要使用这个网络，在创建容器时需要指定–network&#x3D;none即可。</p>
<p>​	对一些安全要求较高且不需要外部通信的场景可以使用none网络，使得数据更加私密，例如日志服务只需要通过卷的方式，往服务器中写入数据。</p>
<p>​	创建一个none网络类型的容器，并进入该容器查看容器网卡，发现none类型他是没有任何网卡的，只有一个lo回环网络，通过ping发现他是不能与外部进行通信的。</p>
<p>​	结论得出，none他是一个绝对私密的一个容器网络，所有在数据需要极高安全并且不需要进行外部通信，则可以使用none网络类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -it --network=none m.daocloud.io/docker.io/library/busybox:latest /bin/sh</span><br><span class="line">/ <span class="comment"># ip a s</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ <span class="comment"># ping www.baidu.com</span></span><br><span class="line">ping: bad address <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>host网络</strong></p>
<p>​	Host网络是一个共享宿主机网络的一个容器共享网络，可以通过–network&#x3D;host在创建容器时指定host网络，处于host网络模式的容器，网络配置和宿主机完全一样，也就是说在容器中可以看到宿主机的所有网卡，并且主机名也是宿主机的，他们共用同一个IP网络，这最大的好处就是性能很高，传输效率好，但是宿主机上已经使用的端口，容器是不可以重复使用的，同样容器使用了的端口，宿主机也是不可以使用的。</p>
<p>​	创建一个host网络类型的容器，并进入容器，查看容器ip后发现，拉出了很多数据，这些数据与宿主机的IP一摸一样，并且容器内也是可以访问外部网络的。</p>
<p>​	由此得出结论，host是直接与宿主机共享了网络，你的IP以及你所使用的端口都会直接使用到宿主机的网络，同时不存在NAT转换，所以他的网络速率要比桥接更快。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -it --network=host m.daocloud.io/docker.io/library/busybox:latest /bin/sh</span><br><span class="line">/ <span class="comment"># ip a s</span></span><br><span class="line">....忽略....</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:<span class="built_in">cd</span>:fb:4c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.8.135/24 brd 192.168.8.255 scope global noprefixroute ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fecd:fb4c/64 scope <span class="built_in">link</span> noprefixroute </span><br><span class="line">....忽略....</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    <span class="built_in">link</span>/ether 42:25:74:09:22:66 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global </span><br><span class="line">....忽略....</span><br><span class="line">/ <span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.baidu.com (157.148.69.151): 56 data bytes</span><br><span class="line">64 bytes from 157.148.69.151: <span class="built_in">seq</span>=0 ttl=128 <span class="keyword">time</span>=41.224 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Docker网络端口映射"><a href="#Docker网络端口映射" class="headerlink" title="Docker网络端口映射"></a>Docker网络端口映射</h2><p>​	我们上述了解完docker的网络，都是针对容器如何进行外部的访问，那么假设我的容器是个nginx服务，我外部需要访问容器内的服务，那么我该怎么做。</p>
<p>​	创建好nginx容器后，我们ps发现它只有一个容器内部的80端口存在，我们也不知道它的ip是多少，随后我们进入容器发现ip a s查看ip的命令也没有，我们无从得知它的ip，即使我们就算得知它的ip，我们客户端也不可能访问到容器内部的ip，而且容器的IP是随机的，每次重启容器都会随机生成一个内部的虚拟IP或没有IP，但是我们容器内访问这个80端口是能访问到nginx服务是正常的，所以即使我们创建出来了容器，但是满足不了我们实际业务中，客户端要访问这个服务的需求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -d --name nginx-01 docker.m.daocloud.io/nginx:latest</span><br><span class="line">9c8de73f0c70f832dc2d7925c32b4fde6f267f82edc077f4878612976818ea04</span><br><span class="line">[root@reg ~]# docker ps </span><br><span class="line">CONTAINER ID   IMAGE                                 COMMAND                   CREATED          STATUS                 PORTS                                                                                NAMES</span><br><span class="line">9c8de73f0c70   docker.m.daocloud.io/nginx:latest     &quot;/docker-entrypoint.…&quot;   18 seconds ago   Up 17 seconds          80/tcp                                                                               nginx-01</span><br><span class="line">[root@reg ~]# docker exec -it nginx-01 /bin/bash</span><br><span class="line">root@9c8de73f0c70:/# ip a s</span><br><span class="line">bash: ip: command not found</span><br><span class="line">root@9c8de73f0c70:/# curl 127.0.0.1 80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">....忽略....</span><br></pre></td></tr></table></figure>



<p>​	对于这类情况，我们就要介绍到端口映射的内容，对于需要客户端访问的服务，我们可以将容器的端口通过映射的方式转到我们宿主机的某一指定端口，客户端即可直接访问固定的宿主机IP+映射端口访问到我们的容器服务。</p>
<p>​	选项说明：</p>
<ul>
<li><p>-p（小写）指定宿主机某一端口进行映射。</p>
</li>
<li><p>-P（大写）随机宿主机某一端口进行映射。</p>
<p>以下示例使用-P（大写）将nginx容器中的80端口随机生成一个宿主机端口进行映射，随机产生了宿主机32768端口映射到容器中的80端口，所以我们客户端要访问容器的80服务，就可以使用宿主机的IP+32768端口进行访问。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -d -P --name nginx-02 docker.m.daocloud.io/nginx:latest</span><br><span class="line">6bc39954ad93248b160b9f059ca6d824b2285fdce530a1e964c89beab3a52439</span><br><span class="line">[root@reg ~]# </span><br><span class="line">[root@reg ~]# </span><br><span class="line">[root@reg ~]# docker ps </span><br><span class="line">CONTAINER ID   IMAGE                                 COMMAND                   CREATED          STATUS                 PORTS                                                                                NAMES</span><br><span class="line">6bc39954ad93   docker.m.daocloud.io/nginx:latest     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   9 seconds ago    Up 8 seconds           0.0.0.0:32768-&gt;80/tcp, [::]:32768-&gt;80/tcp                                            nginx-02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	使用浏览器访问宿主机IP+端口，验证通过。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250630163338736.png" alt="image-20250630163338736"></p>
<p>​	以下示例使用-p（小写）创建一个nginx容器服务，它会根据您指定的端口进行映射，指定81端口映射到容器中的80端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -d -p 81:80 --name nginx-03 docker.m.daocloud.io/nginx:latest</span><br><span class="line">600d76d166900138f9ddc0ca6d46bbee48b7965992ab171bf161749ce93b1cc3</span><br><span class="line">[root@reg ~]# docker ps </span><br><span class="line">CONTAINER ID   IMAGE                                 COMMAND                   CREATED          STATUS                 PORTS                                                                                NAMES</span><br><span class="line">600d76d16690   docker.m.daocloud.io/nginx:latest     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   3 seconds ago    Up 2 seconds           0.0.0.0:81-&gt;80/tcp, [::]:81-&gt;80/tcp                                                  nginx-03</span><br></pre></td></tr></table></figure>

<p>​	使用浏览器访问宿主机IP+端口，验证通过。</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250630163707191.png" alt="image-20250630163707191"></p>
<h2 id="配置容器DNS"><a href="#配置容器DNS" class="headerlink" title="配置容器DNS"></a>配置容器DNS</h2><p>​	配置容器的DNS可在宿主机的&#x2F;etc&#x2F;docker&#x2F;daemon.json文件中增加所有容器默认的DNS,在该文件中增加dns参数，重启docker后生效，之后所有的容器默认都有拥有这两个dns。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liweihu docker]# <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">    &quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">  &quot;insecure-registries&quot;: [&quot;reg.liweihu.cn&quot;],</span></span><br><span class="line"><span class="string">  &quot;dns&quot;: [&quot;114.114.114.114&quot;,&quot;8.8.8.8&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">[root@reg ~]# systemctl daemon-reload </span><br><span class="line">[root@reg ~]# systemctl restart docker.service</span><br></pre></td></tr></table></figure>

<p>​	创建一个容器，执行cat查看容器内的etc&#x2F;resolv.conf文件，验证通过，容器内的dns配置文件默认dns为配置的dns。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run --name dns-1 m.daocloud.io/docker.io/library/busybox:latest <span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line"><span class="comment"># Generated by Docker Engine.</span></span><br><span class="line"><span class="comment"># This file can be edited; Docker Engine will not make further changes once it</span></span><br><span class="line"><span class="comment"># has been modified.</span></span><br><span class="line"></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">search liweihu.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># Based on host file: &#x27;/etc/resolv.conf&#x27; (legacy)</span></span><br><span class="line"><span class="comment"># Overrides: [nameservers]</span></span><br></pre></td></tr></table></figure>



<p>​	如有容器需要指定特殊的dns，则可以在创建容器时使用–dns选项进行指定。</p>
<ul>
<li>-dns：为该容器指定一个dns。</li>
<li>-dns-search：为该容器指定一个dns搜索域，搜索域设置为<code>test.com</code>，请求的域名为<code>example</code>时，系统会将其补全为<code>example.test.com</code></li>
<li>-h：为该容器设置主机名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run --name dns-2 --dns 2.2.2.2 --dns-search test.com -h test-dns m.daocloud.io/docker.io/library/busybox:latest <span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line"><span class="comment"># Generated by Docker Engine.</span></span><br><span class="line"><span class="comment"># This file can be edited; Docker Engine will not make further changes once it</span></span><br><span class="line"><span class="comment"># has been modified.</span></span><br><span class="line"></span><br><span class="line">nameserver 2.2.2.2</span><br><span class="line">search test.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Based on host file: &#x27;/etc/resolv.conf&#x27; (legacy)</span></span><br><span class="line"><span class="comment"># Overrides: [nameservers search]</span></span><br></pre></td></tr></table></figure>





<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="容器和层"><a href="#容器和层" class="headerlink" title="容器和层"></a>容器和层</h2><p>​	容器和镜像最大的不同在于最顶部的可写层，所有在容器中的数据写入和修改都会直接存储到这个可写层，这就意味着当容器被删除，可写层中的数据就丢失了，虽然每个容器都有自己不同的可写层，但是容器底层的镜像却是可以同时共享的，</p>
<p><img src="/2025/06/05/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20250702155805125.png" alt="image-20250702155805125"></p>
<h2 id="Copy-on-write策略"><a href="#Copy-on-write策略" class="headerlink" title="Copy-on-write策略"></a>Copy-on-write策略</h2><table>
<thead>
<tr>
<th>操作</th>
<th>具体执行</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建文件</strong></td>
<td>新文件只能被添加在容器层中</td>
</tr>
<tr>
<td><strong>删除文件</strong></td>
<td>依据容器分层结构由上往下依次查找。找到后，在容器层中记录该删除操作。具体实现是，UnionFS会在容器层创建一个“whiteout”文件，将被删除的文件“遮挡”起来</td>
</tr>
<tr>
<td><strong>修改文件</strong></td>
<td>依据容器分层结构由上往下依次查找。找到后，镜像层中的数据复制到容器层进行修改，修改后的数据保存在容器层中。</td>
</tr>
<tr>
<td><strong>读取文件</strong></td>
<td>依据容器分层结构由上往下依次查找。</td>
</tr>
</tbody></table>
<h2 id="容器数据管理-Volume"><a href="#容器数据管理-Volume" class="headerlink" title="容器数据管理-Volume"></a>容器数据管理-Volume</h2><p>​	如果我们要使用Volume卷挂在的方式来进行容器数据的管理，我们可以使用-v的选项。这样我们将容器内的数据文件映射到宿主机，通过宿主机来管理如容器内的配置文件。</p>
<p><strong>参数说明：</strong></p>
<ul>
<li>-v [容器需挂载的目录]</li>
</ul>
<p>​	创建一个容器，将容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;“目录做成卷的方式进行管理，查看容器详细信息，发现该容器的数据类型为volume【卷】，卷的名字为【e38a7e9eb……】，该卷在宿主机中的【&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;e38a7…..】目录下进行管理，对应挂载了容器内的【”&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html”】目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker run -d -v /usr/share/nginx/html/ -p 81:80 docker.m.daocloud.io/nginx:latest </span><br><span class="line">53de2bd999b7cfb2a0b8411176d635462f5680ebf207d9dd838e3b5dead1a2f3</span><br><span class="line"></span><br><span class="line">[root@reg ~]# docker inspect 53de2bd999b7 | grep -A 10 Mounts</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/usr/share/nginx/html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">[root@reg ~]# docker volume <span class="built_in">ls</span> | grep <span class="string">&quot;e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d&quot;</span></span><br><span class="line"><span class="built_in">local</span>     e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d</span><br><span class="line"><span class="comment"># 尝试修改挂载到宿主机的容器数据文件</span></span><br><span class="line">[root@reg ~]# <span class="built_in">echo</span> <span class="string">&quot;这是一个lovume的容器卷实验&quot;</span> &gt; /var/lib/docker/volumes/e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d/_data/index.html</span><br><span class="line"><span class="comment"># 访问容器服务，容器内的数据文件确实已被修改</span></span><br><span class="line">[root@reg ~]# curl 127.0.0.1:81</span><br><span class="line">这是一个lovume的容器卷实验</span><br><span class="line"><span class="comment"># 即使我将容器给删除</span></span><br><span class="line">[root@reg ~]# docker <span class="built_in">rm</span> 53de2bd999b7 --force </span><br><span class="line">53de2bd999b7</span><br><span class="line"><span class="comment"># 他的数据卷依然存在</span></span><br><span class="line">[root@reg ~]# docker volume <span class="built_in">ls</span> | grep <span class="string">&quot;e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d&quot;</span></span><br><span class="line"><span class="built_in">local</span>     e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d</span><br><span class="line"><span class="comment"># 以及该目录下的文件依然存在</span></span><br><span class="line">[root@reg _data]# <span class="built_in">cat</span> /var/lib/docker/volumes/e38a7e9eb84c1f447ebab4f879c381cd0692b22ae84ef8bd08fe74e3241bb48d/_data/index.html </span><br><span class="line">这是一个lovume的容器卷实验</span><br></pre></td></tr></table></figure>

<p>​	但是大家会发现容器内的数据文件确认是挂载出来了，但是挂载出来到宿主机的这个目录实在是太长了，而且中间还是一串乱码，并且有过Linux基础的还会发现这个&#x2F;var目录下的都是临时文件，容器关机不会引起数据丢失，但是如果服务器关机重启，数据文件还是一样会丢失，并不能完全满足业务中的持久化存储以及便利性。</p>
<h2 id="数据管理-bind"><a href="#数据管理-bind" class="headerlink" title="数据管理-bind"></a>数据管理-bind</h2><p>​	为此我们可以使用更优解的方式，将指定的宿主机目录挂载到指定的指定的容器目录，互相mount绑定。</p>
<p><strong>参数说明：</strong></p>
<ul>
<li>-v [宿主机目录]:[容器目录]</li>
</ul>
<p>​	创建一个持久化的宿主机目录，然后创建容器并使用-v[宿主机目录]:[容器目录]将互相mount挂载，向宿主机目录写入文件已验证，查看容器详细信息可看到此刻绑定的卷类型为bind，以及他的宿主机源目录以及容器目标目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个我们需要持久化存储的目录</span></span><br><span class="line">[root@reg _data]# <span class="built_in">mkdir</span> /opt/nginx</span><br><span class="line"><span class="comment"># 创建一个容器，宿主机目录/opt/nginx:容器目录/usr/share/nginx/html/</span></span><br><span class="line">[root@reg ~]# docker run -d -v /opt/nginx:/usr/share/nginx/html/ -p 81:80 docker.m.daocloud.io/nginx:latest</span><br><span class="line"><span class="comment"># 像挂载目录写入文件。</span></span><br><span class="line">[root@reg opt]# <span class="built_in">echo</span> <span class="string">&quot;这是一个持久化mount的目录&quot;</span> &gt; /opt/nginx/index.html</span><br><span class="line"><span class="comment"># 验证是否修改了容器内的数据文件</span></span><br><span class="line">[root@reg opt]# curl 127.0.0.1:81</span><br><span class="line">这是一个持久化mount的目录</span><br><span class="line"><span class="comment"># 同时我们可以查看到容器详细信息，他绑定的卷类型为bind</span></span><br><span class="line">[root@reg opt]# docker inspect 5abc1cb9f4a5 | grep -A 10 Mounts</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/opt/nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/usr/share/nginx/html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	心细的可以他发现volume和bind查看容器详细信息时有个区别，bind少了name卷名称的参数，没错bind是mount挂载的方式，他不会新生成卷，所以你即使docker volume发现他是没有生成卷的。</p>
<p>​	之前我们介绍的Harbor官方也是采用bind方式来持久化存储我们所有上传的镜像文件，不然我们上传的镜像只要关闭容器或者关闭宿主机，上传的镜像就会丢失，以下示例可以验证以下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看我们harbor-db的服务，这是他的数据库</span></span><br><span class="line"><span class="comment"># 可以看出，他的数据是存放在我们宿主机的/data/database目录中的</span></span><br><span class="line">[root@reg opt]# docker inspect harbor-db | grep -A 10 Mounts</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/data/database&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/var/lib/postgresql/data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;rw,z&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;Config&quot;</span>: &#123;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第二章</title>
    <url>/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Kubernetes概述"><a href="#Kubernetes概述" class="headerlink" title="Kubernetes概述"></a>Kubernetes概述</h1><p>​	Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。</p>
<p>​	<strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。K8s 这个缩写是因为 K 和 s 之间有 8 个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 <a href="https://research.google/pubs/pub43438">Google 大规模运行生产工作负载十几年经验</a>的基础上， 结合了社区中最优秀的想法和实践。</p>
<h2 id="什么是Kubernetes"><a href="#什么是Kubernetes" class="headerlink" title="什么是Kubernetes"></a>什么是Kubernetes</h2><p>​	Kubernetes是一个可移植、可扩展的开源容器管理平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes拥有一个庞大且快速增长的生态系统。</p>
<p>​	它是由Google开发并开源的项目，现由云原生计算基金会（CNCF）维护，支持跨主机集群的容器化应用管理，提供负载均衡、自我修复、自动部署和存储编排等功能。</p>
<p>​	从Kubernetes的图标看，这个图标很像一艘船的船舵，控制着船行驶的方向。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250703101842759.png" alt="image-20250703101842759"></p>
<p>​	再看docker的图标，类似一艘轮船（运行时），轮船上放着许多集装箱（容器），前面我们了解了一些docker的基础，现在我们要学习Kubernetes。</p>
<p>​	就好比原先你是一个吭哧吭哧打工搬运集装箱上船的员工，由于你的出色表现得到董事长的赏识，董事长把你从搬运工提升为掌舵的小领导，以后你再也不用亲历亲为去做具体的事情了，再也不用想着我要怎么把集装箱（容器）搬上船了，以后您只用下达指令你的监工们去替你督促和管理你的搬运工去做具体的事情，从此走上人生巅峰迎娶白富美。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250703102753594.png" alt="image-20250703102753594"></p>
<h2 id="Kubernetes的历史背景"><a href="#Kubernetes的历史背景" class="headerlink" title="Kubernetes的历史背景"></a>Kubernetes的历史背景</h2><p>​	让我们回顾一下为何 Kubernetes 能够裨益四方。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250703104143438.png" alt="image-20250703104143438"></p>
<p><strong>传统部署时代：</strong></p>
<p>​	早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序， 而且维护许多物理服务器的成本很高。</p>
<p><strong>虚拟化部署时代：</strong></p>
<p>​	因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。</p>
<p>​	虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。</p>
<p>​	每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p>
<p><strong>容器部署时代：</strong></p>
<p>​	容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p>
<p>​	容器因具有许多优势而变得流行起来，例如：</p>
<ul>
<li><p>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</p>
</li>
<li><p>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。</p>
</li>
<li><p>关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。</p>
</li>
<li><p>可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</p>
</li>
<li><p>跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。</p>
</li>
<li><p>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</p>
</li>
<li><p>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</p>
</li>
<li><p>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</p>
</li>
<li><p>资源隔离：可预测的应用程序性能。</p>
</li>
<li><p>资源利用：高效率和高密度。</p>
</li>
</ul>
<h2 id="Kubernetes特点"><a href="#Kubernetes特点" class="headerlink" title="Kubernetes特点"></a>Kubernetes特点</h2><p>​	Kubernetes具有以下几个特点：</p>
<ul>
<li>可移植：支持公有云、私有云、混合云、多重云（multi-cloud）</li>
<li>可扩展：模块化、插件化、可挂载、可组合</li>
<li>自动化：自动部署、自动修复、自动重启、自动复制、自动伸缩&#x2F;扩展</li>
</ul>
<h2 id="Kubernetes作用"><a href="#Kubernetes作用" class="headerlink" title="Kubernetes作用"></a>Kubernetes作用</h2><p>​	容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？</p>
<p>​	这就是 Kubernetes 要来做的事情！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary (金丝雀) 部署。</p>
<p>Kubernetes 为你提供：</p>
<ul>
<li><p><strong>服务发现和负载均衡</strong></p>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p><strong>存储编排</strong></p>
<p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
</li>
<li><p><strong>自动部署和回滚</strong></p>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
</li>
<li><p><strong>自动完成装箱计算</strong></p>
<p>你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p>
</li>
<li><p><strong>自我修复</strong></p>
<p>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p>
</li>
<li><p><strong>密钥与配置管理</strong></p>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>
</li>
<li><p><strong>批处理执行</strong> 除了服务外，Kubernetes 还可以管理你的批处理和 CI（持续集成）工作负载，如有需要，可以替换失败的容器。</p>
</li>
<li><p><strong>水平扩缩</strong> 使用简单的命令、用户界面或根据 CPU 使用率自动对你的应用进行扩缩。</p>
</li>
<li><p><strong>IPv4&#x2F;IPv6 双栈</strong> 为 Pod（容器组）和 Service（服务）分配 IPv4 和 IPv6 地址。</p>
</li>
<li><p><strong>为可扩展性设计</strong> 在不改变上游源代码的情况下为你的 Kubernetes 集群添加功能。</p>
</li>
</ul>
<h2 id="Kubernetes整体框架"><a href="#Kubernetes整体框架" class="headerlink" title="Kubernetes整体框架"></a>Kubernetes整体框架</h2><p>​	Kubernetes 集群由一个控制平面和一组用于运行容器化应用的工作机器组成， 这些工作机器称作节点（Node）。每个集群至少需要一个工作节点来运行 Pod。</p>
<p>​	工作节点托管着组成应用负载的 Pod。控制平面管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行，而一个集群通常运行多个节点，以提供容错和高可用。</p>
<p>​	K8s整体需要至少一个Master节点和至少一个Node节点，所以要使用K8s我们至少需要两台服务器。</p>
<p>​	Master节点又称为控制平面，这里主要是我们的船长控制室也就是管理员的负责向Node节点下发指令的地方；Node节点也就是具体工人的工作室，Node节点同时会有一个监工小组长的角色（Kubelet），负责监督具体干活的Docker是否正在努力的工作。</p>
<p>​	使用Docker的时候我们指的是一个容器，而到了K8s这个概念变了，既然是集群，那么我们一个容器服务不能只有一个容器，不然达不到多负载、伸缩扩展的要求，例如一个nginx服务会生成多个容器，多个容器组成一个Pod的概念。</p>
<p>​	本文概述了构建一个完整且可运行的 Kubernetes 集群所需的各种组件。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250703112645294.png" alt="image-20250703112645294"></p>
<h3 id="控制平面组件"><a href="#控制平面组件" class="headerlink" title="控制平面组件"></a>控制平面组件</h3><p>​	控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足 Deployment 的 <code>replicas</code> （一个Pod扩展容器的数量）字段时，要启动新的Pod。</p>
<p>​	控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，安装脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户的服务容器。</p>
<h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>​	API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。API 服务器是 Kubernetes 控制平面的前端。</p>
<p>​	Kubernetes API 服务器的主要实现是 kube-apiserver。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量，这就是高级篇多Master节点实现高可用的K8s集群。</p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>​	一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库，主要记录着集群中由多少个Pod现在分别部署在那几个Node节点中等等集群数据。</p>
<p>​	如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份备份计划。</p>
<h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>​	<code>kube-scheduler</code> 是控制平面的组件， 负责监视新创建的、根据自身的算法来为容器服务指定Pod应该运行在哪个Node节点上为最适合的。选择节点来让 Pod 在上面运行。</p>
<p>​	调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>​	kube-controller-manager 是控制平面的组件， 负责运行控制器进程。</p>
<p>从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p>
<p>​	控制器有许多不同类型。以下是一些例子：</p>
<ul>
<li>Node 控制器：负责在节点出现故障时进行通知和响应</li>
<li>Job 控制器：监测代表一次性任务的 Job 对象，然后创建 Pod 来运行这些任务直至完成</li>
<li>EndpointSlice 控制器：填充 EndpointSlice 对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>ServiceAccount 控制器：为新的命名空间创建默认的 ServiceAccount。</li>
</ul>
<h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h4><p>​	一个 Kubernetes 控制平面组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不包含云控制器管理器。</p>
<p>​	与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中，以同一进程的方式供你运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p>
<p>下面的控制器都包含对云平台驱动的依赖：</p>
<ul>
<li>Node 控制器：用于在节点终止响应后检查云平台以确定节点是否已被删除</li>
<li>Route 控制器：用于在底层云基础架构中设置路由</li>
<li>Service 控制器：用于创建、更新和删除云平台上的负载均衡器</li>
</ul>
<h3 id="节点组件"><a href="#节点组件" class="headerlink" title="节点组件"></a>节点组件</h3><p>节点组件会在每个Node节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行时环境。</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p><code>kubelet</code> 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod中。</p>
<p>kubelet接收一组通过各类机制提供给它的 PodSpec，确保这些 PodSpec 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h4 id="kube-proxy（可选）"><a href="#kube-proxy（可选）" class="headerlink" title="kube-proxy（可选）"></a>kube-proxy（可选）</h4><p>​	kube-proxy是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service）概念的一部分。</p>
<p>​	kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>​	如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<p>​	如果你使用网络插件为 Service 实现本身的数据包转发， 并提供与 kube-proxy 等效的行为，那么你不需要在集群中的节点上运行 kube-proxy。</p>
<h4 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h4><p>​	这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的执行和生命周期。</p>
<p>​	Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O以及 Kubernetes CRI、CRI-docker (容器运行环境接口) 的其他任何实现。</p>
<h2 id="Kubernetes常用插件"><a href="#Kubernetes常用插件" class="headerlink" title="Kubernetes常用插件"></a>Kubernetes常用插件</h2><p>​	插件使用 Kubernetes 资源（DaemonSet、 Deployment 等)实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p>
<h3 id="Core-DNS"><a href="#Core-DNS" class="headerlink" title="Core-DNS"></a>Core-DNS</h3><p>​	尽管该插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有集群 DNS， 因为很多示例都需要 DNS 服务。</p>
<p>​	集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>​	Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p>
<h3 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）</h3><p>​	Dashboard是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身，并进行故障排除。</p>
<h3 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控</h3><p>​	容器资源监控 将关于容器的一些常见的时序度量值保存到一个集中的数据库中，并提供浏览这些数据的界面。</p>
<h3 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志</h3><p>​	集群层面日志机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p>
<h3 id="网络插件"><a href="#网络插件" class="headerlink" title="网络插件"></a>网络插件</h3><p>​	网络插件是实现容器网络接口（CNI）规范的软件组件。它们负责为 Pod 分配 IP 地址，并使这些 Pod 能在集群内部相互通信。</p>
<h1 id="部署Kubernetes"><a href="#部署Kubernetes" class="headerlink" title="部署Kubernetes"></a>部署Kubernetes</h1><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><table>
<thead>
<tr>
<th></th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>操作系统</strong></td>
<td>RedHat 9.4</td>
</tr>
<tr>
<td><strong>节点数量</strong></td>
<td>至少2，本示例为3</td>
</tr>
<tr>
<td><strong>CPU</strong></td>
<td>至少2核心，本示例为4核心</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>至少2G，本实例为8G</td>
</tr>
<tr>
<td><strong>磁盘</strong></td>
<td>100G</td>
</tr>
<tr>
<td><strong>网络</strong></td>
<td>公网和内网均可，只要3台彼此能够互联</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td>各节点主机名、MAC地址、product_uuid不可重复，如果使用VMware虚拟机避免使用克隆</td>
</tr>
</tbody></table>
<p><strong>IP规划</strong></p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>IP</th>
</tr>
</thead>
<tbody><tr>
<td>Master-01</td>
<td>192.168.8.136</td>
</tr>
<tr>
<td>Node-01</td>
<td>192.168.8.137</td>
</tr>
<tr>
<td>Node-02</td>
<td>192.168.8.138</td>
</tr>
</tbody></table>
<h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p><strong>关闭Swap分区</strong></p>
<p>​	需在三个节点都要执行关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapoff -a</span><br><span class="line">[root@localhost ~]# sed -i <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>



<p><strong>开启iptables 检查桥接流量</strong></p>
<p>​	需在三个节点都要执行开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">...忽略....</span><br><span class="line">[root@localhost ~]# <span class="built_in">sudo</span> sysctl --system</span><br><span class="line">* Applying /usr/lib/sysctl.d/10-default-yama-scope.conf ...</span><br><span class="line">...忽略....</span><br><span class="line"><span class="comment"># 验证net.ipv4.ip_forward 是否设置为 1</span></span><br><span class="line">[root@localhost ~]# sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>



<p><strong>配置主机名</strong></p>
<p>​	需在三个节点都要执行配置，可根据自身需要自行定义主机名，各节点主机名不可重复，主机名需具有识别性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.8.136设置的主机名</span></span><br><span class="line">[root@localhost ~]# hostnamectl hostname k8s-master-01</span><br><span class="line"><span class="comment"># 192.168.8.137设置的主机名</span></span><br><span class="line">[root@localhost ~]# hostnamectl hostname k8s-node-01</span><br><span class="line"><span class="comment"># 192.168.8.138设置的主机名</span></span><br><span class="line">[root@localhost ~]# hostnamectl hostname k8s-node-02</span><br></pre></td></tr></table></figure>



<p><strong>配置hosts域名解析</strong></p>
<p>​	需在三个节点都要执行配置，写入参数需根据自身的IP和主机名进行调整。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.8.136 k8s-master-01</span></span><br><span class="line"><span class="string">192.168.8.137 k8s-node-01</span></span><br><span class="line"><span class="string">192.168.8.138 k8s-node-02</span></span><br><span class="line"><span class="string">192.168.8.135 reg.liweihu.cn</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>





<h2 id="部署运行时docker"><a href="#部署运行时docker" class="headerlink" title="部署运行时docker"></a>部署运行时docker</h2><p>​	这里我们采用的运行时是docker引擎，docker 引擎的部署我们在第一章已经介绍过了，可以参考第一章的【离线部署docker】进行部署。</p>
<p>​	我们本次采用的是docker，v1.24 之前的 Kubernetes 版本直接集成了 Docker引擎的一个组件，名为 <strong>dockershim</strong>。但是之后的版本K8S将不在替Docker搞特殊去维护他的组件了，所以把这部分三方运行时接口删除，交给第三方docker自行去维护，docker之后就将这部分运行时接口改名为<strong>CRI-Docker</strong>，所以我们只使用docker不需要他的CRI，如果想用docker作为K8S的运行时则必须要安装docker的CRI。</p>
<p>​	默认情况下，K8s使用容器运行时接口来与你所选择的容器运行时进行交互。</p>
<p>​	如果您在部署时不指定运行时，则Kubeadm会自动尝试检测您系统上已安装的运行时，方法是扫描众所周知的Unix域套接字。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704102832282.png" alt="image-20250704102832282"></p>
<p>​	<strong>运行时常用套接字</strong></p>
<table>
<thead>
<tr>
<th>运行时</th>
<th>默认Linux中的套接字</th>
</tr>
</thead>
<tbody><tr>
<td>cri-dockerd</td>
<td>&#x2F;run&#x2F;cri-dockerd.sock</td>
</tr>
<tr>
<td>containerd</td>
<td>&#x2F;run&#x2F;containerd&#x2F;containerd.sock</td>
</tr>
<tr>
<td>CRI-O</td>
<td>&#x2F;var&#x2F;run&#x2F;crio&#x2F;crio.sock</td>
</tr>
</tbody></table>
<h3 id="CRI-Docker部署"><a href="#CRI-Docker部署" class="headerlink" title="CRI-Docker部署"></a>CRI-Docker部署</h3><p><strong>CRI-Docker下载地址</strong>：<a href="https://github.com/Mirantis/cri-dockerd/releases">https://github.com/Mirantis/cri-dockerd/releases</a></p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704112451966.png" alt="image-20250704112451966"></p>
<p><strong>CRI-Docker.service启动文件下载地址</strong>：<a href="https://github.com/Mirantis/cri-dockerd/blob/master/packaging/systemd/cri-docker.service">https://github.com/Mirantis/cri-dockerd/blob/master/packaging/systemd/cri-docker.service</a></p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704112607046.png" alt="image-20250704112607046"></p>
<p><strong>cri-docker.socket启动文件下载地址</strong>：<a href="https://github.com/Mirantis/cri-dockerd/blob/master/packaging/systemd/cri-docker.socket">https://github.com/Mirantis/cri-dockerd/blob/master/packaging/systemd/cri-docker.socket</a></p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704144053145.png" alt="image-20250704144053145"></p>
<p><strong>解压压缩包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压二进制文件，并移动到PATH工作目录</span></span><br><span class="line">[root@k8s-master-01 softapp]# tar -zxvf /opt/softapp/cri-dockerd-0.4.0.amd64.tgz --strip-components=1 -C /usr/local/bin/ &amp;&amp; <span class="built_in">chmod</span> 775 /usr/local/bin/cri-dockerd</span><br><span class="line"><span class="comment"># 创建service文件用于systemd守护进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#为service文件授权775</span></span><br><span class="line">[root@k8s-master-01 softapp]# <span class="built_in">chmod</span> 775 /etc/systemd/system/cri-docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将cir-docker已守护进程的方式启动</span></span><br><span class="line">[root@k8s-master-01 softapp]# </span><br><span class="line">[root@k8s-master-01 softapp]# </span><br><span class="line">[root@k8s-master-01 softapp]# </span><br></pre></td></tr></table></figure>



<p><strong>创建systemd守护进程</strong></p>
<ul>
<li><strong>cri-docker.service</strong>守护进程配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# <span class="built_in">cat</span> &gt; /etc/systemd/system/cri-docker.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=CRI Interface for Docker Application Container Engine</span></span><br><span class="line"><span class="string">Documentation=https://docs.mirantis.com</span></span><br><span class="line"><span class="string">After=network-online.target firewalld.service docker.service</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string">Requires=cri-docker.socket</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd://</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -s HUP $MAINPID</span></span><br><span class="line"><span class="string">TimeoutSec=0</span></span><br><span class="line"><span class="string">RestartSec=2</span></span><br><span class="line"><span class="string">Restart=always</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that StartLimit* options were moved from &quot;Service&quot; to &quot;Unit&quot; in systemd 229.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Both the old, and new location are accepted by systemd 229 and up, so using the old location</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># to make them work for either version of systemd.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StartLimitBurst=3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># this option work for either version of systemd.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StartLimitInterval=60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LimitNOFILE=infinity</span></span><br><span class="line"><span class="string">LimitNPROC=infinity</span></span><br><span class="line"><span class="string">LimitCORE=infinity</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Comment TasksMax if your systemd version does not support it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Only systemd 226 and above support this option.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TasksMax=infinity</span></span><br><span class="line"><span class="string">Delegate=yes</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p><strong>cri-docker.socket</strong>守护进程配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# <span class="built_in">cat</span> &gt; /etc/systemd/system/cri-docker.socket &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=CRI Docker Socket for the API</span></span><br><span class="line"><span class="string">PartOf=cri-docker.service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Socket]</span></span><br><span class="line"><span class="string">ListenStream=%t/cri-dockerd.sock</span></span><br><span class="line"><span class="string">SocketMode=0660</span></span><br><span class="line"><span class="string">SocketUser=root</span></span><br><span class="line"><span class="string">SocketGroup=docker</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=sockets.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<p>​	<strong>修改守护进程配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# sed -i -e <span class="string">&#x27;s,/usr/bin/cri-dockerd --container-runtime-endpoint fd://,/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=reg.liweihu.cn/google_containers/pause:3.10,&#x27;</span> /etc/systemd/system/cri-docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将socket修改为root组</span></span><br><span class="line">[root@k8s-master-01 system]# sed -i -e <span class="string">&#x27;s,docker,root,&#x27;</span> /etc/systemd/system/cri-docker.socket</span><br><span class="line">[root@k8s-master-01 system]# sed -i -e <span class="string">&#x27;s,%t/cri-rootd.sock,/run/cri-dockerd.sock,&#x27;</span> /etc/systemd/system/cri-docker.socket</span><br></pre></td></tr></table></figure>



<p>​	<strong>启动cri-docker</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 system]# <span class="built_in">chmod</span> 775 /etc/systemd/system/cri-docker.s*</span><br><span class="line">[root@k8s-master-01 system]# systemctl daemon-reload </span><br><span class="line">[root@k8s-master-01 system]# systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br></pre></td></tr></table></figure>









<h2 id="部署kubeadm、kubelet、kubect"><a href="#部署kubeadm、kubelet、kubect" class="headerlink" title="部署kubeadm、kubelet、kubect"></a>部署kubeadm、kubelet、kubect</h2><p>​	下载地址：<a href="https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.33/rpm/x86_64/?spm=a2c6h.25603864.0.0.70ef7af3yMGs1u">https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.33/rpm/x86_64/?spm=a2c6h.25603864.0.0.70ef7af3yMGs1u</a></p>
<p>​	分别把这五个软件包分别下载最新版本</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704152754075.png" alt="image-20250704152754075"></p>
<ul>
<li><strong>kubeadm</strong>：用于初始化集群的工具包指令。</li>
<li><strong>kubelet</strong>：在集群中的每个节点上用来启动Pod和容器等。</li>
<li><strong>kubectl</strong>：用来与集群通信的命令行工具。</li>
<li><strong>cni</strong>：kubelet的依赖程序。</li>
<li><strong>tools</strong>：kubeadm的依赖程序</li>
</ul>
<p>​	<strong>注意：您需要确保它们与通过kubeadm安装的控制平面版本相匹配。不然可能会导致一些预料之外的错误。然而控制平面与kubelet之间相差一个次要版本不一致是支持的，但kubelet的版本不可以超过API服务器的版本。例如1.7.0版本的kubelet可以兼容1.8.0本版本的API，1.8.0的API不能兼容1.7.0的kubelet。</strong></p>
<p>​	<strong>所以为了避免出现不可预料的问题，还是建议尽量所有组件统一版本。</strong></p>
<p>​	<strong>conntrack-tools及相关依赖下载地址</strong>：<a href="https://mirrors.aliyun.com/redhat/rhel/rhel-9-beta/appstream/x86_64/Packages/?spm=a2c6h.25603864.0.0.6192773eKiz0x9">https://mirrors.aliyun.com/redhat/rhel/rhel-9-beta/appstream/x86_64/Packages/?spm=a2c6h.25603864.0.0.6192773eKiz0x9</a></p>
<p>​	<strong>同一下载界面需要下载以下软件包：<code>libnetfilter_cthelper</code>、<code>libnetfilter_cttimeout</code>、<code>libnetfilter_queue</code>，例如下图，通过浏览器CTRL+F进行搜索下载</strong></p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250704155507533.png" alt="image-20250704155507533"></p>
<h3 id="部署相关组件"><a href="#部署相关组件" class="headerlink" title="部署相关组件"></a>部署相关组件</h3><p>​	软件包下载并上传至三个节点，最后一次按照顺序执行rpm安装程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# rpm -ivh libnetfilter*.rpm</span><br><span class="line">[root@k8s-master-01 softapp]# rpm -ivh conntrack-tools-1.4.5-9.el9.x86_64.rpm </span><br><span class="line">[root@k8s-master-01 softapp]# rpm -ivh kubernetes-cni-1.6.0-150500.1.1.x86_64.rpm cri-tools-1.33.0-150500.1.1.x86_64.rpm</span><br><span class="line">[root@k8s-master-01 softapp]# rpm -ivh kubeadm-1.33.2-150500.1.1.x86_64.rpm kubectl-1.33.2-150500.1.1.x86_64.rpm kubelet-1.33.2-150500.1.1.x86_64.rpm</span><br><span class="line"><span class="comment"># 加入自启</span></span><br><span class="line">[root@k8s-master-01 softapp]# systemctl <span class="built_in">enable</span> --now kubelet.service</span><br></pre></td></tr></table></figure>

<p>​	验证kubeadm、kubelet、kubectl版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# kubeadm version</span><br><span class="line">[root@k8s-master-01 softapp]# kubectl version</span><br><span class="line">[root@k8s-master-01 softapp]# kubelet --version</span><br></pre></td></tr></table></figure>



<p><strong>添加命令补全功能</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 softapp]# kubectl completion bash &gt; /etc/bash_completion.d/kubectl</span><br><span class="line">[root@k8s-master-01 softapp]# kubeadm completion bash &gt; /etc/bash_completion.d/kubeadm</span><br><span class="line">[root@k8s-master-01 softapp]# <span class="built_in">source</span> /etc/bash_completion.d/kubectl</span><br><span class="line">[root@k8s-master-01 softapp]# <span class="built_in">source</span> /etc/bash_completion.d/kubeadm</span><br></pre></td></tr></table></figure>





<h2 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h2><p>​	通过具有外网的Habor主机拉取所需镜像，如果您的Harbor不具备外网，则可以先使用您具备外网的docker将镜像拉取到本地，然后通过docker save和docker load将镜像保存成tar文件再导入进您的Harbor主机中。</p>
<p><strong>拉取镜像</strong></p>
<p>​	harbor主机上执行拉取镜像的任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.33.0</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.33.0</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.33.0</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.33.0</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/etcd:3.5.21-0</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/pause:3.10</span><br><span class="line">[root@reg ~]# docker pull registry.aliyuncs.com/google_containers/coredns:v1.12.0</span><br></pre></td></tr></table></figure>



<p><strong>为镜像重新打上新的标签</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/kube-apiserver:v1.33.0 reg.liweihu.cn/google_containers/kube-apiserver:v1.33.0</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.33.0 reg.liweihu.cn/google_containers/kube-proxy:v1.33.0</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/kube-controller-manager:v1.33.0 reg.liweihu.cn/google_containers/kube-controller-manager:v1.33.0</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/kube-scheduler:v1.33.0 reg.liweihu.cn/google_containers/kube-scheduler:v1.33.0</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/etcd:3.5.21-0 reg.liweihu.cn/google_containers/etcd:3.5.21-0</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/pause:3.10 reg.liweihu.cn/google_containers/pause:3.10</span><br><span class="line">[root@reg ~]# docker tag registry.aliyuncs.com/google_containers/coredns:v1.12.0 reg.liweihu.cn/google_containers/coredns:v1.12.0</span><br></pre></td></tr></table></figure>



<p><strong>上传Harbor仓库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/kube-apiserver:v1.33.0</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/kube-scheduler:v1.33.0</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/kube-controller-manager:v1.33.0</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/kube-proxy:v1.33.0</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/etcd:3.5.21-0</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/pause:3.10</span><br><span class="line">[root@reg ~]# docker push reg.liweihu.cn/google_containers/coredns:v1.12.0</span><br></pre></td></tr></table></figure>



<h3 id="Master节点集群初始化"><a href="#Master节点集群初始化" class="headerlink" title="Master节点集群初始化"></a>Master节点集群初始化</h3><p>​	Master节点上执行，他会为您将仓库中的K8s镜像拉到本地，然后为您的集群制作证书等初始化配置。</p>
<p>​	初始化完成后，输出的信息一定要保存好，这个非常重要，我们需要用它输出的命令来完成最后的操作，以及node节点的加入集群。</p>
<p>​	<strong>参数解析</strong></p>
<ul>
<li><strong>–apiserver-advertise-address</strong>：Master节点IP</li>
<li><strong>–apiserver-bind-port</strong>：Master中的API端口</li>
<li><strong>–kubernetes-version</strong>：k8s版本</li>
<li><strong>–cri-socket</strong>：运行时的sock文件路径</li>
<li><strong>–service-dns-domain</strong>：dns域</li>
<li><strong>–image-repository</strong>：镜像仓库地址</li>
<li><strong>–service-cidr</strong>：service服务发现网段</li>
<li><strong>–pod-network-cidr</strong>：pod网段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 etc]# kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.8.136 \</span><br><span class="line">--apiserver-bind-port=6443 \</span><br><span class="line">--kubernetes-version=1.33.0 \</span><br><span class="line">--token-ttl=0 \</span><br><span class="line">--cri-socket=/run/cri-dockerd.sock \</span><br><span class="line">--service-dns-domain=cluster.local \</span><br><span class="line">--image-repository reg.liweihu.cn/google_containers \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line">[init] Using Kubernetes version: v1.33.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING Firewalld]: firewalld is active, please ensure ports [6443 10250] are open or your cluster may not <span class="keyword">function</span> correctly</span><br><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action beforehand using <span class="string">&#x27;kubeadm config images pull&#x27;</span></span><br><span class="line">[certs] Using certificateDir folder <span class="string">&quot;/etc/kubernetes/pki&quot;</span></span><br><span class="line">......忽略.....</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容中的该条命令Master节点需要创建的在用户家目录下的一些配置文件</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"><span class="comment"># 输出内容中的该条命令Master节点需要创建的在用户家目录下的一些配置文件</span></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容中的该条命令是Node节点加入集群的命令需要再Node节点执行</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.8.136:6443 --token 6v7c7k.9hc5wow978c3xkbx \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:5b2af6b3c07f793f1f863203624d26c187bbc425b12de797616bf9fbbc3bed4c</span><br></pre></td></tr></table></figure>



<p>​	根据输出的提示，Master节点执行它提供的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于我们全程都是使用root进行操作的，所以root用户执行</span></span><br><span class="line">[root@k8s-master-01 etc]# <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">[root@k8s-master-01 etc]# <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">[root@k8s-master-01 etc]# <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment"># root用户需要执行该条命令  </span></span><br><span class="line">[root@k8s-master-01 etc]# <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>

<p>​	执行完成后，我们可以先认识一下<code>kubectl get nodes</code>这条命令，该命令的作用是查看集群下分别由哪些节点，以及各节点的角色、状态、版本等。</p>
<p>​	kubectl为k8s控制集群的命令。get获取，nodes节点。可以看到当前就只有一个控制平面的节点，并且他的状态是NotReady（未启动的）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 etc]# kubectl get  nodes</span><br><span class="line">NAME            STATUS     ROLES           AGE   VERSION</span><br><span class="line">k8s-master-01   NotReady   control-plane   14m   v1.33.2</span><br></pre></td></tr></table></figure>



<h3 id="创建secret"><a href="#创建secret" class="headerlink" title="创建secret"></a>创建secret</h3><p>​	Secret是k8s中非常使用的一个功能，例如我们在初始化集群的时候我们把存放K8s镜像的仓库，设置为私有镜像</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250708173536817.png" alt="image-20250708173536817"></p>
<p>​	当我们进行初始化kubeadm的时候提示就会提示如下图的错误，拉取镜像失败，仓库是未经授权的错误，但是我们docke login和pull都能正常从这个私有仓库拉镜像下来，那是因为我们在docker login的时候是用了admin这个用户去登录的，docker使用了管理员用户，他肯定是可以拉下来的，但是我们的kubeadm使用的可不一定是管理员，所以造成这样的异常，这里我们可以把仓库设置为公开即可。</p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250708172539078.png" alt="image-20250708172539078"></p>
<p>​	如果我们公司内部为了安全的保护内部镜像不被泄露，在k8s创建pod从私有仓库拉还是会遇到这样的问题，那这个时候我们就要介绍一下K8s中的Secret资源了。</p>
<p><strong>创建Secret</strong></p>
<p>​	命令解析：</p>
<ul>
<li><strong>kubectl</strong>：为控制集群的二进制命令。</li>
<li><strong>create</strong>：表示该操作为创建某个资源。</li>
<li><strong>secret</strong>：创建的资源类型为secret的选项。</li>
<li><strong>docker-registry</strong>：该资源下的子类别，用于docker仓库的选项。</li>
<li><strong>registry-secret-liweihu</strong>：资源名称参数。</li>
<li><strong>docker-server</strong>：仓库地址参数。</li>
<li><strong>docker-username</strong>：仓库的用户名参数。</li>
<li><strong>docker-password</strong>：仓库的密码参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 etc]# kubectl create secret docker-registry registry-secret-liweihu --docker-server=reg.liweihu.cn --docker-username=admin --docker-password=admin</span><br><span class="line">secret/registry-secret-liweihu created</span><br><span class="line"><span class="comment"># 验证是否添加</span></span><br><span class="line">[root@k8s-master-01 etc]# kubectl get secrets </span><br><span class="line">NAME                      TYPE                             DATA   AGE</span><br><span class="line">registry-secret-liweihu   kubernetes.io/dockerconfigjson   1      17s</span><br><span class="line">[root@k8s-master-01 etc]#</span><br></pre></td></tr></table></figure>

<p>​	这样就创建完成了，这个验证我们到后面章节再为大家展示创建与没创建的效果，本章节了解该内容即可，便于后续的操作。</p>
<h3 id="将Node节点添加至集群中"><a href="#将Node节点添加至集群中" class="headerlink" title="将Node节点添加至集群中"></a>将Node节点添加至集群中</h3><p>​	前面我们创建了集群，目前集群里仅有一个控制平面节点（Master），接下来我们要将Node节点加入集群，这里要使用到我们初始化集群时保存的如下命令再node节点进行操作，添加节点。</p>
<p>​	<strong>两个节点执行的命令都是一样的，依次有序执行即可。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node-01 system]# kubeadm <span class="built_in">join</span> 192.168.8.136:6443 --token 6v7c7k.9hc5wow978c3xkbx      --discovery-token-ca-cert-hash sha256:5b2af6b3c07f793f1f863203624d26c187bbc425b12de797616bf9fbbc3bed4c</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the <span class="string">&quot;kubeadm-config&quot;</span> ConfigMap <span class="keyword">in</span> namespace <span class="string">&quot;kube-system&quot;</span>...</span><br><span class="line">[preflight] Use <span class="string">&#x27;kubeadm init phase upload-config --config your-config-file&#x27;</span> to re-upload it.</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">&quot;/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span></span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-check] Waiting <span class="keyword">for</span> a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s</span><br><span class="line">[kubelet-check] The kubelet is healthy after 1.503844186s</span><br><span class="line">[kubelet-start] Waiting <span class="keyword">for</span> the kubelet to perform the TLS Bootstrap</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;kubectl get nodes&#x27;</span> on the control-plane to see this node <span class="built_in">join</span> the cluster.</span><br><span class="line"></span><br><span class="line">[root@k8s-node-01 system]#</span><br></pre></td></tr></table></figure>

<p>​	添加完成后，我们再回来Master节点，查看集群节点就可以看到另外两台node已经现实出来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 etc]# kubectl get nodes</span><br><span class="line">NAME            STATUS     ROLES           AGE     VERSION</span><br><span class="line">k8s-master-01   NotReady   control-plane   137m    v1.33.2</span><br><span class="line">k8s-node-01     NotReady   &lt;none&gt;          5m40s   v1.33.2</span><br><span class="line">k8s-node-02     NotReady   &lt;none&gt;          43s     v1.33.2</span><br></pre></td></tr></table></figure>





<h2 id="Calico网络部署"><a href="#Calico网络部署" class="headerlink" title="Calico网络部署"></a>Calico网络部署</h2><h3 id="软件包下载"><a href="#软件包下载" class="headerlink" title="软件包下载"></a><strong>软件包下载</strong></h3><p>​	<strong>下载地址：</strong><code>https://github.com/projectcalico/calico/releases/tag/v3.30.2</code></p>
<p><img src="/2025/07/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20250710102042170.png" alt="image-20250710102042170"></p>
<h3 id="上传并部署Calico"><a href="#上传并部署Calico" class="headerlink" title="上传并部署Calico"></a>上传并部署Calico</h3><p>​	解压完成后，进入解压目录中的images目录，将里面的镜像文件导入到本地镜像仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 images]# <span class="built_in">pwd</span></span><br><span class="line">/opt/softapp/release-v3.30.2/images</span><br><span class="line">[root@k8s-master-01 images]# ll</span><br><span class="line">总用量 1007816</span><br><span class="line">-rw-------. 1 1001 1001 162432000  6月 20 06:57 calico-cni.tar</span><br><span class="line">-rw-------. 1 1001 1001  91260416  6月 20 06:57 calico-dikastes.tar</span><br><span class="line">-rw-------. 1 1001 1001 152131072  6月 20 06:57 calico-flannel-migration-controller.tar</span><br><span class="line">-rw-------. 1 1001 1001 121548288  6月 20 06:57 calico-kube-controllers.tar</span><br><span class="line">-rw-------. 1 1001 1001 407298560  6月 20 06:57 calico-node.tar</span><br><span class="line">-rw-------. 1 1001 1001  12103168  6月 20 06:57 calico-pod2daemon.tar</span><br><span class="line">-rw-------. 1 1001 1001  85215744  6月 20 06:57 calico-typha.tar</span><br><span class="line"><span class="comment"># 将镜像导入本地镜像仓库</span></span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-cni.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-dikastes.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-flannel-migration-controller.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-kube-controllers.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-node.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-pod2daemon.tar</span><br><span class="line">[root@k8s-master-01 images]# docker load -i calico-typha.tar</span><br><span class="line"><span class="comment"># 查看镜像是否已导入本地镜像仓库</span></span><br><span class="line">[root@k8s-master-01 images]# docker images </span><br><span class="line">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">calico/typha                                               v3.30.2    b3baa600c7ff   3 weeks ago     85.2MB</span><br><span class="line">calico/pod2daemon-flexvol                                  v3.30.2    639615519fa6   3 weeks ago     12MB</span><br><span class="line">calico/node                                                v3.30.2    cc52550d767f   3 weeks ago     405MB</span><br><span class="line">calico/flannel-migration-controller                        v3.30.2    0f62b640dd7c   3 weeks ago     152MB</span><br><span class="line">calico/kube-controllers                                    v3.30.2    761b294e2655   3 weeks ago     122MB</span><br><span class="line">calico/cni                                                 v3.30.2    77a357d0d33e   3 weeks ago     162MB</span><br><span class="line">calico/dikastes                                            v3.30.2    b3e1c212267f   3 weeks ago     91.2MB</span><br></pre></td></tr></table></figure>



<p>​	为导入进本地镜像仓库的calico镜像重新打上新标签，便于上传Harbor私有镜像仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新打标签</span></span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/cni:v3.30.2 reg.liweihu.cn/calico/cni:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/node:v3.30.2 reg.liweihu.cn/calico/node:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/kube-controllers:v3.30.2 reg.liweihu.cn/calico/kube-controllers:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/pod2daemon-flexvol:v3.30.2 reg.liweihu.cn/calico/pod2daemon-flexvol:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/dikastes:v3.30.2 reg.liweihu.cn/calico/dikastes:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/typha:v3.30.2 reg.liweihu.cn/calico/typha:v3.30.2 </span><br><span class="line">[root@k8s-master-01 manifests]# docker tag calico/flannel-migration-controller:v3.30.2 reg.liweihu.cn/calico/flannel-migration-controller:v3.30.2 </span><br></pre></td></tr></table></figure>



<p>​	将重新打好标签的镜像上传本地镜像仓库，在此操作前，需先在Harbor创建好一个公开的calico仓库，仓库名称具体根据你的标签定义的仓库名称来自行定于。</p>
<p>​	<strong>标签组成解析</strong></p>
<ul>
<li>reg.liweihu.cn&#x2F;：镜像仓库地址（域名）</li>
<li>calico&#x2F;：仓库名称</li>
<li>cni:v3.30.2：镜像名:版本号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上传镜像仓库</span></span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/cni:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/node:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/kube-controllers:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/pod2daemon-flexvol:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/dikastes:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/typha:v3.30.2</span><br><span class="line">[root@k8s-master-01 manifests]# docker push reg.liweihu.cn/calico/flannel-migration-controller:v3.30.2</span><br></pre></td></tr></table></figure>

<p>​	进入到软件包解压后的manifests目录，修改yaml文件镜像拉取的地址，默认是dockerHub的公有镜像仓库，但是由于限制的问题，我们无法从国内获取，所以需要离线从我们的私有仓库中获取镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">pwd</span></span><br><span class="line">/opt/softapp/release-v3.30.2/manifests</span><br><span class="line"><span class="comment"># 查询calico所需镜像并将镜像仓库修改为私有仓库的地址</span></span><br><span class="line"><span class="comment"># 这里自行vim或vi进入文本自行修改，由于各版本不同，这里就不用sed来写了，自行vim修改避免内容格式混乱</span></span><br><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">cat</span> calico.yaml |grep image:</span><br><span class="line">          image: docker.io/calico/cni:v3.30.2</span><br><span class="line">          image: docker.io/calico/cni:v3.30.2</span><br><span class="line">          image: docker.io/calico/node:v3.30.2</span><br><span class="line">          image: docker.io/calico/node:v3.30.2</span><br><span class="line">          image: docker.io/calico/kube-controllers:v3.30.2</span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">cat</span> calico.yaml |grep image:</span><br><span class="line">          image: reg.liweihu.cn/calico/cni:v3.30.2</span><br><span class="line">          image: reg.liweihu.cn/calico/cni:v3.30.2</span><br><span class="line">          image: reg.liweihu.cn/calico/node:v3.30.2</span><br><span class="line">          image: reg.liweihu.cn/calico/node:v3.30.2</span><br><span class="line">          image: reg.liweihu.cn/calico/kube-controllers:v3.30.2</span><br><span class="line"><span class="comment"># 修改calico的podIP网段，这里要与kubeadm分配的PodIP一致，否则calico无法正常分配IP</span></span><br><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">cat</span> custom-resources.yaml | grep  cidr:</span><br><span class="line">      cidr: 10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装calico</span></span><br><span class="line">[root@k8s-master-01 manifests]# kubectl apply -f custom-resources.yaml</span><br><span class="line">[root@k8s-master-01 manifests]# kubectl apply -f tigera-operator.yaml</span><br><span class="line">[root@k8s-master-01 manifests]# kubectl apply -f calico.yaml</span><br><span class="line">poddisruptionbudget.policy/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-kube-controllers created</span><br><span class="line">serviceaccount/calico-node created</span><br><span class="line">serviceaccount/calico-cni-plugin created</span><br><span class="line">configmap/calico-config created</span><br><span class="line">....忽略....</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-cni-plugin created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/calico-tier-getter created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-node created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-cni-plugin created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/calico-tier-getter created</span><br><span class="line">daemonset.apps/calico-node created</span><br><span class="line">deployment.apps/calico-kube-controllers created</span><br></pre></td></tr></table></figure>



<p>​	安装完成calico后，检查各节点是否处于Ready允许状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# kubectl get nodes</span><br><span class="line">NAME            STATUS   ROLES           AGE     VERSION</span><br><span class="line">k8s-master-01   Ready    control-plane   3d1h    v1.33.2</span><br><span class="line">k8s-node-01     Ready    &lt;none&gt;          2d23h   v1.33.2</span><br><span class="line">k8s-node-02     Ready    &lt;none&gt;          2d23h   v1.33.2</span><br></pre></td></tr></table></figure>

<p>​	检查所有Pod是否运行正常，这里我们可以看到，以及calico为这些Pod分配的IP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS      AGE     IP               NODE            NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   calico-kube-controllers-7f59498f59-kf5nn   1/1     Running   2 (24m ago)   24h     10.244.151.136   k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-7ndvs                          1/1     Running   2 (24m ago)   24h     192.168.8.137    k8s-node-01     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-l4rfm                          1/1     Running   2 (24m ago)   24h     192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   calico-node-ls56h                          1/1     Running   2 (24m ago)   24h     192.168.8.138    k8s-node-02     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-dc6b59956-72kvq                    1/1     Running   2 (24m ago)   3d1h    10.244.151.135   k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-dc6b59956-bfgfb                    1/1     Running   2 (24m ago)   3d1h    10.244.151.137   k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   etcd-k8s-master-01                         1/1     Running   4 (24m ago)   3d1h    192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-apiserver-k8s-master-01               1/1     Running   4 (24m ago)   3d1h    192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-controller-manager-k8s-master-01      1/1     Running   4 (24m ago)   3d1h    192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-ggxph                           1/1     Running   3 (24m ago)   2d23h   192.168.8.138    k8s-node-02     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-hb9dg                           1/1     Running   3 (24m ago)   2d23h   192.168.8.137    k8s-node-01     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-proxy-rv6rk                           1/1     Running   4 (24m ago)   3d1h    192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   kube-scheduler-k8s-master-01               1/1     Running   4 (24m ago)   3d1h    192.168.8.136    k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="为Node节点打标签"><a href="#为Node节点打标签" class="headerlink" title="为Node节点打标签"></a>为Node节点打标签</h2><p>​	我们部署完成后发现，我们的master节点是具有<code>control-plane</code>（控制平面）的角色标签，但是我们另外的两个node是<code>none</code>（空），为了便于管理辨认最好将其打上标签，已区分各节点的角色关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get nodes</span><br><span class="line">NAME            STATUS   ROLES           AGE     VERSION</span><br><span class="line">k8s-master-01   Ready    control-plane   5d18h   v1.33.2</span><br><span class="line">k8s-node-01     Ready    node            5d16h   v1.33.2</span><br><span class="line">k8s-node-02     Ready    node            5d16h   v1.33.2</span><br><span class="line"><span class="comment"># label、nodes选项，role.kubernetes.io/node=资源记标签</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl label nodes k8s-node-01 k8s-node-02 node-role.kubernetes.io/node=</span><br></pre></td></tr></table></figure>



<h2 id="加入Node节点"><a href="#加入Node节点" class="headerlink" title="加入Node节点"></a>加入Node节点</h2><p>​	如果后续2台node已经支撑不了业务的运行，需要增加node节点，但是最开始的加入集群的语句已经丢了，我们可以通过一下方式获取新的join参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建token，并print打印join命令参数</span></span><br><span class="line">[root@k8s-master-01 ~]# kubeadm token create --print-join-command</span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.8.136:6443 --token fuag1e.rlwcwz93roobuts8 --discovery-token-ca-cert-hash sha256:5b2af6b3c07f793f1f863203624d26c187bbc425b12de797616bf9fbbc3bed4cxxxxxxxxxx kubeadm token create --print-join-command[root@k8s-master-01 ~]# kubeadm token create --print-join-commandkubeadm <span class="built_in">join</span> 192.168.8.136:6443 --token fuag1e.rlwcwz93roobuts8 --discovery-token-ca-cert-hash sha256:5b2af6b3c07f793f1f863203624d26c187bbc425b12de797616bf9fbbc3bed4cbash</span><br></pre></td></tr></table></figure>



<h2 id="重置集群"><a href="#重置集群" class="headerlink" title="重置集群"></a>重置集群</h2><p>​	如果因为某种原因您想删除集群重新进行部署，可通过一下方式进行删除，删除完成后即可重新进行初始化集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清除集群中的运行时</span></span><br><span class="line">[root@k8s-master-01 ~]# kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"><span class="comment"># 手动删除K8S相关配置文件</span></span><br><span class="line">[root@k8s-master-01 ~]# <span class="built_in">rm</span> -rf /etc/cni/net.d</span><br><span class="line">[root@k8s-master-01 ~]# iptables -F</span><br><span class="line">[root@k8s-master-01 ~]# <span class="built_in">rm</span> -rf <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>



<p><strong>至此Kubernetes单节点集群已部署完成，离线部署话可以通过二进制的方式进行部署，所有组件通过守护进程进行管理，如果想了解二进制方式的部署可参考我的CSDN文档：</strong><code>https://blog.csdn.net/qq_42658764/article/details/137954292</code></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第六章</title>
    <url>/2025/11/03/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="存活、就绪和启动探针"><a href="#存活、就绪和启动探针" class="headerlink" title="存活、就绪和启动探针"></a>存活、就绪和启动探针</h1>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第五章</title>
    <url>/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h2><p>​	将在集群中运行的应用通过同一个面向外界的端点公开出去，即使工作负载分散于多个后端也完全可行。</p>
<p>​	Kubernetes 中 Service 是 将运行在一个或一组 <strong>Pod</strong>上的网络应用程序公开为网络服务的方法。</p>
<p>​	Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用以使用某种不熟悉的服务发现机制。 你可以在 Pod 集合中运行代码，无论该代码是为云原生环境设计的，还是被容器化的老应用。 你可以使用 Service 让一组 Pod 可在网络上访问，这样客户端就能与之交互。</p>
<p>​	如果你使用 <strong>Deployment</strong>来运行你的应用， Deployment 可以动态地创建和销毁 Pod。 在任何时刻，你都不知道有多少个这样的 Pod 正在工作以及它们健康与否； 你可能甚至不知道如何辨别健康的 Pod。 <strong>Kubernetes Pod</strong> 的创建和销毁是为了匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。</p>
<p>​	每个 Pod 会获得属于自己的 IP 地址（Kubernetes 期待网络插件来保证这一点）。 对于集群中给定的某个 Deployment，这一刻运行的 Pod 集合可能不同于下一刻运行该应用的 Pod 集合。</p>
<p>​	这就带来了一个问题：如果某组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”） 集合提供功能，前端要如何发现并跟踪要连接的 IP 地址，以便其使用负载的后端组件呢？</p>
<p>​	这样我们可以通过下图大概了解，下图中可以看出我们的客户端以及api-server并没有通过直接对接后端Pod的方式进行连接访问的，而是通过一个叫做<strong>ClusterIP</strong>作为一个统一入口进行代理访问，这个ClusterIP就是我们本章节要介绍的Service，同时ClusterIP是通过集群中的iptables进行实现的。这样就能做到不管Pod是如何删除又重建的，我们始终访问的是这个ClusterIP这个是不会变动的。</p>
<p>​	那么我们的集群中会有很多个Pod，service又是如何能找到例如Mysql这个后端的Pod是哪些呢？service是通过一个名为标签选择器的配置Yaml进行筛选的，这个之前我们在控制器章节也是有见过这个参数的，最终我们就可以实现给临时的Pod绑定上一个持久的service网络，所有的不管客户端也好，集群内部的api也好都可以通过持久的service找到我们对应的Pod并且通过service内部的算法合理的将流量分配到我们的每一个Pod身上。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024161851007.png" alt="image-20251024161851007"></p>
<h3 id="Kubernetes-中的-Service"><a href="#Kubernetes-中的-Service" class="headerlink" title="Kubernetes 中的 Service"></a>Kubernetes 中的 Service</h3><p>​	Service API 是 Kubernetes 的组成部分，它是一种抽象，帮助你将 Pod 集合在网络上公开出去。 每个 Service 对象定义端点的一个逻辑集合（通常这些端点就是 Pod）以及如何访问到这些 Pod 的策略。</p>
<p>​	例如，考虑一个无状态的图像处理后端，其中运行 3 个副本（Replicas）。 这些副本是可互换的 —— 前端不需要关心它们调用的是哪个后端。 即便构成后端集合的实际 Pod 可能会发生变化，前端客户端不应该也没必要知道这些， 而且它们也不必亲自跟踪后端的状态变化。</p>
<p>​	Service 抽象使这种解耦成为可能。</p>
<p>​	Service 所对应的 Pod 集合通常由你定义的<strong>选择算符</strong>来确定。 若想了解定义 Service 端点的其他方式，可以查阅后续的<strong>不带选择算符的 Service</strong>。</p>
<p>如果你的工作负载使用 HTTP 通信，你可能会选择使用 <strong>Ingress</strong> 来控制 Web 流量如何到达该工作负载。Ingress 不是一种 Service，但它可用作集群的入口点。 Ingress 能让你将路由规则整合到同一个资源内，这样你就能将工作负载的多个组件公开出去， 这些组件使用同一个侦听器，但各自独立地运行在集群中。</p>
<p>用于 Kubernetes 的 <strong>Gateway API</strong> 能够提供 Ingress 和 Service 所不具备的一些额外能力。 Gateway 是使用 <strong>CustomResourceDefinitions</strong> 实现的一系列扩展 API。 你可以添加 Gateway 到你的集群中，之后就可以使用它们配置如何访问集群中运行的网络服务。</p>
<h3 id="service的类型"><a href="#service的类型" class="headerlink" title="service的类型"></a>service的类型</h3><h4 id="type-ClusterIP"><a href="#type-ClusterIP" class="headerlink" title="type: ClusterIP"></a><strong>type: ClusterIP</strong></h4><p>​	指定该类型时，服务只能够在集群内部访问，同时此为默认 Service 类型，从你的集群中为此预留的 IP 地址池中分配一个 IP 地址。</p>
<p>​	其他几种 Service 类型在 <code>ClusterIP</code> 类型的基础上进行构建。</p>
<p>​	如果你定义的 Service 将 <code>.spec.clusterIP</code> 设置为 <code>&quot;None&quot;</code>，则 Kubernetes 不会为其分配 IP 地址。其被称为<strong>无头服务</strong>。</p>
<p><strong>选择自己的 IP 地址</strong></p>
<p>​	在创建 <code>Service</code> 的请求中，你可以通过设置 <code>spec.clusterIP</code> 字段来指定自己的集群 IP 地址。 比如，希望复用一个已存在的 DNS 条目，或者遗留系统已经配置了一个固定的 IP 且很难重新配置。</p>
<p>​	你所选择的 IP 地址必须是合法的 IPv4 或者 IPv6 地址，并且这个 IP 地址在 API 服务器上所配置的 <code>service-cluster-ip-range</code> CIDR 范围内。 如果你尝试创建一个带有非法 <code>clusterIP</code> 地址值的 Service，API 服务器会返回 HTTP 状态码 422， 表示值不合法。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024165751722.png" alt="image-20251024165751722"></p>
<h4 id="type-NodePort"><a href="#type-NodePort" class="headerlink" title="type: NodePort"></a>type: NodePort</h4><p>​	如果你将 <code>type</code> 字段设置为 <code>NodePort</code>，则 Kubernetes 控制平面将在 <code>--service-node-port-range</code> 标志所指定的范围内分配端口（默认值：30000-32767）。 每个节点将该端口（每个节点上的相同端口号）上的流量代理到你的 Service。 你的 Service 在其 <code>.spec.ports[*].nodePort</code> 字段中报告已分配的端口。</p>
<p>​	通过每个节点的IP和静态端口暴露访问。NodePort访问会路由到自动创建的ClusterIP服务。通过请求&lt;节点IP&gt;:&lt;节点端口&gt;，不过您可以从集群外部进行访问服务，因此即使是创建了NodePort，他也会为您自动创建出一个clusterIP，通过节点IP路由到您的clusterIP，从而实现了从外部访问到集群内部。</p>
<p>​	对于 NodePort 类型 Service，Kubernetes 额外分配一个端口（TCP、UDP 或 SCTP 以匹配 Service 的协议）。 集群中的每个节点都将自己配置为监听所分配的端口，并将流量转发到与该 Service 关联的某个就绪端点。 通过使用合适的协议（例如 TCP）和适当的端口（分配给该 Service）连接到任何一个节点， 你就能够从集群外部访问 <code>type: NodePort</code> 服务。</p>
<p><strong>选择你自己的端口</strong></p>
<p>​	如果需要特定的端口号，你可以在 <code>nodePort</code> 字段中指定一个值。 控制平面将或者为你分配该端口，或者报告 API 事务失败。 这意味着你需要自行注意可能发生的端口冲突。 你还必须使用有效的端口号，该端口号在配置用于 NodePort 的范围内。</p>
<p>​	由于ClusterIP仅限于集群内部访问，无法让需要局域网内的客户端直接进行访问，对于这样的业务，我们可以使用NodePort，可以解决集群外部的访问需求。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024172623656.png" alt="image-20251024172623656"></p>
<h4 id="type-LoadBalancer"><a href="#type-LoadBalancer" class="headerlink" title="type: LoadBalancer"></a>type: LoadBalancer</h4><p>在使用云提供商的负载均衡器向外暴露访问，如果将 <code>type</code> 设置为 <code>&quot;LoadBalancer&quot;</code>， 则平台会为 Service 提供负载均衡器。 负载均衡器的实际创建过程是异步进行的，关于所制备的负载均衡器的信息将会通过 Service 的 <code>status.loadBalancer</code> 字段公开出来，外部负载均衡器可以将流量路由到自动创建的NodePort服务和ClusterIP服务上。</p>
<p>​	由于NodePort类型他仅限于局域网，并且他所使用的端口是（30000-32767）的高端口并且提出的服务数量有限制，所以如果您对该服务具有公网访问、低端口等需求，我们可以使用LoadBalancer不仅可以满足公网服务访问，并且可以将高端口转换为低端口，便于记忆。</p>
<p>​	但是由于这需要用到云服务器和公网IP和负载均衡器，这东西是需要收费的，这是无法避免的，当然您如果没有公网需求只需要一个低端口访问，您可以使用***（负载均衡器）来实现这一效果。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024173000204.png" alt="image-20251024173000204"></p>
<h4 id="ExternalName-类型"><a href="#ExternalName-类型" class="headerlink" title="ExternalName 类型"></a>ExternalName 类型</h4><p>类型为 ExternalName 的 Service 将 Service 映射到 DNS 名称，而不是典型的选择算符， 例如 <code>my-service</code> 或者 <code>cassandra</code>。你可以使用 <code>spec.externalName</code> 参数指定这些服务。</p>
<h3 id="iptables代理模式的Service"><a href="#iptables代理模式的Service" class="headerlink" title="iptables代理模式的Service"></a>iptables代理模式的Service</h3><p>​	kube-proxy会监视kubernetes控制节点对Service对象和Endpoints对象的添加和移除。对每个Service，他会配置iptables规则，从而捕获到达该Service的ClusterIP和端口的请求，进而将请求重定向到Service的一组后端中的某个Pod上。对于每个Endpoints对象，它也会配置iptables规则，这个规则会选择一个后端组合。</p>
<p>​	默认的策略是，kube-proxy在iptables模式下随机选择一个后端。</p>
<p>​	使用iptables处理六里昂具有较低的系统开销，因为流量由Linux netfilter处理，而无需在用户空间和内核空间之间来回切换。这种方法也可能更可靠。</p>
<h3 id="IPVS代理模式的Service"><a href="#IPVS代理模式的Service" class="headerlink" title="IPVS代理模式的Service"></a>IPVS代理模式的Service</h3><p>​	在ipvs模式下，kube-proxy监控kubernetes服务和端点，调用netlink接口相应地创建IPVS规则，并定期将IPVS规则与kubernetes服务和端点同步。该控制循环可确保IPVS状态与所需状态匹配。访问服务时，IPVS将流量定向到后端的Pod之一。</p>
<p>​	IPVS代理模式基于类似iptables模式的netfilter挂钩函数，但是使用哈希表作为基础数据结构，并且在内核空间中工作。这意味着，与iptables模式下的kube-proxy相比，IPVS模式下的kube-proxy重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。与其他代理模式相比，IPVS模式还支持更高的网络流量吞吐。</p>
<p>​	因为当您的规则有上百万条的时候，如果您使用的是iptables那么它得挨个扫描一变去匹配规则，那这样可能会出现几秒或是十几秒的延迟，如果当您使用的是IPVS，由于它是基于哈希表进行存储的，每个哈希都是一个固定值，这样相对而言IPVS性能更好。</p>
<p>​	这样看的话是不是用IPVS要更好，iptables没用？并不是这样的，具体得根据业务体量来进行判断，如果您的业务场景仅是内部使用，物理机数量也就几台或者几十台，你在使用iptables和IPVS上感受不到什么区别的，只有当您的物理机数量达到一定量，假定体量很大，物理机数量有5000台，那么用IPVS会感受到一些区别。</p>
<h3 id="命令生成NodePort类型的Service"><a href="#命令生成NodePort类型的Service" class="headerlink" title="命令生成NodePort类型的Service"></a>命令生成NodePort类型的Service</h3><p>​	接下来我们开始了解，如何创建和使用service。</p>
<p>​	我们可以通过命令行的方式进行创建service服务，以下解析各命令含义：</p>
<ul>
<li>expose：表示service服务暴露的命令及含义。</li>
<li>deployment：选定我们要暴露的服务类型为deployment。</li>
<li>nginx-dlt：选定我们要暴露的deployment服务中的nginx-dlt服务。</li>
<li>–type&#x3D;NodePort：表示我们创建的service类型为NodePort。</li>
<li>–name&#x3D;nginx-service： 表示创建的service资源类型名称为nginx-service。</li>
<li>–port 9000：表示将要创建的ClusterIP的端口为9000。</li>
<li>–target-port 80：表示流量到达ClusterIP的9000端口后，指定找到我们pod中的80端口服务进行暴露。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl expose deployment nginx-dlt --<span class="built_in">type</span>=NodePort --name=nginx-service --port 9000 --target-port 80</span><br><span class="line">service/nginx-service exposed</span><br></pre></td></tr></table></figure>



<p>1、创建service完成后，我们可以通过如下命令查看到创建的service信息。</p>
<p>2、同时iptables为我们自动从IP池中获取到了一个clusterIP及端口为:10.96.226.228:9000</p>
<p>3、由于我们创建的service类型是NodePort，同时为我们获取到了外部访问的高端口为：30790</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get service</span><br><span class="line">NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">nginx           ClusterIP   None            &lt;none&gt;        80/TCP           15d</span><br><span class="line">nginx-service   NodePort    10.96.226.228   &lt;none&gt;        9000:30790/TCP   16s</span><br></pre></td></tr></table></figure>

<p>​	我们可以先验证一下clusterIP在集群内是否能访问到这个nginx服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# curl 10.96.226.228:9000</span><br><span class="line">...忽略....</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">...忽略...</span><br></pre></td></tr></table></figure>

<p>​	最后我们在使用节点IP加上NodePort获取到的高端口通过外部客户端的浏览器进行访问，访问通过。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024183346791.png" alt="image-20251024183346791"></p>
<h3 id="使用Yaml的方式生成NodePort类型的Service"><a href="#使用Yaml的方式生成NodePort类型的Service" class="headerlink" title="使用Yaml的方式生成NodePort类型的Service"></a>使用Yaml的方式生成NodePort类型的Service</h3><p>​	前面一直提到，命令行创建的资源建议通常用于临时性的任务，当在企业级的正式环境中，还是建议使用yaml的方式进行创建便于管理维护，接下来我们来应用下前面控制器的知识，结合service创建一个较为完善的服务访问。</p>
<p>​	Deployment部分就不在过度解析了，主要关注spec下的selector（标签选择器）及template下的labels标签两个保持一致，避免控制器所筛选的标签与pod创建的标签不同，这里主要描述service资源创建部分。</p>
<ul>
<li><strong>spec.selector: app: nginx</strong>：这里的标签选择器要与Deployment的metadata.labels要一致，避免service无法筛选到需要暴露的Deployment服务。</li>
<li><strong>spec.type: NodePort</strong> ：这里表示您要创建的service类型。</li>
<li><strong>spec.ports.targetPort: 80</strong>：这里表示pod服务暴露出来的端口，与Deployment部分的ports一致。</li>
<li><strong>spec.ports.port: 9000</strong>：这里表示自动创建的ClusterIP的端口。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; service-nodeport.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建后端服务Deployment部分</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: del-nginx</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  replicas: 3</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: del-nginx</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">      namespace: book-k8s</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          protocol: TCP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 使用---进行分割写新的资源创捷</span></span><br><span class="line"><span class="string"># 创建service资源服务</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx-ser</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ser</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - name: nginx-port</span></span><br><span class="line"><span class="string">    protocol: TCP</span></span><br><span class="line"><span class="string">    targetPort: 80</span></span><br><span class="line"><span class="string">    port: 9000</span></span><br><span class="line"><span class="string">  type: NodePort</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可以使用如下命令，执行yaml文件，进行资源创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl create -f service-nodeport.yaml </span><br><span class="line">deployment.apps/del-nginx created</span><br><span class="line">service/nginx-ser created</span><br></pre></td></tr></table></figure>

<p>​	验证资源创建情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get -f service-nodeport.yaml </span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/del-nginx   3/3     3            3           6m28s</span><br><span class="line"></span><br><span class="line">NAME                TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">service/nginx-ser   NodePort   10.97.51.154   &lt;none&gt;        9000:31640/TCP   6m27s</span><br></pre></td></tr></table></figure>

<p>​	验证CLUSTERIP是否访问成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# curl 10.97.51.154:9000</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>​	验证NodePort节点IP加高端口访问。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024195326888.png" alt="image-20251024195326888"></p>
<p>​	删除资源可以使用如下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl delete -f service-nodeport.yaml </span><br><span class="line">deployment.apps <span class="string">&quot;del-nginx&quot;</span> deleted</span><br></pre></td></tr></table></figure>





<h3 id="使用Yaml的方式生成ClusterIP类型的Service"><a href="#使用Yaml的方式生成ClusterIP类型的Service" class="headerlink" title="使用Yaml的方式生成ClusterIP类型的Service"></a>使用Yaml的方式生成ClusterIP类型的Service</h3><p>​	同样沿用之前的yaml，只需要稍加改动即可，在创建前，需先将上面创建的NodePort删除，否则会资源名称重复。</p>
<p>​	这里也是没什么改动，由于kubernetes模式就是ClusterIP类型，所以我们只需要把type删除即可，或者把type的值改为ClusterIP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; service-nodeport.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建后端服务Deployment部分</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: del-nginx</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  replicas: 3</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: del-nginx</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">      namespace: book-k8s</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          protocol: TCP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 使用---进行分割写新的资源创捷</span></span><br><span class="line"><span class="string"># 创建service资源服务</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx-ser</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ser</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - name: nginx-port</span></span><br><span class="line"><span class="string">    protocol: TCP</span></span><br><span class="line"><span class="string">    targetPort: 80</span></span><br><span class="line"><span class="string">    port: 9000</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可以使用如下命令，执行yaml文件，进行资源创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl create -f service-nodeport.yaml </span><br><span class="line">deployment.apps/del-nginx created</span><br><span class="line">service/nginx-ser created</span><br></pre></td></tr></table></figure>

<p>​	验证资源创建情况，这里我们可以看到service资源有些变化，type类似变为：ClusterIP，PORT(S)中也少了NodePort的端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get -f service-nodeport.yaml </span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/del-nginx   3/3     3            3           10s</span><br><span class="line"></span><br><span class="line">NAME                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/nginx-ser   ClusterIP   10.109.116.255   &lt;none&gt;        9000/TCP   10s</span><br></pre></td></tr></table></figure>

<p>​	由于CLUSTERIP只能集群内访问，所以我们只能在K8s集群中的物理机进行验证CLUSTERIP是否访问成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# curl 10.109.116.255:9000</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>​	那有小伙伴可以要问，这是怎么实现的访问ClusterIP就能找到我对应的Pod后端服务，在这ClusterIP后面其实还有一个endpoints的资源类型，kube-porxy会实时扫描控制节点的变化，如果您的Pod删除了等操作导致IP变动了，kube-porxy会对endpoints记录的PodIP进行更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get endpoints</span><br><span class="line">Warning: v1 Endpoints is deprecated <span class="keyword">in</span> v1.33+; use discovery.k8s.io/v1 EndpointSlice</span><br><span class="line">NAME        ENDPOINTS                                             AGE</span><br><span class="line">nginx-ser   10.244.154.208:80,10.244.44.219:80,10.244.44.221:80   10m</span><br></pre></td></tr></table></figure>

<p>​	这里我们删除一个Pod，模拟故障重启的情况，这时我们发现Pod的IP进行了变动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get pods</span><br><span class="line">NAME                        READY   STATUS    RESTARTS         AGE</span><br><span class="line">del-nginx-bf86c6ccd-qbt5m   1/1     Running   0                12m</span><br><span class="line">del-nginx-bf86c6ccd-smqpn   1/1     Running   0                12m</span><br><span class="line">del-nginx-bf86c6ccd-t57mz   1/1     Running   0                12m</span><br><span class="line">staticpod-k8s-master-01     1/1     Running   11 (5h23m ago)   87m</span><br><span class="line">[root@k8s-master-01 service]# kubectl delete pods del-nginx-bf86c6ccd-qbt5m del-nginx-bf86c6ccd-smqpn </span><br><span class="line">pod <span class="string">&quot;del-nginx-bf86c6ccd-qbt5m&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;del-nginx-bf86c6ccd-smqpn&quot;</span> deleted</span><br><span class="line">[root@k8s-master-01 service]# kubectl get pods -o wide </span><br><span class="line">NAME                        READY   STATUS    RESTARTS         AGE   IP               NODE            NOMINATED NODE   READINESS GATES</span><br><span class="line">del-nginx-bf86c6ccd-cbcsm   1/1     Running   0                38s   10.244.154.201   k8s-node-01     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">del-nginx-bf86c6ccd-h7w9b   1/1     Running   0                38s   10.244.154.209   k8s-node-01     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">del-nginx-bf86c6ccd-t57mz   1/1     Running   0                13m   10.244.44.221    k8s-node-02     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">staticpod-k8s-master-01     1/1     Running   11 (5h24m ago)   88m   10.244.151.155   k8s-master-01   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	同时我们endpoints的记录IP也进行了秒级更新，所以我们的service能保证任何时候都能找到临时存在的Pod。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get endpoints</span><br><span class="line">Warning: v1 Endpoints is deprecated <span class="keyword">in</span> v1.33+; use discovery.k8s.io/v1 EndpointSlice</span><br><span class="line">NAME        ENDPOINTS                                              AGE</span><br><span class="line">nginx-ser   10.244.154.201:80,10.244.154.209:80,10.244.44.221:80   13m</span><br></pre></td></tr></table></figure>



<h3 id="使用Yaml的方式生成Headless类型的Service（无头服务）"><a href="#使用Yaml的方式生成Headless类型的Service（无头服务）" class="headerlink" title="使用Yaml的方式生成Headless类型的Service（无头服务）"></a>使用Yaml的方式生成Headless类型的Service（无头服务）</h3><p>​	什么是Headless？前面我们提到过一下无头服务，这个Headless就是无头服务，下面我们看下如何创建和使用这个Headless。</p>
<p>​	这里镜像换成了busybox:1.28，因为节约时间这个镜像有需要用到的命令。采用的类型还是默认的ClusterIP，只不过多加了一个参数<code>spec.clusterIP: None</code>,这个表示没有clusterIP。</p>
<p>​	在创建前，需先将上面创建的NodePort删除，否则会资源名称重复。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; service-nodeport.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建后端服务Deployment部分</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: del-busybox</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: busybox</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: busybox</span></span><br><span class="line"><span class="string">  replicas: 3</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: del-busybox</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: busybox</span></span><br><span class="line"><span class="string">      namespace: book-k8s</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: busybox</span></span><br><span class="line"><span class="string">        image: busybox:1.28</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        command: [&#x27;sh&#x27;,&#x27;-c&#x27;,&#x27;echo &quot;Hello,liweihu!&quot; &amp;&amp; sleep 3600 &#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 使用---进行分割写新的资源创捷</span></span><br><span class="line"><span class="string"># 创建service资源服务</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: headless</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: busybox-service</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  clusterIP: None</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">      app: busybox</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - name: busybox-port</span></span><br><span class="line"><span class="string">    protocol: TCP</span></span><br><span class="line"><span class="string">    targetPort: 80</span></span><br><span class="line"><span class="string">    port: 9000</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可以使用如下命令，执行yaml文件，进行资源创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl create -f service-nodeport.yaml </span><br><span class="line">deployment.apps/del-busybox created</span><br><span class="line">service/headless created</span><br></pre></td></tr></table></figure>

<p>​	验证资源创建情况，这里我们可以看到service资源有些变化，type依然是为：ClusterIP没问题。</p>
<p>​	但是CLUSTER-IP字段缺没了IP，service宣称提供的是持久可靠的统一IP访问入口，但是你都没有IP了，如何保证持久。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get -f service-nodeport.yaml </span><br><span class="line">NAME                          READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/del-busybox   3/3     3            3           6s</span><br><span class="line"></span><br><span class="line">NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/headless   ClusterIP   None         &lt;none&gt;        9000/TCP   6s</span><br></pre></td></tr></table></figure>

<p>​	这里我们要验证的话需要进入到Pod容器中，我们通过nslookup这个命令扫描我们创建service时的资源名称，可以发现这返回的于之前的截然不同，他将所有的Pod的Ip进行了一个返回以及他的一个地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl <span class="built_in">exec</span> -it deployments/del-busybox -- /bin/sh</span><br><span class="line">/ <span class="comment"># nslookup headless</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      headless</span><br><span class="line">Address 1: 10.244.154.200 del-busybox-5dbbd9857f-m7h62</span><br><span class="line">Address 2: 10.244.154.214</span><br><span class="line">Address 3: 10.244.44.223</span><br></pre></td></tr></table></figure>

<p>​	前面我们介绍过，headless他是通过DNS去进行记录条目的，所以我们可以通过域名的方式去进行一个访问。</p>
<p>​	但是访问出来的结果是各个Pod的IP，这就衍生到我可以用headless做些什么了？</p>
<p>​	我们在使用不管是NodePort还是ClusterIIP，他中间都是带有负载均衡的，由它来为您自动选择这个流量要进去到哪个Pod中，所以headless通常是在您对它这个负载均衡不满意的情况下，并且您拥有一个自己的负载均衡器，想用自己的负载均衡算法去分配流量的时候，您就可以使用headless（无头服务）去满足您个性化的需求。</p>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>​	什么是ingress？它是基于上述说的service中优化衍生出来的产品，拥有了它您不在需要考虑什么高端口、什么只能集群内部访问等等，使用一种能感知协议配置的机制来解析 URI、主机名称、路径等 Web 概念， 让你的 HTTP（或 HTTPS）网络服务可被访问。 Ingress 概念允许你通过 Kubernetes API 定义的规则将流量映射到不同后端。</p>
<ul>
<li>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</li>
<li>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</li>
</ul>
<p>​	它是可以通过同一个公网IP：10.10.10.10及域名解析的方式，将您访问的host（域名）对应的转到相应的Pod服务中去。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024214624001.png" alt="image-20251024214624001"></p>
<p>​	这里可以参考下实力，浏览器访问百度，使用F12您可以看到，您每次的访问都会带有一个host，ingress就是通过这个host去分析路由规则，同时每一个service都绑定这唯一的host，当遇到相匹配的host请求，则就转发到相应的service中去。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024215110256.png" alt="image-20251024215110256"></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>​	要使用ingress首先需要安装ingress控制器，这里我采用的是ingress-nginx。</p>
<p>ingress-nginx离线下载地址：<a href="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024220118705.png" alt="image-20251024220118705"></p>
<p>​	具体安装就不具体演示了，如遇到问题可咨询博主。</p>
<p>​	最终可使用如下命令，查看是否安装完成，主要是看ingress-nginx-controller。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl get pods -A | grep ingress</span><br><span class="line">ingress-nginx   ingress-nginx-admission-create-txbjl       0/1     Completed   0               39m</span><br><span class="line">ingress-nginx   ingress-nginx-admission-patch-wlm5s        0/1     Completed   0               39m</span><br><span class="line">ingress-nginx   ingress-nginx-controller-cr25v             1/1     Running     0               39m</span><br><span class="line">ingress-nginx   ingress-nginx-controller-mwtbx             1/1     Running     0               39m</span><br></pre></td></tr></table></figure>



<h3 id="使用ingress"><a href="#使用ingress" class="headerlink" title="使用ingress"></a>使用ingress</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; backend.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建后端Deployment</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-1</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-1</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx-1</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: nginx-1</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx-1</span></span><br><span class="line"><span class="string">      namespace: book-k8s</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx-1</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          protocol: TCP</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建Service</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx-s1</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-1</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">      app: nginx-1</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - name: busybox-port</span></span><br><span class="line"><span class="string">    protocol: TCP</span></span><br><span class="line"><span class="string">    targetPort: 80</span></span><br><span class="line"><span class="string">    port: 80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建Ingress</span></span><br><span class="line"><span class="string">apiVersion: networking.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: Ingress</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-i1</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-i1</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  ingressClassName: nginx</span></span><br><span class="line"><span class="string">  rules:</span></span><br><span class="line"><span class="string">  - host: www.liweihu.com</span></span><br><span class="line"><span class="string">    http:</span></span><br><span class="line"><span class="string">      paths:</span></span><br><span class="line"><span class="string">      - path: &quot;/&quot;</span></span><br><span class="line"><span class="string">        pathType: Prefix</span></span><br><span class="line"><span class="string">        backend:</span></span><br><span class="line"><span class="string">          service:</span></span><br><span class="line"><span class="string">            name: nginx-s1</span></span><br><span class="line"><span class="string">            port:</span></span><br><span class="line"><span class="string">              number: 80</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可以使用如下命令，执行yaml文件，进行资源创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# kubectl create -f backend.yaml</span><br></pre></td></tr></table></figure>

<p>​	创建完成后，需先检查验证ingress分配的IP是多少，并将其加入hosts用于域名解析。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两台node节点均已加入。</span></span><br><span class="line">[root@k8s-master-01 service]# kubectl get ingress</span><br><span class="line">NAME       CLASS   HOSTS             ADDRESS                       PORTS   AGE</span><br><span class="line">nginx-i1   nginx   www.liweihu.com   192.168.8.137,192.168.8.138   80      29m</span><br><span class="line">[root@k8s-master-01 service]# <span class="built_in">echo</span> <span class="string">&quot;192.168.8.137 www.liweihu.com&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line">[root@k8s-master-01 service]# <span class="built_in">echo</span> <span class="string">&quot;192.168.8.138 www.liweihu.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<p>​	验证正常访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 service]# curl www.liweihu.com</span><br><span class="line">is my default</span><br></pre></td></tr></table></figure>

<p>​	同时包括在我们的客户端进行访问也是一样的，需要在本机电脑上的hosts文件内同样添加两个节点的域名解析。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024234407037.png" alt="image-20251024234407037"></p>
<p>​	即也可以正常外部域名访问。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024234435371.png" alt="image-20251024234435371"></p>
<p>​	即使当您使用了不存在的后缀，也同样能锁定到默认的service，这样即便不管您有多少个服务，统一通过统一域名不同后缀的方式进行访问，大大减少的前面繁琐的管理和维护工作。</p>
<p><img src="/2025/10/10/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20251024234521100.png" alt="image-20251024234521100"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第七章节</title>
    <url>/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="监控和管理Linux进程"><a href="#监控和管理Linux进程" class="headerlink" title="监控和管理Linux进程"></a>监控和管理Linux进程</h1><h2 id="进程状态和生命周期"><a href="#进程状态和生命周期" class="headerlink" title="进程状态和生命周期"></a>进程状态和生命周期</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>​	进程是已启动的可执行程序中运行的实例。从进程创建那一刻起，它由以下项目组成：</p>
<ul>
<li>已分配内存的地址空间</li>
<li>安全属性，包括所有权凭据和特权</li>
<li>程序代码的一个或多个执行线程</li>
<li>进程状态</li>
</ul>
<p>进程的环境是包含以下项目的信息列表：</p>
<ul>
<li>本地和全局变量</li>
<li>当前调度上下文</li>
<li>分配的系统资源，如文件描述的网络端口</li>
</ul>
<p>​	现有的父进程复制自己的地址空间（成为进程分叉）来创建子进程结构。每个新进程分配有一个唯一进程ID（PID），满足跟踪和安全性之需。PID和父进程ID（PPID）是新进程环境的元素。任何进程都可以创建子进行。所有进程都是第一个系统进程的后代，在RedHat Linux中，第一个系统进程是systemd。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527112636921.png" alt="image-20250527112636921"></p>
<p>​	通过分叉进程，子进程继承安全性身份、过去和当前的文件描述符、端口和资源特权、环境变量，以及程序代码。随后，子进程可以执行其自己的代码程序。</p>
<p>​	通常，父进程在子进程运行期间处于睡眠状态，设置一个在子进程完成时发出信号的等待请求。子进程退出后，他会关闭或丢弃其资源和环境，并留下僵停资源，即进程表中的一个条目。父进程在子进程退出时收到信号而被唤醒，清理子进程条目的进程表，由此释放子进程的最后一个资源，然后，父进程继续执行自己的程序代码。</p>
<h3 id="描述进程状态"><a href="#描述进程状态" class="headerlink" title="描述进程状态"></a>描述进程状态</h3><p>​	在多任务处理操作系统中，每个CPU（或CPU核心）在一个时间上处理一个进程。在进程运行时，它对CPU时间和资源分配的直接要求会有变化。进程分配有一个状态，它随着环境要求而改变。</p>
<p>​	以下图示和表格详细描述了Linux进程状态。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527115327090.png" alt="image-20250527115327090"></p>
<p><strong>Linux进程状态</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>标志</th>
<th>内核定义的状态名称和描述</th>
</tr>
</thead>
<tbody><tr>
<td>运行中</td>
<td>R</td>
<td>TASK_RUNNING：进程正在CPU上执行，或者正在等待运行。处于运行中（或可运行）状态时，进程可能正在执行用户例程或内核例程（系统调用），或者已经排队并就绪。</td>
</tr>
<tr>
<td>睡眠</td>
<td>S</td>
<td>TASK_INTERRUPTIBLEl：进程正在等待某一条件：硬件请求、系统资源访问或信号。当事件或信号满足该条件时，该进程将返回运行中。</td>
</tr>
<tr>
<td>睡眠</td>
<td>D</td>
<td>TASK_UNINERRUPTIBLE：此进程也正在睡眠，但与S状态不同，不会响应信号。仅在进程终端可能会导致以外设备状态下使用。</td>
</tr>
<tr>
<td>睡眠</td>
<td>K</td>
<td>TASK_KILLABLE：与不可中断的D状态相同，但有所修改，允许等待中的任务响应要被中止（彻底退出）的信号。实用程序通常将可中止的进程显示为D状态。</td>
</tr>
<tr>
<td>睡眠</td>
<td>I</td>
<td>TASK_REPORT_IDLE：D状态的一个子集。在计算负载平均值时，内核不会统计这些进程。用于内核线程。设置了TASK_UNINTEERRUPTIBLE和TASK_NOLOAD标志。类似于TASK_KILLABLE，也是D状态的一个子集。它接受致命信号。</td>
</tr>
<tr>
<td>已停止</td>
<td>T</td>
<td>TASK_STOPPED：进程已被停止（暂停），通常是通过用户或其他进程发出的信号。进程可以通过另一信号返回到运行中状态，继续执行（恢复）。</td>
</tr>
<tr>
<td>已停止</td>
<td>T</td>
<td>TASK_TRACED：正在被调试的进程也会临时停止，并且共享同一个T状态标识。</td>
</tr>
<tr>
<td>僵停</td>
<td>Z</td>
<td>EXIT_TRACED：子进程在退出时向父进程发送信号。除进程身份（PID）之外的所有资源都已释放。</td>
</tr>
<tr>
<td>僵停</td>
<td>X</td>
<td>EXIT_DEAD：当父进程清理（获取）剩余的子进程结构时，进程现在已经彻底释放。次状态无法在进程列出实用程序中看到。</td>
</tr>
</tbody></table>
<h3 id="进程状态的重要性"><a href="#进程状态的重要性" class="headerlink" title="进程状态的重要性"></a>进程状态的重要性</h3><p>​	在对系统进行故障排除时，了解内核如何于进程通信以及进程如何相互通信非常重要。系统为每个新进程分配一个状态。top命令的S列或ps的STAT列显示每个进程的状态。在单CPU系统上，一次只能运行一个进程。您可以看到多个状态为R的进程。但是，并非所有进程都在连续运行。其中一些处于等待状态。</p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527134505011.png" alt="image-20250527134505011"></p>
<p><img src="/2025/05/26/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%8A%82/image-20250527134807084.png" alt="image-20250527134807084"></p>
<p>​	使用信号来暂停、停止、恢复、终止或中断进程。进程可以捕获来自同一系统上内核、其他进程和其他用户的信号。</p>
<h3 id="列出进程"><a href="#列出进程" class="headerlink" title="列出进程"></a>列出进程</h3><p>​	ps命令用于列出当前进程的详细信息。</p>
<ul>
<li>用户标识符（UID），它确定进程的特权。</li>
<li>唯一进程标识符（PID）。</li>
<li>已用CPU量和实际时间。</li>
<li>分配的内存量。</li>
<li>进程stdout位置，称为控制终端。</li>
<li>当前的进程状态。</li>
</ul>
<p>​	<code>重要：Linux版的ps命令支持以下选项格式：</code></p>
<ul>
<li><p><code>UNIX(POSIX)选项，可以分组单必须以连字符开头。</code></p>
</li>
<li><p><code>BSD选项，可以分组但不可以与短划线同用。</code></p>
</li>
<li><p><code>GNU长选项，以爽连字符开头。</code></p>
<p><code>例如：ps -aux 命令与ps aux命令不同。</code></p>
</li>
</ul>
<p>​	常见的ps命令aux选项显示包括无控制终端的进程在内的所有进程。长列表（lax选项）提供更多详细信息，并且通过避免查询用户名可用加快显示。相似的UNIX语法使用-ef选项来显示所有进程。在以下示例中，调度的内核线程显示在列表顶部，并用方括号括起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps aux | <span class="built_in">tail</span> -n 10</span><br><span class="line">root        2313  0.0  0.0      0     0 ?        I    13:44   0:00 [kworker/1:0-events_long]</span><br><span class="line">root        2314  0.0  0.0      0     0 ?        I    13:44   0:00 [kworker/0:0-mm_percpu_wq]</span><br><span class="line">root        2336  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/5:0-events_freezable]</span><br><span class="line">root        2337  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">root        2363  0.0  0.0      0     0 ?        I    13:49   0:00 [kworker/3:1-events]</span><br><span class="line">root        2364  0.0  0.0      0     0 ?        I    13:50   0:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">root        2366  0.0  0.0      0     0 ?        I    13:52   0:00 [kworker/u256:0-events_unbound]</span><br><span class="line">root        2367  0.0  0.0      0     0 ?        I    13:55   0:00 [kworker/3:2-mm_percpu_wq]</span><br><span class="line">kiosk       2376  0.0  0.0 225500  3720 pts/0    R+   13:57   0:00 ps aux</span><br><span class="line">kiosk       2377  0.0  0.0 220988  1040 pts/0    S+   13:57   0:00 <span class="built_in">tail</span> -n 10</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ ps lax | <span class="built_in">tail</span> -n 10</span><br><span class="line">1     0    2314       2  20   0      0     0 -      I    ?          0:00 [kworker/0:0-events]</span><br><span class="line">1     0    2336       2  20   0      0     0 -      I    ?          0:00 [kworker/5:0-events_freezable]</span><br><span class="line">1     0    2337       2  20   0      0     0 -      I    ?          0:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">1     0    2363       2  20   0      0     0 -      I    ?          0:00 [kworker/3:1-events]</span><br><span class="line">1     0    2364       2  20   0      0     0 -      I    ?          0:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">1     0    2366       2  20   0      0     0 -      I    ?          0:00 [kworker/u256:0-nfsd4]</span><br><span class="line">1     0    2367       2  20   0      0     0 -      I    ?          0:00 [kworker/3:2-events_freezable_power_]</span><br><span class="line">1     0    2378       2  20   0      0     0 -      I    ?          0:00 [kworker/u256:1-events_unbound]</span><br><span class="line">0  1000    2379    2304  20   0 225500  1568 -      R+   pts/0      0:00 ps lax</span><br><span class="line">0  1000    2380    2304  20   0 220988   980 pipe_r S+   pts/0      0:00 <span class="built_in">tail</span> -n 10</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line">[kiosk@foundation0 ~]$ ps -ef | <span class="built_in">tail</span> -n 10</span><br><span class="line">root        2314       2  0 13:44 ?        00:00:00 [kworker/0:0-events]</span><br><span class="line">root        2336       2  0 13:45 ?        00:00:00 [kworker/5:0-events_freezable]</span><br><span class="line">root        2337       2  0 13:45 ?        00:00:00 [kworker/4:2-events_power_efficient]</span><br><span class="line">root        2363       2  0 13:49 ?        00:00:00 [kworker/3:1-events]</span><br><span class="line">root        2364       2  0 13:50 ?        00:00:00 [kworker/6:0-mm_percpu_wq]</span><br><span class="line">root        2366       2  0 13:52 ?        00:00:00 [kworker/u256:0-nfsd4]</span><br><span class="line">root        2367       2  0 13:55 ?        00:00:00 [kworker/3:2-events_freezable_power_]</span><br><span class="line">root        2378       2  0 13:57 ?        00:00:00 [kworker/u256:1-events_unbound]</span><br><span class="line">kiosk       2381    2304  0 13:57 pts/0    00:00:00 ps -ef</span><br><span class="line">kiosk       2382    2304  0 13:57 pts/0    00:00:00 <span class="built_in">tail</span> -n 10</span><br></pre></td></tr></table></figure>

<p>​	默认情况下，不带选项运行ps命令会选择具有与当前用户相同的有效用户ID（EUID）并与运行命令所处同一终端关联的所有进程。僵停进程使用exiting 或defunct标签列出。</p>
<p>​	您可以使用ps 命令 –forest 选项以树形格式显示进程，从而查看父进程和子进程之间的关系。</p>
<p>​	ps 命令的默认输出按进程ID编号排序。输出中似乎使用了时间顺序，但内核重复使用了进程ID，因此其顺序不如看起来那样有序。使用ps 命令-o 或 –sort 选项对输出进行排序。显示顺序与系统进程表的顺序匹配，在进程终止和进程运行时重新使用列表行。</p>
<h2 id="控制作业"><a href="#控制作业" class="headerlink" title="控制作业"></a>控制作业</h2><h3 id="描述作业和会话"><a href="#描述作业和会话" class="headerlink" title="描述作业和会话"></a>描述作业和会话</h3><p>​	借助作业控制shell功能，单个shell实例可以运行和管理多个命令。</p>
<p>​	作业与在shell提示符中输入的每个管道相关联。该管道中的所有进程均是作业的一部分，并且是同一个进程组的成员。最小管道可以被视为在shell提示符处输入的唯一一个命令，创建仅含有一个成员的一个作业。</p>
<p>​	一次只能有一个作业从特定终端窗口中读取输入和键盘生成的信号。属于改作业的进程是该终端的前台进程。</p>
<p>​	该控制终端的后台进程是与该终端相关联的任何其他作业。终端的后台进程无法从终端读取输入或接收键盘生成的中断，但可以写入到终端。后台作业可能已停止（暂停），也可能正在运行。如果某个正在运行的后台作业尝试从终端读取内容，则该作业将自动暂停。</p>
<p>​	每个终端在其自身的会话中运行，并且可以具有一个前台进程和任意数量的后台进程。一个作业仅在属于其控制终端的一个会话中。</p>
<p>​	ps命令在TTY列中显示控制终端的设备名称。某些进程（如系统守护进行）由系统启动，并不是从控制终端启动的。这些进程不是作业的成员，并且无法转至前台。ps命令在TTY列中针对这些进程显示一个问号（？）。</p>
<h3 id="在后台运行作业"><a href="#在后台运行作业" class="headerlink" title="在后台运行作业"></a>在后台运行作业</h3><p>​	任何命令或管道都可以在后台启动，只需在命令上附加一个&amp;符号即可。Bash Shell显示作业编号（特定于会话的唯一编号）在新建子进程的PID。shell不等待子进程终止，而会显示shell提示符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[1] 2490</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	如果将包含竖线（|）的命令发送到后台，将显示管道中最后一个命令的PID。所有管道进程仍是该作业的成员。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> example_command | <span class="built_in">sort</span> | mail -s <span class="string">&quot;Sort Output&quot;</span> &amp;</span><br><span class="line">[3] 2553</span><br></pre></td></tr></table></figure>

<p>​	使用jobs命令显示当前shell会话的作业列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span> </span><br><span class="line">[1]   Running                 <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[2]   Stopped                 example_command | <span class="built_in">sort</span> | mail -s <span class="string">&quot;Sort Output&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	使用fg命令将后台作业置于前台。使用（%jobNumber）格式将进程指定到前台。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="built_in">sleep</span> 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在上述例子中，sleep命令现在正在控制终端的前台运行。shell本身将睡眠，并等待这一子进程退出。</p>
<p>​	若要将前台进程发送到后台，请首先在终端中按键盘生成暂停请求（Ctrl+z）。该作业将被置于后台并暂停。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="built_in">sleep</span> 10000</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 <span class="built_in">sleep</span> 10000</span><br></pre></td></tr></table></figure>

<p>​	ps命令 j选项显示与作业相关的信息。使用ps命令j选项来查找进行和会话信息。</p>
<ul>
<li>PID是唯一的进程ID。</li>
<li>PPID是此进程的父进程（即启动（分叉）此进程的进程）的PID。</li>
<li>PGID是进程组首进程的PID，通常是作业管道中的第一个进程。</li>
<li>SID是会话首进程的PID，对于作业而言，这通常是正在其控制终端上运行的交互shell。</li>
</ul>
<p>以下示例中，sleep命令当前已停止，其状态为T。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps j</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   2297    2304    2304    2304 pts/0       2595 Ss    1000   0:00 -bash</span><br><span class="line">   2304    2490    2490    2304 pts/0       2595 T     1000   0:00 <span class="built_in">sleep</span> 10000</span><br><span class="line">   2304    2533    2531    2304 pts/0       2595 T     1000   0:00 -bash</span><br><span class="line">   2304    2597    2597    2304 pts/0       2597 R+    1000   0:00 ps j</span><br></pre></td></tr></table></figure>

<p>使用bg命令和作业ID来启动暂停的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">bg</span> %1</span><br><span class="line">[1]+ <span class="built_in">sleep</span> 10000 &amp;</span><br><span class="line">[kiosk@foundation0 ~]$ ps j</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   2297    2304    2304    2304 pts/0       2597 Ss    1000   0:00 -bash</span><br><span class="line">   2304    2490    2490    2304 pts/0       2597 S     1000   0:00 <span class="built_in">sleep</span> 10000</span><br><span class="line">   2304    2533    2531    2304 pts/0       2597 T     1000   0:00 -bash</span><br><span class="line">   2304    2597    2597    2304 pts/0       2597 R+    1000   0:00 ps j</span><br></pre></td></tr></table></figure>

<p>​	如果用户尝试退出带有暂停作业的终端窗口（会话），那么shell会发出警告。如果用户再次尝试立即退出，暂停的作业将会被终止。</p>
<p>​	<code>注意：在前面示例中，【[1]+ sleep 10000 &amp;】+符号表示此作业是当前的默认作业。如果不带%jobNumber参数使用作业控制命令，则对默认作业执行操作。-符号表示在当前默认作业完成时即将成为下一个默认作业。</code></p>
<h2 id="中止进程"><a href="#中止进程" class="headerlink" title="中止进程"></a>中止进程</h2><h3 id="使用信号控制进程"><a href="#使用信号控制进程" class="headerlink" title="使用信号控制进程"></a>使用信号控制进程</h3><p>​	信号是传递至进程的软件中断。信号向执行中的程序报告事件。生成信号的时间可以是错误或外部事件（I&#x2F;O请求或定时器过期），或者来自于显示使用信号发送命令或键盘序列。</p>
<p>​	下表列出了系统管理员常用进程管理的基本信号。请通过短名称（HUP）或全称（SIGHUP）来指代信号。</p>
<p><strong>基本进程信号</strong></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>Hangup：报告终端控制进程的终止。也请求进程重新初始化（重新加载配置）而不终止。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>Keyboard interrupt：导致程序终止。可以被拦截或处理。通过按INTR（中断）键序列（Ctrl+c）发送</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>Keyboard quit：与SIGINT相似；在终止时添加进程转储。通过按QUIT键序列（Ctrl+\）发送。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>Kill, unblockable:导致立即终止程序。无法被拦截、忽略或处理；总是致命的。</td>
</tr>
<tr>
<td>15（默认）</td>
<td>TERM</td>
<td>Terminate：导致程序终止。与SIGKILL不同，可以被拦截、忽略或处理。要求程序以”干净“的方式终止；它允许程序完成基本操作和自我清理后再终止。</td>
</tr>
<tr>
<td>18</td>
<td>CONT</td>
<td>Continue：发送至进程使其恢复（若已停止）。无法拦截。即使被处理，也始终恢复进程。</td>
</tr>
<tr>
<td>19</td>
<td>STOP</td>
<td>Stop， unblockable：暂停进程。无法被拦截或处理</td>
</tr>
<tr>
<td>20</td>
<td>TSTP</td>
<td>Keyboard stop：和SIGSTOP不通，可以被拦截、忽略或处理。通过按暂停键序列（Ctrl+z）发送。</td>
</tr>
</tbody></table>
<p>​	<code>注意：信号编号视不通Linux硬件平台而异，但信号名称和含义都是标准的。建议再发送信号时使用信号名称，而不是数字。本章节适用于X86_64架构系统。</code></p>
<p>​	每个信号都有一个默认操作，通常是如下操作之一：</p>
<ul>
<li><p>Term：立即终止程序（退出）。</p>
</li>
<li><p>Core：保存程序的内存镜像（核心转储），然后终止。</p>
</li>
<li><p>Stop：停止运行中的程序（暂停），再等待继续（恢复）。</p>
<p>程序通过实施处理程序例程来响应预期的事件信号，以忽略、替换或扩展信号的默认操作。</p>
</li>
</ul>
<h3 id="通过显示请求发送信号"><a href="#通过显示请求发送信号" class="headerlink" title="通过显示请求发送信号"></a>通过显示请求发送信号</h3><p>​	您可以想当前的前台进程发送信号，具体操作为案件键盘控制序列以暂停（Ctrl+z）、中止（Ctrl+c）或核心转储（Ctrl+\）该进程。不过，您可以使用信用发送命令向另一会话中的后台进程发送信号。</p>
<p>​	您可以通过名称（例如 -HUP 或 -SIGHUP）或编号（相关的 -1 选项）来指定信号。用户可以中止自己的进程，但需要root权限才能终止其他人拥有的进程。</p>
<p>​	kill命令使用PID编号向进程发送信号。芮苒其名为kill，但您可以使用这个命令来发送任何信号，而不仅仅是终止程序的信号。您可以使用kill命令 -l选项列出所有可用信号的名称和编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX	</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2912  0.0  0.0 220956  1048 pts/0    S    17:09   0:00 <span class="built_in">sleep</span> 1000</span><br><span class="line">root        2913  0.0  0.0 220956   996 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2920  0.0  0.0 221668  2368 pts/0    S+   17:10   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> 2912</span><br><span class="line">[1]   Terminated              <span class="built_in">sleep</span> 1000</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2913  0.0  0.0 220956   996 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2922  0.0  0.0 221668  2368 pts/0    S+   17:10   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> -9 2913</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2914  0.0  0.0 220956  1012 pts/0    S    17:10   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2924  0.0  0.0 221668  2356 pts/0    S+   17:11   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[2]-  Killed                  <span class="built_in">sleep</span> 2000</span><br><span class="line">[root@foundation0 Videos]# <span class="built_in">kill</span> -SIGTERM 2914</span><br><span class="line">[root@foundation0 Videos]# ps -aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2942  0.0  0.0 221668  2260 pts/0    S+   17:11   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[3]+  Terminated              <span class="built_in">sleep</span> 3000</span><br></pre></td></tr></table></figure>



<h3 id="控制特定进程"><a href="#控制特定进程" class="headerlink" title="控制特定进程"></a>控制特定进程</h3><p>​	使用pkill命令向一个或多个符合选择条件的进程发送信号。选择条件可用是命令名称、特定用户拥有的进程，或所有系统范围进程。</p>
<p>​	可用逐一向进程和会话发送信号，也可以集体发送。要终止一个用户的所有进程，可使用pkill命令。</p>
<p>​	由于登录会话中的初始进程（会话首进程）设计为可以处理会话终止请求并忽略不想要的键盘信号，中断某一用户的所有进程和登录shell需要使用SIGKILL信号。</p>
<p>​	首先，使用pgrep命令来确定要中止的PID编号。此命令的操作与pkill命令类似，大部分选项相同，但是pgrep命令列出进程而不是中止它们。</p>
<p>​	使用pgrep命令和-l选项列出进程名称和ID。使用任一命令和-u选项来指定拥有进程的用户的ID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# pgrep -l -u user03</span><br><span class="line">3174 systemd</span><br><span class="line">3179 (sd-pam)</span><br><span class="line">3200 sshd</span><br><span class="line">3207 bash</span><br><span class="line">[root@foundation0 home]# pkill -SIGKILL -u user03</span><br><span class="line">[root@foundation0 home]# pgrep -l -u user03</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	当需要注意的进程在同一登录会话中时，可能不需要中止用户所有的进程。使用w命令来确定会话的控制终端，然后仅中止引用同一中断ID的进程。</p>
<p>​	除非指定了SIGKILL，否则会话首进程（此处为Bash登录shell）可以成功处理中止请求并继续运行，但所有其他会话进程将被终止。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br><span class="line">3283 systemd</span><br><span class="line">3287 (sd-pam)</span><br><span class="line">3304 sshd</span><br><span class="line">3313 bash</span><br><span class="line">[root@foundation0 ~]# w -u user03</span><br><span class="line"> 18:22:33 up  7:15,  2 <span class="built_in">users</span>,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">user03   pts/1     18:16    5:49   0.03s  0.03s -bash</span><br><span class="line">[root@foundation0 ~]# pkill -t pts/1</span><br><span class="line"><span class="comment"># 此刻发现user03的bash会话首进程依然存在，有效忽略掉了中止信号</span></span><br><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br><span class="line">3283 systemd</span><br><span class="line">3287 (sd-pam)</span><br><span class="line">3304 sshd</span><br><span class="line">3313 bash</span><br><span class="line">[root@foundation0 ~]# pkill -SIGKILL -t pts/1</span><br><span class="line"><span class="comment"># 使用SIGKILL信号，则会无视忽略，强制中止</span></span><br><span class="line">[root@foundation0 ~]# pgrep -l -u user03</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：管理员通常使用SIGKILL。</code></p>
<p>​	<code>由于SIGKILL信号无法被处理或忽视，它总是致命的。然而，它会强制终止进程，而不允许被中断的进程运行自我清理例程。RedHat Linux建议先发送SIGTERM，然后尝试SIGINT；只有这两个都失败时，在尝试SIGKILL。</code></p>
<p>​	您可以借助父进程和子进程关系应用相同的选择性进程终止。使用pstree命令查看系统或单个用户的进程树。使用父进程的PID中止其创建的所有子进程。父进程Bash登录Shell不通被终止，因为信号仅定向至它的子进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)─┬─<span class="built_in">sleep</span>(2296)</span><br><span class="line">                        ├─<span class="built_in">sleep</span>(2297)</span><br><span class="line">                        └─<span class="built_in">sleep</span>(2298)</span><br><span class="line">[root@foundation0 ~]# pkill -P 2262</span><br><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)</span><br><span class="line">[root@foundation0 ~]# pkill -SIGKILL -P 2262</span><br><span class="line">[root@foundation0 ~]# pstree -p kiosk</span><br><span class="line">sshd(2255)───bash(2262)</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>



<h3 id="向多个进程发送信号"><a href="#向多个进程发送信号" class="headerlink" title="向多个进程发送信号"></a>向多个进程发送信号</h3><p>​	killall命令可以根据命令名称向多个进程发送信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# ps aux | grep <span class="built_in">sleep</span></span><br><span class="line">kiosk       2346  0.0  0.0 220956   988 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 1000</span><br><span class="line">kiosk       2347  0.0  0.0 220956   988 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 2000</span><br><span class="line">kiosk       2348  0.0  0.0 220956  1040 pts/1    S    17:12   0:00 <span class="built_in">sleep</span> 3000</span><br><span class="line">root        2350  0.0  0.0 221668  2212 pts/0    S+   17:12   0:00 grep --color=auto <span class="built_in">sleep</span></span><br><span class="line">[root@foundation0 ~]# killall <span class="built_in">sleep</span> </span><br><span class="line">[root@foundation0 ~]# ps aux | grep <span class="built_in">sleep</span></span><br><span class="line">root        2360  0.0  0.0 221668  2268 pts/0    S+   17:13   0:00 grep --color=auto <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure>

<p>​	使用kill命令终止特定的作业。在作业编号上添加前缀百分号（%）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 <span class="built_in">sleep</span> 3000 &amp;</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">kill</span> -SIGTERM %1</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Terminated              <span class="built_in">sleep</span> 3000</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>



<h3 id="以管理员身份注销用户"><a href="#以管理员身份注销用户" class="headerlink" title="以管理员身份注销用户"></a>以管理员身份注销用户</h3><p>​	出于各种原因，您可能需要注销其他用户。一些可能的情景：用户做出了安全违规行为；用户可能过度使用了资源；用户的系统不响应；或者，用户不当访问了资料。在这些情形中，您必须以管理员身份使用信号来终止其会话。</p>
<p>​	要注销某个用户，首先确定要终止的登录会话。使用w命令列出用户登录和当前运行的进程。记录TTY和FROM列，以确定要关闭的会话。</p>
<p>​	所有用户登录会话都与某个中断设备(TTY)相关联。如果设备名称为pts&#x2F;N，说明这时一个与图形终端窗口或远程登录会话相关联的伪终端。如果为ttyN，则说明用户位于一个系统控制台、替代控制台或其他直接连接的终端设备上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# w</span><br><span class="line"> 17:49:39 up  1:06,  3 <span class="built_in">users</span>,  load average: 1.29, 0.29, 0.10</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kiosk    pts/0     16:44    1.00s  0.22s  0.06s sshd: kiosk [priv]  </span><br><span class="line">kiosk    pts/1     16:50   34.00s  0.05s  0.05s -bash</span><br><span class="line">user01   tty2      17:49    1:05m  0.08s  0.07s /usr/libexec/gnome-session-binary</span><br></pre></td></tr></table></figure>

<p>​	查看会话登录时间，了解用户已登录该系统的时长。对于每个会话，当前作业占用的CPU资源（包括后台任务和子进程）位于JCPU列中。当前的前台进程CPU占用情况列在PCPU中。</p>
<h2 id="监控进程活动"><a href="#监控进程活动" class="headerlink" title="监控进程活动"></a>监控进程活动</h2><h3 id="描述负载平均值"><a href="#描述负载平均值" class="headerlink" title="描述负载平均值"></a>描述负载平均值</h3><p>​	负载平均值是Linux内核提供的一种度量，可以表示一段时间内感知的系统负载。它可用来粗略衡量待处理的系统资源请求数量，并确定系统负载的增减。</p>
<p>​	根据处于可运行和不可中断状态的进程数，内核会每五秒收集一次当前的负载数。通过汇总这些数值，可以得到最近1分钟、5分钟和15分钟内的指数移动平均值。</p>
<h3 id="负载平均值计算"><a href="#负载平均值计算" class="headerlink" title="负载平均值计算"></a>负载平均值计算</h3><p>​	负载平均值代表一段时间内感知的系统负载。通过报告CPU上准备运行的进程数以及等待磁盘或网络I&#x2F;O完成的进程数，Linux可以确定负载平均值。</p>
<ul>
<li>负载数是准备运行的进程数（进程状态为R）或等待I&#x2F;O完成的进程数（进程状态为D）的运行平均值。</li>
<li>一些UNIX系统仅考虑CPU使用率或运行列长度来指示系统负载。Linux还包含磁盘或网络利用率，因为与CPU负载一样，这些资源使用量较高会对系统性能产生重大影响。如果负载平均值很高但CPU活动很低，请检查磁盘和网络活动。</li>
</ul>
<p>​	负载平均值可以粗略衡量在执行其他任何作业之前，有多少进程当前在等待请求完成。请求可能是用于运行进程的CPU时间。或者，请求可能是让关键磁盘I&#x2F;O操作完成；在其他作业请求完成之前，不能在CPU上运行该进程，即使CPU空闲也不行。无论是哪种方法，都会影响系统负载；系统的运行看起来会变慢，因为有进程正在等待运行。</p>
<h3 id="解读负载平均值"><a href="#解读负载平均值" class="headerlink" title="解读负载平均值"></a>解读负载平均值</h3><p>​	uptime命令是显示当前负载平均值的一种方法。它可显示当前时间、计算机启动时长、运行的用户会话数以及当前的负载平均值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">uptime</span> </span><br><span class="line"> 16:30:20 up  6:24,  1 user,  load average: 0.07, 0.03, 0.01</span><br></pre></td></tr></table></figure>

<p>​	这三个负载平均值代表了最近1、5和15分钟的负载情况。它指出了系统负载似乎在增高还是降低。</p>
<p>​	如果等待CPU处理的进程是负载平均值的主要贡献因素，则可以计算近似的每个CPU负载值以判断系统是否在遭遇显著的等待。</p>
<p>​	使用lscpu命令来确定系统上存在的CPU数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# lscpu </span><br><span class="line">Architecture:            x86_64</span><br><span class="line">  CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">  Address sizes:         45 bits physical, 48 bits virtual</span><br><span class="line">  Byte Order:            Little Endian</span><br><span class="line">CPU(s):                  8</span><br><span class="line">  On-line CPU(s) list:   0-7</span><br><span class="line">Vendor ID:               GenuineIntel</span><br><span class="line">  BIOS Vendor ID:        GenuineIntel</span><br><span class="line">  Model name:            13th Gen Intel(R) Core(TM) i9-13980HX</span><br><span class="line">    BIOS Model name:     13th Gen Intel(R) Core(TM) i9-13980HX</span><br><span class="line">    CPU family:          6</span><br><span class="line">    Model:               183</span><br><span class="line">    Thread(s) per core:  1</span><br><span class="line">    Core(s) per socket:  2</span><br><span class="line">    Socket(s):           4</span><br><span class="line">    Stepping:            1</span><br><span class="line">    BogoMIPS:            4838.40</span><br><span class="line">    Flags:               fpu vme de pse tsc msr pae mce cx8 ...忽略....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	暂时不妨设想，需要CPU时间的进程是负载数的唯一贡献因素。然后您可以用显示的负载平均值除以系统中的逻辑CPU数。值低于1表示资源利用率适当，等待时间较短。值高于1表示资源饱和，而且有一些处理处于延迟。</p>
<p>​	空闲CPU队列的负载数为0。每个等待CPU处理的进程都会使负载数加1.如果有一个进程在CPU上运行，则负载数为1；虽然资源（CPU）处于使用状态，单没有等待的请求。如果改进程运行了整整一分钟，那么它对这一分钟负载平均值的贡献就是1。</p>
<p>​	不过，因为磁盘或忘了资源忙碌而等待关键I&#x2F;O并处于不可中断睡眠状态的进行也包含在该计数内，而且会使负载平均值增大。虽然不能表示CPU使用率，但这些进程也被添加到队列数中，因为它们正在等待资源，并且在获取资源之前无法在CPU上运行。由于资源限制导致无法运行，因此这一指标仍被视为系统负载。</p>
<p>​	在资源饱和之前，负载平均值将保持在1以下，因为几乎不会在队列中发现等待的认为。只有资源饱和导致请求留在排队状态并且被负载计算例程计数时，负载平均值才会增大。当资源使用率接近100%时，每个增加的请求将开始遭遇服务等待时间。</p>
<h3 id="实时进程监控"><a href="#实时进程监控" class="headerlink" title="实时进程监控"></a>实时进程监控</h3><p>​	top命令显示系统进程的动态视图，以及一个摘要标题，后跟一个进程或线程列表。与静态的ps命令输出不同，top命令以可配置的间隔持续刷新，而且也提供列重新排列、排序和突出显示功能。您可以对top设置进行持久更改。默认的top输出列如下：</p>
<ul>
<li>进程ID（PID）</li>
<li>进程所有者用户名（USER）</li>
<li>虚拟内存（VIRT）是进程正在使用的所有内存，包括常驻集合、共享库，以及任何映射或交换的内存页。（在ps命令中标题为VSZ）</li>
<li>常驻内存（ERS）是进程所使用的物流内存，包括任何驻留2的共享对象（在ps命令中标题为RSS）</li>
<li>进程状态（S）可以是以下状态之一：<ul>
<li>D&#x3D; 不可中断睡眠</li>
<li>R&#x3D;运行中可运行</li>
<li>S&#x3D;睡眠中</li>
<li>T&#x3D;已停止或已跟踪</li>
<li>Z&#x3D;僵停</li>
</ul>
</li>
<li>CPU时间（TIME）是进程启动以来总的处理时间。可以切换为包含所有过去子进程的累计时间。</li>
<li>进程命令名称（CMMMAND）。</li>
</ul>
<p><strong>top命令中的基本击键操作</strong></p>
<table>
<thead>
<tr>
<th>键</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>？或h</td>
<td>交互式击键操作的帮助。</td>
</tr>
<tr>
<td>l、t、m</td>
<td>切换到负载、线程和内存标题行。</td>
</tr>
<tr>
<td>1</td>
<td>标题张却换显示单独CPU信息或所有CPU汇总。</td>
</tr>
<tr>
<td>s</td>
<td>更改（屏幕）刷新率，以小数点的秒数表示（如0.5、1、5）</td>
</tr>
<tr>
<td>b</td>
<td>却换反色突出显示Running进程；默认为仅粗体。</td>
</tr>
<tr>
<td>Sheift+b</td>
<td>在显示中使用粗体，用于标题以及运行中的进程。</td>
</tr>
<tr>
<td>Sheift+h</td>
<td>切换线程；显示进程摘要或单独线程。</td>
</tr>
<tr>
<td>u、Sheift+u</td>
<td>过滤任何用户名（有效、真实）</td>
</tr>
<tr>
<td>Sheift+m</td>
<td>按照内存使用率，以降序方式对进程列表排序。</td>
</tr>
<tr>
<td>Sheift+p</td>
<td>按照处理器使用率，以降序方式对进程列表排序。</td>
</tr>
<tr>
<td>k</td>
<td>中止进程。如有提示，输入PID，在输入signal。</td>
</tr>
<tr>
<td>r</td>
<td>调整进程的nice值。若有提示，输入PID，再输入nice_value。（nice值为-20到19，值越低代表该进程优先级越高）</td>
</tr>
<tr>
<td>Sheift+w</td>
<td>写入（保存）当前的显示配置，一遍下一次重新启动top时使用</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>f</td>
<td>通过启用或禁用字段的方式来管理列。也可以为top设置排序字段。（d选中或显示列，s切换该列进行排序，q退出设置）</td>
</tr>
</tbody></table>
<p>​	<code>注意：再安全模式下启动top命令时，s、k和r击键操作不可用。</code></p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第一章节</title>
    <url>/2025/02/27/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="红帽企业Linux入门"><a href="#红帽企业Linux入门" class="headerlink" title="红帽企业Linux入门"></a>红帽企业Linux入门</h1><h2 id="为什么要了解Linux？"><a href="#为什么要了解Linux？" class="headerlink" title="为什么要了解Linux？"></a>为什么要了解Linux？</h2><p>​	Linux是IT专业人士必须了解的关键技术。</p>
<p>​	Linux目前在全球范围得到广泛的使用。互联网上的用户每天通过万维网浏览各式各样的网页，例如此刻您正在通过互联网访问我的博客网站，与Linux应用和Web服务器系统进行交互。</p>
<p>​	在现代互联网时代，Linux和Windows是主要的操作系统。随着Linux广泛在企业、云等领域的采用，您有许多理由学习Linux</p>
<ul>
<li>Windows用户需要与Linux上托管的服务进行交互。</li>
<li>应用开发中，Linux常托管应用及运行。</li>
<li>云计算中，私有云或公有云实例都在使用Linux作为操作系统</li>
<li>移动应用及移动设备等通常都运行在Linux上</li>
</ul>
<h3 id="Linux的优点"><a href="#Linux的优点" class="headerlink" title="Linux的优点"></a>Linux的优点</h3><ul>
<li><p>Linux是开源软件</p>
<ul>
<li>开源意味着免费，您可以彻底了解程序或系统的工作方式，并且可以对其进行更改，并将他分享给他人使用，从而加快创新速度。</li>
</ul>
</li>
<li><p>Linux提供命令行（CLI），不仅访问便捷，并且具有强大的脚本化功能。</p>
<ul>
<li>Linux构建时的设计理念是用户可以通过CLI执行所有管理任务。它能够轻松实现自动化、部署和配置，并简化本地和远程系统的管理，从而实现易用性和稳定性。</li>
</ul>
</li>
<li><p>Linux是一种模块化的操作系统，管理员可以轻松替换或删除组件</p>
<ul>
<li>需要时，可以对系统组件进行升级和更新，Linux是一个通用开发工作站，也可以是特意精简化的软件设备</li>
</ul>
</li>
</ul>
<h3 id="RedHat是谁？"><a href="#RedHat是谁？" class="headerlink" title="RedHat是谁？"></a>RedHat是谁？</h3><p>​	RedHat翻译过来就是红色的帽子，同时它的LoGo也是一顶红色的帽子，在国内统称为红帽。</p>
<p>​	红帽是目前世界领先的开源软件解决方案供应商，使用社区驱动的方式提供可靠和高性能的云、Linux、中间件、存储和虚拟化技术。</p>
<h3 id="什么是Linux发行版"><a href="#什么是Linux发行版" class="headerlink" title="什么是Linux发行版"></a>什么是Linux发行版</h3><p>​	Linux发行版是有一种可安装的操作系统，由Linux内核以及提供支持的用户程序和库构建而成。完整的Linux系统又多个独立的开发社区开发，这些社区协同处理各个组件。发行版让用户能够轻松安装和管理正常运行的Linux系统。</p>
<p>​	1991年，名为Linus Torvalds的人开发了Unix内核，将其命名为Linux，作为开源软件进行授权。内核是操作系统的核心，它管理着硬件、内存以及运行中的程序调度。Linux内核可通过其他开源软件加以补充，如来自GNU项目的实用工具和程序、来自MIT的X window Systen的图形界面或Apache HTTP Web服务器等其他开源组件，以构建成一个完整、开源的类Unix操作系统</p>
<h2 id="访问命令行"><a href="#访问命令行" class="headerlink" title="访问命令行"></a>访问命令行</h2><h3 id="Bash-Shell简介"><a href="#Bash-Shell简介" class="headerlink" title="Bash Shell简介"></a>Bash Shell简介</h3><p>​		命令行是基于文本的界面，可用于向计算机系统输入指令。Linux命令行由名为Shell的程序提供。</p>
<p>​		红帽 Linux中为用户提供的默认shell是GNU Bourne-Again Shell简称(bash)。bash shell是UNIX系统上原始 Bourne shell简称(sh)的改进版本。</p>
<p>​		Shell在等待用户输入时会显示有一个字符串，称为Shell提示符。当普通用户启用Shell时，提示符为（$）美元符结尾的字符。kiosk则为当前所使用的用户名，foundation0则为当前您操作的主机名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​		如果以超级用户root运行Shell，则美元符则会被替换为（#）井号字符。次字符表明当前是在超级用户下进行操作Shell，有助于避免权限过大导致的误操作，从而影响到整个系统的异常破坏。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<p>​		bash命令是非常强大的。bash shell提供了脚本语言，可支持自动化任务。同时shell还可以实现图形化工具难以规模化完成的操作。</p>
<h3 id="Shell基础知识"><a href="#Shell基础知识" class="headerlink" title="Shell基础知识"></a>Shell基础知识</h3><p>在shell提示符下输入的命令需要由三个基本部分组成：</p>
<ul>
<li>要运行的命令</li>
<li>用于命令的行为选项</li>
<li>通常作为命令的目标参数</li>
</ul>
<p>命令是也要运行的程序名称。其后可能跟着一个或多个选项，用于表示该命令的行为或作用。选项通常以一个或两个破折号开头（例如：-a或 –all），有一个破折号代表选项简写，两个代表选项全称。命令和后面可能会跟着一个或多个参数，这些参数通常用于指明应在其中运行命令的目标。</p>
<p>例如：usermod -L user01，usermod是命令，-L是选项，而user01则是参数。此命令用于锁定user01用户账号的密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# usermod -L user01</span><br></pre></td></tr></table></figure>



<h3 id="登录远程系统"><a href="#登录远程系统" class="headerlink" title="登录远程系统"></a>登录远程系统</h3><p>​		Linux与用户和管理员通常需要通过网络连接到远程系统来获得对远程系统的shell访问权限。</p>
<p>​		在Linux中，获取远程系统上的shell提示符最常用的方式是使用Secure Shell（SSH）。大多数Linux系统都会默认提供SSH的命令行程序来满足这样一用途需求。</p>
<p>​		在以下示例中，在计算机上的shell提示符中使用sshmingl以student用户身份远程登录Linux系统名为servera的主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@workstation ~]$ ssh servera@student</span><br><span class="line">The authenticity of host <span class="string">&#x27;servera (172.25.250.10)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ED25519 key fingerprint is SHA256:peUGgfxFNw6Jt6WK4CB2rs+jql1/LhA32M1+8zBawLI.</span></span><br><span class="line"><span class="string">This key is not known by any other names</span></span><br><span class="line"><span class="string"># 验证指纹</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>servera<span class="string">&#x27; (ED25519) to the list of known hosts.</span></span><br><span class="line"><span class="string">student@servera&#x27;</span>s password:  <span class="comment"># 输入远程服务器的student用户密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		ssh命令通过加密连接来防止同学被窃听或截获密码和内容。</p>
<p>​		在一些场景中，不允许ssh使用密码进行登录，以加强安全性，在不输入密码的情况下对远程计算机进行身份验证的另一种方式是利用公元幺身份验证。</p>
<p>​		使用这种身份验证时，用户需要拥有内含私钥的的特殊身份文件，这相当于与用户的加密密码。在远程服务器上的账户配置有匹配的公钥，公钥不是保密的。在登录时，用户可以指定ssh私钥，如果该远程服务器上的对应账户中安装了他们的匹配公钥就会在不询问密码的情况下让用户登录</p>
<p>​		以下示例中，计算机使用shell提示符的用户通过ssh使用公钥身份验证的方式以student用户身份登录servera主机。ssh是命令，-i选项可用于只用你当前主机的私钥文件，即.ssh&#x2F;lab_rsa。当该私钥用于远程主机servera下的student用户所拥有的公钥相互匹配，则无需密码，可直接登录到servera的shell提示符中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@workstation ~]$ ssh -i .ssh/lab_rsa servera</span><br><span class="line">Activate the web console with: systemctl <span class="built_in">enable</span> --now cockpit.socket</span><br><span class="line"></span><br><span class="line">Register this system with Red Hat Insights: insights-client --register</span><br><span class="line">Create an account or view all your systems at https://red.ht/insights-dashboard</span><br><span class="line">Last login: Wed Feb 26 05:09:03 2025 from 172.25.250.9</span><br><span class="line">[student@servera ~]$ </span><br></pre></td></tr></table></figure>



<p>​		为保证连接正常，只有拥有该私钥文件的用户才能读取私钥文件。在上述示例中，私钥位于.ssh&#x2F;lab_rsa文件中，可以使用chmod 600 .ssh&#x2F;lab_rsa来确保只有其所有者才能够读取该文件。后面的文章将会详细讨论如何设置文件权限。</p>
<p>​		此外，用户还可能配置了无需指定私钥的方式，省略上述示例中 -i 指定私钥的操作，在后续章节也会陆续详细讨论。</p>
<h3 id="从远程系统中注销退出"><a href="#从远程系统中注销退出" class="headerlink" title="从远程系统中注销退出"></a>从远程系统中注销退出</h3><p>​	当您对ssh远程主机的操作完成后，想退出远程主机的shell时，可以悬着以下方式来结束本次远程会话。</p>
<ul>
<li>快捷键：Ctrl+D来结束会话</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@servera ~]$ </span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to servera closed.</span><br><span class="line">[student@workstation ~]$</span><br></pre></td></tr></table></figure>

<ul>
<li>命令行：exit</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[student@servera ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to servera closed.</span><br><span class="line">[student@workstation ~]$ </span><br></pre></td></tr></table></figure>





<h2 id="使用Bash-Shell执行命令"><a href="#使用Bash-Shell执行命令" class="headerlink" title="使用Bash Shell执行命令"></a>使用Bash Shell执行命令</h2><h3 id="基本命令语法"><a href="#基本命令语法" class="headerlink" title="基本命令语法"></a>基本命令语法</h3><p>​	GNU Bourne-Again Shell（bash）这个程序可以理解为用户输入的命令窗口。输入到shell中的每一个字符串最多有三个部分：命令、选项（通常以-或–开头）、参数。输入到Shell中的每个单词通过空格与其他单次间隔开。命令则是系统中安装的程序名称。每个命令都具有自己的选项和参数。</p>
<p>​	在单独的行上输入每个命令。系统会显示命令的输出结果，然后显示下一行shell提示符。此命令是输出当前使用的用户名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">whoami</span> </span><br><span class="line">kiosk</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​	如果要在一行shell提示符中输入多个命令，则可以使用分号进行分割（;）。分号是一类成为元字符的字符成员，对于bash具有特殊的解读作用。这时系统会分别执行你输入的多个命令，并分别显示多个命令的输出结果，最后显示下一行shell提示符。</p>
<p>​	whoami为第一个命令，（;）分号分割，hostname为第二个命令，作用输输出当前主机名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">whoami</span> ; hostname</span><br><span class="line">kiosk</span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="编写简单命令"><a href="#编写简单命令" class="headerlink" title="编写简单命令"></a>编写简单命令</h3><p>​	date命令可显示当前的日期和时间。超级用户或者特权用户也可以使用date来设置系统时钟。使用（+）号作为参数，指定日期命令的格式字符串。</p>
<p>​	下列示例分别使用date命令显示当前时间，以及date加参数+%R指定输出格式，只输出时、分。以及+%x显示年月日。+%Y-%m-%d:%H-%M-%S则是按照你给出的参数分别自定义日期输出格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span></span><br><span class="line">Thu Feb 27 10:48:35 AM CST 2025</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%R</span><br><span class="line">10:48</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%x</span><br><span class="line">02/27/2025</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> +%Y-%m-%d:%H-%M-%S</span><br><span class="line">2025-02-27:10-49-03</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	不带选项的passwd命令将更改当前用户的密码。若要更改密码，请先指定账户原始密码（当前密码）。默认情况passwd命令配置为需要强密码，其包含小写字母、大写字母、数字呵呵字符，并且不以字典中的标准单词为基础。超级用户或者特权用户可以使用passwd命令更改其他用户的密码。</p>
<p>​	输入当前密码以及新密码时，你的输入不会在shell窗口显示，所以修改避免输入错误，建议在外部将密码粘贴进来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># Rey@183dv</span></span><br><span class="line">Retype new password: <span class="comment"># Rey@183dv</span></span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<p>​	如果输入的密码安全级别过低，是无法正常进行修改的，例如下方示例：</p>
<p>​		1、输入的密码少于8为字符，修改失败</p>
<p>​		2、密码存在于标准字典中，安全级别过低，修改失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># redhat1</span></span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">passwd: Authentication token manipulation error</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user kiosk.</span><br><span class="line">Current password: <span class="comment"># redhat</span></span><br><span class="line">New password: <span class="comment"># 1q2w3e4r</span></span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word</span><br><span class="line">passwd: Authentication token manipulation error</span><br></pre></td></tr></table></figure>



<p>​	Linux中不需要文件扩展名来区分文件类型。file命令扫描文件的已编译标头中的2位数字magic number，并显示其类型。文本文件可被识别，因为它们没有经过编译。</p>
<p>​	如下示例，分别查看了三个文件的类型，第一个为txt文本类型，第二个可执行文件，第三个为文件夹（目录）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line">[kiosk@foundation0 ~]$ file /bin/passwd </span><br><span class="line">/bin/passwd: setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a467cb9c8fa7306d41b96a820b0178f3a9c66055, <span class="keyword">for</span> GNU/Linux 3.2.0, stripped</span><br><span class="line">[kiosk@foundation0 ~]$ file /home/</span><br><span class="line">/home/: directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	magic number是什么，可以理解为你的文本文件里面的内容，它是的编码格式是什么，然后file命令就会根据你文本内容的前两个数值去分辨你当前的文件属于什么类型</p>
<p>​	例如，我当前的ssh.sh里面是一些字符串，我的fiel命令解释改文本属于txt文本类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> ssh.sh </span><br><span class="line">afadsad</span><br><span class="line">[kiosk@foundation0 ~]$ file ssh.sh </span><br><span class="line">ssh.sh: ASCII text</span><br></pre></td></tr></table></figure>

<p>​	那么我对改文本的内容进行修改，修改为了标准的shell脚本格式，此时fiile命令就会解释该文本是一个可执行文件，类似于Windows的.exe文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> ssh.sh </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">[kiosk@foundation0 ~]$ file ssh.sh </span><br><span class="line">ssh.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>



<h3 id="查看文件的内容"><a href="#查看文件的内容" class="headerlink" title="查看文件的内容"></a>查看文件的内容</h3><p>​	Linux中最简单最常用的命令是cat命令。通过这个命令您可以创建单个或多个文件以及查看文件内容，串联不同文件中的内容，以及文件内容重定向到终端或文件内。</p>
<p>​	以下示例演示如何查看&#x2F;etc&#x2F;passwd文件的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">......省略......</span><br></pre></td></tr></table></figure>



<p>​	如果要显示多个文件的内容，请再cat命令后将文件名作为参数进行传入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 ~]$ <span class="built_in">cat</span> file1 file2 </span><br><span class="line">HHA</span><br><span class="line">XIXIXI</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	如果一些文件内容较长，可能比shell终端提供的显示空间还要多很多，cat命令不会将文件的内容显示为多个页面。这时您可以使用less命令一次显示文件的一个页面，然后通过鼠标滚轮或键盘的上下键来进行翻页查看，键盘按q退出查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ less file1 </span><br></pre></td></tr></table></figure>



<p>​	head和tail命令分别显示文件的开头和结尾部分。默认情况下这两个命令显示文件的开头10行或结尾10行，但您可以通过它的选项-n 来指定一次显示自定义行数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">head</span> -n 2 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">tail</span> -n 5 /etc/passwd</span><br><span class="line">systemd-oom:x:977:977:systemd Userspace OOM Killer:/:/usr/sbin/nologin</span><br><span class="line">kiosk:x:1000:1000::/home/kiosk:/bin/bash</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">named:x:25:25:Named:/var/named:/sbin/nologin</span><br><span class="line">dhcpd:x:177:177:DHCP server:/:/sbin/nologin</span><br></pre></td></tr></table></figure>



<p>​	wc命令可计算文件中的行、字和字符数量。使用-l、-w或-c选项，分别可以仅显示行数、字数或字符数</p>
<p>​	以下示例中，我们可以看到file1文件中有一行数据，Ha Xi分别两个字数，以及加上他俩中间的空格分割符，共5个字符。分别对应上wc输出的1、2、6。这时你可能会有疑问，该文件里我怎么数都是5个字母，怎么会统计出6个字符数呢？</p>
<p>​	那是因为wc也是通过类似cat这样的命令去先去输出了文本里的内容，然后进行统计的，cat这样输出的内容会自带一个换行符，所以我们肉眼是看不出来的，但是换行符实际是存在的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> file1 </span><br><span class="line">Ha Xi</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">wc</span> file1 </span><br><span class="line">1 2 6 file1</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	如果您想把这个换行符去掉，可以使用如下命令，其中|符号，称为管道符，作用是将它前面命令的输出结果，传递到后面的命令中去使用，tr -d ‘\n’则表示删除换行符。这些目前在后面的章节会陆续进行详细讨论，目前知道我们wc时，所统计的字符数为什么会多一个的原理即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ cat file1 | tr -d &#x27;\n&#x27; | wc </span><br><span class="line">      0       2       5</span><br></pre></td></tr></table></figure>



<h3 id="了解Tab补全"><a href="#了解Tab补全" class="headerlink" title="了解Tab补全"></a>了解Tab补全</h3><p>​	通过之后的学习，我们将会遇到许多命令，包括一些命令、选项、参数等很多很长，做为人很难全部一个字符都不差的记住，这时就得用上我们的Tab补全功能，这对我们记命令、找命令的帮助是很大的，它可以帮助你快速的找到你想找的命令。</p>
<p>​	例如：我们要修改密码，但是我只知道它是pa开头的，后面的字母我记不清了，那么我们则可以通过输入pa，随后快速按两下键盘上的Tab键，他会在你主机的众多软件命令中找关于pa开头的命令，如果你主机众多软件里只有一个pa开头的，那么直接会给你把后面的字母全部自动补充上来，如果存在多个，则它会将pa开头的命令列出来，您则可以根据你的记忆去寻找相似的，勾起你粉红色的回忆。</p>
<p>​	此时，它会列出pa开头的相关命令，然后我们就在里面找，找了一圈发现，我的回忆勾起来一些了，好像是pas后面的我又记不起来了，那么我就继续pas加TAB，缩小范围，这是选择的范围就小了，目前只出现三个pas相关的了，我一看到passwd的单词就是密码的意思，我的回忆被完全勾起来了，那就再pas的基础上再加上s，pass+TAB+TAB，再主机命令中唯一了，剩下的wd就自动给补充到shell提示符中了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ pa <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">pacat                 pam_timestamp_check   parted</span><br><span class="line">pack200               pango-list            partprobe</span><br><span class="line">packer                pango-segmentation    partx</span><br><span class="line">pacmd                 pango-view            passwd</span><br><span class="line">pactl                 paperconf             <span class="built_in">paste</span></span><br><span class="line">page_owner_sort       paperconfig           pasuspender</span><br><span class="line">pam_console_apply     paplay                patch</span><br><span class="line">pam_namespace_helper  parec                 <span class="built_in">pathchk</span></span><br><span class="line">pamon                 parecord              pax11publish</span><br><span class="line">[kiosk@foundation0 ~]$ pas  <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">passwd       <span class="built_in">paste</span>        pasuspender  </span><br><span class="line">[kiosk@foundation0 ~]$ pass <span class="comment"># 快速按两下TAB+TAB</span></span><br><span class="line">[kiosk@foundation0 ~]$ passwd <span class="comment"># pass唯一了，则剩下的全部字符都自动补充上来了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	相同，每个命令的选项很多我们也是可以通过Tab的方式查找补充，TAB功能很强大，强烈建于不管现在还是工作中尽量都使用Tab进行命令、选项、参数的补充，这样可以减少我们手动输入导致的很多执行错误的问题。</p>
<p>​	我们输入命令后，选项是由一个或多个减号（-）组成的，所以我们打上一个或两个减号，在按两下tab，则可以列出该命令的全部选项，同样也支持–g这样的模糊搜索示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ useradd --  <span class="comment"># 列出useradd所有的选项</span></span><br><span class="line">--badnames              --<span class="built_in">help</span>                  --prefix</span><br><span class="line">--base-dir              --home-dir              --root</span><br><span class="line">--btrfs-subvolume-home  --inactive              --selinux-user</span><br><span class="line">--comment               --key                   --shell</span><br><span class="line">--create-home           --no-create-home        --skel</span><br><span class="line">--defaults              --no-log-init           --system</span><br><span class="line">--expiredate            --non-unique            --uid</span><br><span class="line">--gid                   --no-user-group         --user-group</span><br><span class="line">--<span class="built_in">groups</span>                --password              </span><br><span class="line">[kiosk@foundation0 ~]$ useradd --g  <span class="comment"># 列出useradd --g开头选项</span></span><br><span class="line">--gid     --<span class="built_in">groups</span>  </span><br><span class="line">[kiosk@foundation0 ~]$ useradd --g</span><br></pre></td></tr></table></figure>



<h3 id="在Shell上编辑多行长命令"><a href="#在Shell上编辑多行长命令" class="headerlink" title="在Shell上编辑多行长命令"></a>在Shell上编辑多行长命令</h3><p>​	在以后的学习及工作中，我们可能会遇到命令+多个选项、参数组成的一个很长的执行命令，在一行Shell提示符中无法一次展示，且阅读性很差。这时我们可以选择将该命令分成多行来书写，我们直接回车换行，回车的含义（作用）是执行，这样我们的命令就直接被执行，无法达到换行书写的效果。</p>
<p>​	这时我们可以通过反斜杠（\）也称为转义符，它在Linux中的作用是忽略后续字符的含义，所有我们在需要换行书写的结尾接上反斜杠（\）我们的回车执行的含义就会被忽略，也就达到了换行书写的效果。</p>
<p>​	以下示例中，head -n 3表示查询文件内容的头3行，通过反斜杠（\）将我们之后要回车执行的含义给忽略掉，这样我们的命令行就切换到了下一行，我们接着写了两个路径较长的文件，查看这两个文件的内容，当我们要执行的时候最后一行不加反斜杠（\）则就是回车原本在Linux中的含义（执行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">head</span> -n 3 \</span><br><span class="line">&gt; /usr/share/dict/words \</span><br><span class="line">&gt; /usr/share/dict/linux.words </span><br><span class="line"><span class="comment"># 以下是head查询出来的文件内容输出</span></span><br><span class="line">==&gt; /usr/share/dict/words &lt;==</span><br><span class="line">1080</span><br><span class="line">10-point</span><br><span class="line">10th</span><br><span class="line"></span><br><span class="line">==&gt; /usr/share/dict/linux.words &lt;==</span><br><span class="line">1080</span><br><span class="line">10-point</span><br><span class="line">10th</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>





<h3 id="显示命令历史记录"><a href="#显示命令历史记录" class="headerlink" title="显示命令历史记录"></a>显示命令历史记录</h3><p>​	在学习和工作中我们可能会遇到重复的命令需要重复用到的情况，但是又不想老是重复输入较长的命令，以及我想看看我之前都执行了哪些命令等情况。这时我们就可能需要用到历史命令记录功能，方法又两种可以查看到我们的历史命令。</p>
<ul>
<li><p>​	方法一：在shell提示符中，使用键盘中的 <code>↑</code>【PgUp】或 <code>↓</code>【PgDn】，上下箭头来翻页查找之前输入过的命令。</p>
</li>
<li><p>方法二：通过history命令，可以将您输入的命令以结果输出的方式展示出来，并且带有每条命令的number序号</p>
<p>我们通过history查看到历史命令后，我们还可以通过<code>!String</code>命令或<code>!number</code>序号，去直接执行最近或指定的命令。</p>
<p><code>!String</code>命令是执行你最近一次执行过的类似命令。</p>
<p>​	例如：<code>!ls</code>，则是执行您最近一次执行过的 <code>!ls</code> 的命令。</p>
<p><code>!number </code>则是根据你history命令查询出来的每条命令的序号指定执行。</p>
<p>​	例如：<code>!46</code>则是执行你history结果中的序号46的命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 ~]$ <span class="built_in">history</span> </span><br><span class="line">  ...忽略...</span><br><span class="line">   46  <span class="built_in">date</span>+%x</span><br><span class="line">   47  <span class="built_in">date</span> +%x</span><br><span class="line">   48  <span class="built_in">date</span> +%Y-%m-%d:%H-%M-%S</span><br><span class="line">   49  passwd </span><br><span class="line">   50  ll</span><br><span class="line">   51  file History-7.x.txt </span><br><span class="line">   52  file Foundation-20221114.tgz </span><br><span class="line">   53  <span class="built_in">ls</span> -a</span><br><span class="line">   54  <span class="built_in">ls</span> -la</span><br><span class="line">   55  <span class="built_in">ls</span> -n</span><br><span class="line">   56  file Foundation-20221114.tgz</span><br><span class="line">  ...忽略...</span><br><span class="line">  [kiosk@foundation0 home]$ !<span class="built_in">ls</span>  </span><br><span class="line"><span class="built_in">ls</span> -n  <span class="comment"># 我最近执行的ls命令是ls -n</span></span><br><span class="line">total 4</span><br><span class="line">drwx------. 18 1000 1000 4096 Feb 27 15:08 kiosk</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 home]$ !47</span><br><span class="line"><span class="built_in">date</span> +%x  <span class="comment"># 我的序号47是date +%x的命令</span></span><br><span class="line">02/27/2025</span><br><span class="line">[kiosk@foundation0 home]$</span><br></pre></td></tr></table></figure>



<h3 id="编辑命令行"><a href="#编辑命令行" class="headerlink" title="编辑命令行"></a>编辑命令行</h3><p>​	以交互方式使用时，bash具有命令行编辑功能。使用文本编辑器命令在当前输入的命令内移动并且进行修改，使用箭头键可以在当前命令内移动，也可以访问历史命令，在本章的界面部分以及做了介绍。下列表格中将介绍更强大的编辑命令方式，学会它可以帮助您在编辑命令时更加游刃有余，编辑命令更加娴熟、迅速。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+A</td>
<td>光标跳到命令行开头</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标跳到命令行末尾</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>将光标处到命令行开头的内容删除</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>将给光标处到命令行末尾内容删除</td>
</tr>
<tr>
<td>Ctrl+LeftArrow（<code>←</code>）</td>
<td>以当前光标为起点跳到命令行前一个字的开头</td>
</tr>
<tr>
<td>Ctrl+RightArrow（<code>→</code>）</td>
<td>以当前光标为起点跳到命令行后一个字的末尾</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>在历史命令记录列表中搜索模糊搜索历史命令</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除光标前的一个字</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第四章</title>
    <url>/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="理解什么是K8s控制器"><a href="#理解什么是K8s控制器" class="headerlink" title="理解什么是K8s控制器"></a>理解什么是K8s控制器</h1><h2 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h2><p>​	例如生活中的空调，当您设置了温度，告诉空调遥控器您的期望温度为25度，但是此刻房间温度是28度，遥控器就会为您控制空调的制冷、风量等，确保当前的温度接近与您期望温度，在这里遥控器就充当着控制器的角色。</p>
<p>​	对于K8s中的控制器来说，控制器通过监控集群的公共状态，并致力于将当前状态变为您的期望状态。</p>
<p>​	K8s中存在很多控制器，每个控制器管理集群状态的一个特定方面。最常见的一个控制器是使用一种类型的资源作为它的期望状态，控制器管理控制另外一个资源类型向它的期望状态演化。</p>
<p>​	例如：您的应用以容器的形式在Pods中运行；但是，直接管理单个Pod的工作量会非常繁琐。当其中一个Pod失败了，您可能希望运行一个新的Pod来替换失败的Pod。K8s控制器会帮您自动完成这些操作。</p>
<p><strong>用于管理工作负载的内置 API 包括</strong>：</p>
<ul>
<li>Deployment （也间接包括 ReplicaSet） 是在集群上运行应用的最常见方式。Deployment 适合在集群上管理无状态应用工作负载， 其中 Deployment 中的任何 Pod 都是可互换的，可以在需要时进行替换。 （Deployment 替代原来的 ReplicationController API）。</li>
<li>StatefulSet 允许你管理一个或多个运行相同应用代码、但具有不同身份标识的 Pod。 StatefulSet 与 Deployment 不同。Deployment 中的 Pod 预期是可互换的。 StatefulSet 最常见的用途是能够建立其 Pod 与其持久化存储之间的关联。 例如，你可以运行一个将每个 Pod 关联到 PersistentVolume 的 StatefulSet。如果该 StatefulSet 中的一个 Pod 失败了，Kubernetes 将创建一个新的 Pod， 并连接到相同的 PersistentVolume。</li>
<li>DaemonSet 定义了在特定节点上提供本地设施的 Pod， 例如允许该节点上的容器访问存储系统的驱动。当必须在合适的节点上运行某种驱动或其他节点级别的服务时， 你可以使用 DaemonSet。DaemonSet 中的每个 Pod 执行类似于经典 Unix &#x2F; POSIX 服务器上的系统守护进程的角色。DaemonSet 可能对集群的操作至关重要， 例如作为插件让该节点访问集群网络， 也可能帮助你管理节点，或者提供增强正在运行的容器平台所需的、不太重要的设施。 你可以在集群的每个节点上运行 DaemonSets（及其 Pod），或者仅在某个子集上运行 （例如，只在安装了 GPU 的节点上安装 GPU 加速驱动）。</li>
<li>你可以使用 Job 和&#x2F;或 CronJob 定义一次性任务和定时任务。 Job 表示一次性任务，而每个 CronJob 可以根据排期表重复执行。</li>
</ul>
<p>​	</p>
<h2 id="ReplicaSet控制器"><a href="#ReplicaSet控制器" class="headerlink" title="ReplicaSet控制器"></a>ReplicaSet控制器</h2><p>​	ReplicaSet控制器确保在任何时候都有特定数量的Pod副本处于运行状态，也就是说通过ReplicaSet控制器创建的多个Pods都会被ReplicaSet控制器所控制，并保证这些Pods总是处于可用正常运行的状态。</p>
<p>​	例如：您通过ReplicaSet控制器创建了一组Pod数量为3个，在运行过程中如果其中一个Pod宕机或者被删除了，那么ReplicaSet控制器就会自动创建一个Pod，以保证您期望的3个Pod始终在线。</p>
<h3 id="何时使用ReplicaSet"><a href="#何时使用ReplicaSet" class="headerlink" title="何时使用ReplicaSet"></a>何时使用ReplicaSet</h3><p>​	ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。</p>
<p>​	这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义你的应用。Deployment后续会相继介绍。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>​	<strong>YAML关键参数解析</strong></p>
<ul>
<li><strong>spec.selector.matchLabels</strong>：标签选择器，用于ReplicaSet控制器选定哪些Pod归该资源进行控制，这是控制器重要的参数。</li>
<li><strong>spec.replicas</strong>：副本数，用于设定您期望的Pod副本数，控制器将始终保持该组Pod数接近您期望的数值。</li>
<li><strong>spec.template</strong>：该模块下面用于定义您的Pod以及容器的创建模板，于之前学习的创建Pod的YAML类似。</li>
<li><strong>spec.template.metadata.labels</strong>：为Pod定义标签，与selector(标签选择器)相互配合，为Pod创建标签，标签相互匹配后，ReplicaSet控制器即可将该组Pod归为自己管理的Pod组。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; replicaset.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: ReplicaSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">  name: nginx-rs</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 3</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          protocol: TCP</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行Yaml文件创建资源，可以使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f replicaset.yaml</span><br></pre></td></tr></table></figure>

<p>​	查看资源创建状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询目前存在一个名为nginx-rs的ReplicaSet资源</span></span><br><span class="line"><span class="comment"># DESIRED期望副本数3，CURRENT当前副本数3，READY正在允许的副本数3</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get -f replicaset.yaml </span><br><span class="line">NAME       DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-rs   3         3         3       20h</span><br><span class="line"><span class="comment"># 通过--show-labels显示资源标签，-l搜索具有app=nginx标签的资源</span></span><br><span class="line"><span class="comment"># 当前具有3个受ReplicaSet管理的Pod资源</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-5p8k8   1/1     Running   1 (16m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (16m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (16m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>

<p>​	当您通过命名删除一个Pod，模拟某一个Pod掉线的情况时，秒删除，秒级速度为您重新拉起一个新的Pod，以保证您该组Pod副本数始终保持为3。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除其中一个Pod</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl delete pods  nginx-rs-5p8k8</span><br><span class="line">pod <span class="string">&quot;nginx-rs-5p8k8&quot;</span> deleted</span><br><span class="line"><span class="comment"># ReplicaSet控制器马上新拉起一个名为nginx-rs-fmdqf的Pod，保证副本数处于3</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (25m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-fmdqf   1/1     Running   0             2s    app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (26m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>

<p>​	<strong>重要：由于ReplicaSet控制器是通过标签来进行管理和识别当前的副本数的，如果此刻您的副本数是满足的，您手动创建了一个具备选择器选择的相同标签的Pod，那么您手动创建的这个Pod马上就会被控制器删除掉，因为控制器会检测到这个Pod，发现副本数超了，控制器会把最后创建的给删掉。</strong></p>
<p>​	<strong>如果您手动创建具备同标签的Pod时，刚好副本数当前是不满足的状态，那么你新创建的这个Pod会加入到ReplicaSet控制器进行管理，即便他里面的images不同。</strong></p>
<p>​	<strong>所以我们在使用和管理K8s时，最好使用yaml进行统一创建和删除，同时前期也要对您部署的微服务做好统一的规划，避免冲突出现。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动创建一个名为：centos，使用的镜像为：centos，并且同样具备app=nginx标签的pod</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl run --image centos  -l app=nginx centos</span><br><span class="line">pod/centos created</span><br><span class="line"><span class="comment"># 再次查询发现新创建的Pod不存在，被控制器删掉了</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx --show-labels </span><br><span class="line">NAME             READY   STATUS    RESTARTS      AGE   LABELS</span><br><span class="line">nginx-rs-9xx7b   1/1     Running   1 (38m ago)   21h   app=nginx</span><br><span class="line">nginx-rs-fmdqf   1/1     Running   0             12m   app=nginx</span><br><span class="line">nginx-rs-pjlth   1/1     Running   1 (38m ago)   21h   app=nginx</span><br></pre></td></tr></table></figure>



<h2 id="Deployments控制器"><a href="#Deployments控制器" class="headerlink" title="Deployments控制器"></a>Deployments控制器</h2><p>​	Deployment用于管理运行一个应用负载的一组Pod，通常适用于不保持状态的负载。</p>
<h3 id="Deployment与ReplicaSet区别"><a href="#Deployment与ReplicaSet区别" class="headerlink" title="Deployment与ReplicaSet区别"></a><strong>Deployment与ReplicaSet区别</strong></h3><p>​	Deployment是一个可以拥有ReplicaSet并使用声明式方式再服务器端完成对Pod滚动更新的对象。尽管ReplicaSet可以独立使用，但它的主要用途是作为Deployment的编排Pod创建、删除、更新和Pod 自动扩缩器的一种机制，因为有了Deployment使得它们整体更加的健硕。当您使用了Deployment时，您不需要关心如何管理它所创建的ReplicaSet，Deployment 拥有并管理其 ReplicaSet。 因此，建议你在需要 ReplicaSet 时使用 Deployment，并且管理整个架构时仅需对Deployment进行管理，再由Deployment去管理旗下的ReplicaSet或Pod。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>​	创建Deployment的yaml文件，用于创建和管理该Deployment，重点Yaml参数解析如下：</p>
<ul>
<li>spec.replicas：该Deployment所创建管理的ReplicaSet控制器的期望副本数。</li>
<li>spec.replicas.selector.matchLabels：用于创建Deployment以及它所创建的ReplicaSet的标签选择器，用于标识归其所管理的Pod资源。</li>
<li>spec.template：以下为所创建具体资源Pod的模板类。</li>
<li>spec.template.metadata.labels：用于该模板Pod创建时具有的标签，与标签选择器一致，标识这些具有同类标签的为一组资源，归该Deployment所管理。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line">  name: nginx-dlt</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-dlt</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-dlt</span><br><span class="line">      namespace: book-k8s</span><br><span class="line">    spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: nginx-dlt</span><br><span class="line">       image: nginx:1.14.2</span><br><span class="line">       imagePullPolicy: IfNotPresent</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 80</span><br><span class="line">         protocol: TCP</span><br></pre></td></tr></table></figure>

<p>​	运行Yaml文件创建资源，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f deployment.yaml </span><br><span class="line">deployment.apps/nginx-dlt created</span><br></pre></td></tr></table></figure>

<p>​	查看Deployment资源创建状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt --show-labels </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE   LABELS</span><br><span class="line">nginx-dlt   3/3     3            3           10m   &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	根据标签查看Deployment创建并管理的ReplicaSet资源状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE   LABELS</span><br><span class="line">nginx-dlt-7b5fbfc86b   3         3         3       13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br></pre></td></tr></table></figure>

<p>​	根据标签查看ReplicaSet资源所创建的Pod状态，可使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pod -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-dlt-7b5fbfc86b-89t7p   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br><span class="line">nginx-dlt-7b5fbfc86b-ckl5k   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br><span class="line">nginx-dlt-7b5fbfc86b-frkt8   1/1     Running   0          13m   app=nginx-dlt,pod-template-hash=7b5fbfc86b</span><br></pre></td></tr></table></figure>



<h3 id="Deployment滚动更新"><a href="#Deployment滚动更新" class="headerlink" title="Deployment滚动更新"></a>Deployment滚动更新</h3><p>​	根据上述示例，我们创建了一个具有nginx:1.14.2镜像的Pod服务，此刻我们希望将镜像更新为nginx:1.16.1版本，可以按照如下操作进行滚动更新。</p>
<ul>
<li>kubectl：二进制命令</li>
<li>set：修改</li>
<li>image：镜像</li>
<li>deployments：修改的资源是deployments资源</li>
<li>nginx-dlt：deployments的资源名称</li>
<li>ginx-dlt：创建容器时的容器名，标识要修改哪个容器</li>
<li>&#x3D;nginx:1.16.1：要更新的容器镜像版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<p>​	更新完成后，我们会发现我们的rs会多出一条，但是其中一个rs是之前我们初次创建deployment时生成的rs，当前该rs处于全员下线的状态，这就是我们前面所说的，滚动更新，他会新增一个rs，并仅关闭一定数量的Pod，最新版本的rs中有一个Pod启动了，旧的rs就会下线一个，依次滚动轮换，始终保持更新业务不间断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs -l app=nginx-dlt --show-labels </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE    LABELS</span><br><span class="line">nginx-dlt-6dbffd95f4   0         0         0       10m    app=nginx-dlt,pod-template-hash=6dbffd95f4</span><br><span class="line">nginx-dlt-7f77dfcf6c   3         3         3       8m5s   app=nginx-dlt,pod-template-hash=7f77dfcf6c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	以防万一，我们还可以通过describe选项查看deployment详细资源描述，验证镜像是否已更换为最新版本镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.16.1</span><br></pre></td></tr></table></figure>







<h3 id="Deployment版本回滚"><a href="#Deployment版本回滚" class="headerlink" title="Deployment版本回滚"></a>Deployment版本回滚</h3><p>​	如果我们在版本更新后发现，新版本存在重大BUG，我们需要将新版本回退到之前的版本，我们可以按照如下方法进行操作。</p>
<p>​	首先使用<code>rollout</code>选项中的<code>history</code>，查看名为nginx-dlt的deployment资源更新记录。最终我们将查看到该资源所更新过的所有记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	但是上述给出的信息仅有更新的顺序编号1、2，另外有字段是none（空），这时我们可以通过加上<code>--revision 编号</code>的方式，查看该编号具体对应的是我哪次版本的更新，经过查找，发现序号1是我需要回滚的版本为1.14.2的记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt --revision 1</span><br><span class="line">deployment.apps/nginx-dlt with revision <span class="comment">#1</span></span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:	app=nginx-dlt</span><br><span class="line">	pod-template-hash=6dbffd95f4</span><br><span class="line">  Containers:</span><br><span class="line">   nginx-dlt:</span><br><span class="line">    Image:	nginx:1.14.2</span><br><span class="line">    Port:	80/TCP</span><br><span class="line">    Host Port:	0/TCP</span><br><span class="line">    Environment:	&lt;none&gt;</span><br><span class="line">    Mounts:	&lt;none&gt;</span><br><span class="line">  Volumes:	&lt;none&gt;</span><br><span class="line">  Node-Selectors:	&lt;none&gt;</span><br><span class="line">  Tolerations:	&lt;none&gt;</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt --revision 2</span><br><span class="line">deployment.apps/nginx-dlt with revision <span class="comment">#2</span></span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:	app=nginx-dlt</span><br><span class="line">	pod-template-hash=7f77dfcf6c</span><br><span class="line">  Containers:</span><br><span class="line">   nginx-dlt:</span><br><span class="line">    Image:	nginx:1.16.1</span><br><span class="line">    Port:	80/TCP</span><br><span class="line">    Host Port:	0/TCP</span><br><span class="line">    Environment:	&lt;none&gt;</span><br><span class="line">    Mounts:	&lt;none&gt;</span><br><span class="line">  Volumes:	&lt;none&gt;</span><br><span class="line">  Node-Selectors:	&lt;none&gt;</span><br><span class="line">  Tolerations:	&lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>​	得知我们要回退的记录序号是1后，可通过<code>rollout</code>选项中的<code>undo</code>，对名为nginx-dlt的deployment资源，<code>--to-revision 1</code>将版本退回到1.14.2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout undo deployment nginx-dlt --to-revision 1</span><br><span class="line">deployment.apps/nginx-dlt rolled back</span><br></pre></td></tr></table></figure>

<p>​	查看资源详细信息，确认版本是否回退。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.14.2</span><br></pre></td></tr></table></figure>



<h3 id="CHANGE-CAUSE变更描述"><a href="#CHANGE-CAUSE变更描述" class="headerlink" title="CHANGE-CAUSE变更描述"></a>CHANGE-CAUSE变更描述</h3><p>​	上述介绍回滚时，我们使用<code>rollout history</code>查看历史更新记录时，发现<code>CHANGE-CAUSE</code>字段是一个为空的，所以我们只能使用<code>--revision 2</code>查看具体版本信息，已确认我们要回退的序号是多少。</p>
<p>​	CHANGE-CAUSE 的内容是从 Deployment 的 kubernetes.io&#x2F;change-cause 注解复制过来的。 复制动作发生在修订版本创建时。你可以通过以下方式设置 CHANGE-CAUSE 消息：</p>
<ul>
<li>使用 <code>[root@k8s-master-01 controller]# kubectl annotate deployments.apps nginx-dlt kubernetes.io/change-cause=&quot;image updated to 1.14.2&quot;</code> 为 当前版本的Deployment 添加注解。</li>
<li>手动编辑资源的清单。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl annotate deployments.apps nginx-dlt kubernetes.io/change-cause=<span class="string">&quot;image updated to 1.14.2&quot;</span> </span><br><span class="line">deployment.apps/nginx-dlt annotated</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         &lt;none&gt;</span><br><span class="line">3         image updated to 1.14.2</span><br></pre></td></tr></table></figure>

<p>​	或者您也可以在滚动更新时，加上–cored字段为其自动将您当前的命令当作注解进行添加。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record</span><br><span class="line">Flag --record has been deprecated, --record will be removed <span class="keyword">in</span> the future</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">3         image updated to 1.14.2</span><br><span class="line">4         kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>​	这样既可以清楚的看出每个版本更新的内容介绍，便于版本的回退及管理。</p>
<h3 id="扩缩容Deployment"><a href="#扩缩容Deployment" class="headerlink" title="扩缩容Deployment"></a>扩缩容Deployment</h3><p>​	您可以根据业务压力情况，灵活的对Deployment使用如下指令手动进行扩缩容操作 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 2</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   2/2     2            2           4h1m</span><br><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 4</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   4/4     4            4           3h59m</span><br></pre></td></tr></table></figure>

<p>​	假设集群启用了 Pod 的水平自动缩放， 你可以为 Deployment 设置自动缩放器，并基于现有 Pod 的 CPU 利用率选择要运行的 Pod 个数下限和上限。</p>
<p>​	这样可以让控制器进行自我调节，基于现有Pod的CPU利用率达到80，最大可自动扩容值15个副本，最小保持在10个副本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl autoscale deployment nginx-dlt --max 15 --min 10 --cpu-percent 80</span><br><span class="line">horizontalpodautoscaler.autoscaling/nginx-dlt autoscaled</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   10/10   10           10          4h14m</span><br></pre></td></tr></table></figure>





<h3 id="比例缩放"><a href="#比例缩放" class="headerlink" title="比例缩放"></a>比例缩放</h3><p>​	RollingUpdate 的 Deployment 支持同时运行应用程序的多个版本。 当自动缩放器缩放处于上线进程（仍在进行中或暂停）中的 RollingUpdate Deployment 时， Deployment 控制器会平衡现有的活跃状态的 ReplicaSet（含 Pod 的 ReplicaSet）中的额外副本， 以降低风险。这称为<strong>比例缩放（Proportional Scaling）</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:sometag</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<p>​	例如，你正在运行一个 10 个副本的 Deployment，其中25% max unavailable（最大不可用）, 25% max surge（最大激增）</p>
<ul>
<li>确保有10个副本正在运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   10/10   10           10          4h14m</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 Deployment 使用新镜像，碰巧该镜像无法从集群内部解析，这里采用更新一个不存在的镜像来演示阻塞。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:sometag</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>镜像更新使用 ReplicaSet <code>nginx-dlt-6788c467d8</code> 启动新的上线过程， 但由于上面提到的 <code>maxUnavailable</code> （最大不可用）、<code>maxSurge</code>（最大激增）要求，该进程当被创建出第五个副本时被阻塞了。检查上线状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6788c467d8   5         5         0       3s</span><br><span class="line">nginx-dlt-7f77dfcf6c   8         8         8       4h20m</span><br></pre></td></tr></table></figure>

<ul>
<li>然后，出现了新的 Deployment 扩缩请求。自动缩放器将 Deployment 副本增加到 15。 Deployment 控制器需要决定在何处添加 5 个新副本。如果未使用比例缩放，所有 5 个副本 都将添加到新的 ReplicaSet 中。使用比例缩放时，可以将额外的副本分布到所有 ReplicaSet。 较大比例的副本会被添加到拥有最多副本的 ReplicaSet，而较低比例的副本会进入到 副本较少的 ReplicaSet。所有剩下的副本都会添加到副本最多的 ReplicaSet。 具有零副本的 ReplicaSet 不会被扩容。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl scale deployment nginx-dlt --replicas 15</span><br><span class="line">deployment.apps/nginx-dlt scaled</span><br></pre></td></tr></table></figure>

<p>​	在上面的示例中，新的rs数量是5，旧的是8，通过扩容至15，为满足扩容需要的需求，所以4个副本被添加到旧 ReplicaSet 中，2 个副本被添加到新 ReplicaSet。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6788c467d8   7         7         0       4m54s</span><br><span class="line">nginx-dlt-7f77dfcf6c   12        12        12      4h25m</span><br></pre></td></tr></table></figure>

<p>​	假定新的副本都很健康，上线过程最终应将所有副本迁移到新的 ReplicaSet 中。 要确认这一点，请运行：</p>
<p>​	但是该演示为了演示阻塞，仅有旧副本的12个是正常的，此为演示需要。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deploy</span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   12/15   7            12          4h51m</span><br></pre></td></tr></table></figure>



<h3 id="删除水平伸缩扩容"><a href="#删除水平伸缩扩容" class="headerlink" title="删除水平伸缩扩容"></a>删除水平伸缩扩容</h3><p>​	当您要清除水平伸缩策略时，可以通过如下命令来进行删除。如您删除控制器，但是未删除水平伸缩策略，并重新创建同一名称资源，您之前所创建的策略会应用在新创建的资源中。</p>
<ul>
<li>查看水平伸缩策略</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get horizontalpodautoscalers.autoscaling nginx-dlt </span><br><span class="line">NAME        REFERENCE              TARGETS              MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-dlt   Deployment/nginx-dlt   cpu: &lt;unknown&gt;/80%   10        15        10         108m</span><br></pre></td></tr></table></figure>

<ul>
<li>删除水平伸缩策略</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl delete horizontalpodautoscalers.autoscaling nginx-dlt </span><br><span class="line">horizontalpodautoscaler.autoscaling <span class="string">&quot;nginx-dlt&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<ul>
<li>删除资源，重新创建。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl delete -f deployment.yaml </span><br><span class="line">deployment.apps <span class="string">&quot;nginx-dlt&quot;</span> deleted</span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f deployment.yaml </span><br><span class="line">deployment.apps/nginx-dlt created</span><br><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps nginx-dlt </span><br><span class="line">NAME        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-dlt   3/3     3            3           14s</span><br></pre></td></tr></table></figure>





<h3 id="暂停与恢复Deployment-的上线过程"><a href="#暂停与恢复Deployment-的上线过程" class="headerlink" title="暂停与恢复Deployment 的上线过程"></a>暂停与恢复Deployment 的上线过程</h3><p>​	在你更新一个 Deployment 的时候，或者计划更新它的时候， 你可以在触发一个或多个更新之前暂停 Deployment 的上线过程。 当你准备应用这些变更时，你可以重新恢复 Deployment 上线过程。 这样做使得你能够在暂停和恢复执行之间应用多个修补程序，而不会触发不必要的上线操作。</p>
<ul>
<li>例如，对于一个刚刚创建的 Deployment，获取Deployment、rs上线状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get deployments.apps,replicasets.apps --show-labels -l app=nginx-dlt</span><br><span class="line">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE   LABELS</span><br><span class="line">deployment.apps/nginx-dlt   3/3     3            3           12s   app=nginx-dlt</span><br><span class="line"></span><br><span class="line">NAME                                   DESIRED   CURRENT   READY   AGE   LABELS</span><br><span class="line">replicaset.apps/nginx-dlt-6dbffd95f4   3         3         3       12s   app=nginx-dlt,pod-template-hash=6dbffd95f4</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下指令对名为nginx-dlt的deployment资源启用暂停上线：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout pause deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt paused</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下指令对资源进行滚动更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record</span><br><span class="line">Flag --record has been deprecated, --record will be removed <span class="keyword">in</span> the future</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<ul>
<li>但是我们查看更新记录中并未存在我们刚才更新的那条记录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看deployment资源中当前的镜像版本是1.16.1是最新版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe deployments.apps nginx-dlt | grep -i Image:</span><br><span class="line">    Image:         nginx:1.16.1</span><br></pre></td></tr></table></figure>

<ul>
<li>最终再查看rs中还是原来的1.14.2的版本，说明我们实际的Pod并未更新成功，仅是deployment变更了而已，但是实际的rs控制Pod的资源实际还是原本的版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl describe rs nginx-dlt-6dbffd95f4 | grep -i Image:</span><br><span class="line">    Image:         nginx:1.14.2</span><br></pre></td></tr></table></figure>

<ul>
<li>那是因为我们之前做了上线暂停的操作导致的，您可以根据需要在暂停和恢复期间做更多的操作，避免未作完更改操作，提前上线，造成不必要的麻烦，例如您还想对该Pod申请更多的<code>cpu=200m、memory=512Mi</code>cpu和内存资源等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> resources -f deployment.yaml  -c=nginx-dlt --limits=cpu=200m,memory=512Mi</span><br><span class="line">deployment.apps/nginx-dlt resource requirements updated</span><br></pre></td></tr></table></figure>

<ul>
<li>当您确认修改好后，想要恢复上线过程，可以是使用如下命令进行恢复。</li>
<li>此时即可看到rs正常开始上线新版本，并且版本已变为最新，以及最新的更新记录中也产生了部署记录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs </span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6dbffd95f4   0         0         0       21m</span><br><span class="line">nginx-dlt-7495f89c5    3         3         3       13s</span><br><span class="line">[root@k8s-master-01 controller]# kubectl describe rs nginx-dlt-7495f89c5 | grep Image:</span><br><span class="line">    Image:      nginx:1.16.1</span><br><span class="line">[root@k8s-master-01 controller]# kubectl rollout <span class="built_in">history</span> deployment nginx-dlt </span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><p>​	您在生产中可能会有如下困惑，每次set更新<code>ReplicaSet</code>都会产生一条记录，并且该记录当积累到10条以后，会开始从旧版本中依次删除替换。</p>
<p>​	您如果想对<code>ReplicaSet</code>的条数有所调整的话，可以在创建Deployment的YAML文件中设置 <code>.spec.revisionHistoryLimit</code> 字段以指定保留此 Deployment 的多少个旧有 ReplicaSet。其余的 ReplicaSet 将在后台被垃圾回收。 默认情况下，此值为 10。</p>
<p>​	可参考以下示例,以下示例中<code>revisionHistoryLimit</code>值设置为0，则每次set更新，都只会保留最新的一个rs，旧的会直接被删除，如果您想能够多保留几次，则可以将该值放大。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: </span><br><span class="line">  name: nginx-dlt</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 0</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-dlt</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-dlt</span><br><span class="line">      namespace: book-k8s</span><br><span class="line">    spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: nginx-dlt</span><br><span class="line">       image: nginx:1.14.2</span><br><span class="line">       imagePullPolicy: IfNotPresent</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 80</span><br><span class="line">         protocol: TCP</span><br></pre></td></tr></table></figure>

<ul>
<li>确认当前的rs名称</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-6dbffd95f4   3         3         3       3s</span><br></pre></td></tr></table></figure>

<ul>
<li>进行更新操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl <span class="built_in">set</span> image deployments nginx-dlt nginx-dlt=nginx:1.16.1</span><br><span class="line">deployment.apps/nginx-dlt image updated</span><br></pre></td></tr></table></figure>

<ul>
<li>查看rs，由于<code>revisionHistoryLimit</code>设置的是0，所以原先版本的rs会被直接删除，替换为新的rs，旧的不再保留。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get rs</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-dlt-7f77dfcf6c   3         3         3       22s</span><br></pre></td></tr></table></figure>

<ul>
<li>但是需要注意，生产环境不能设置为0，因为这同时也会影响回滚的历史部署记录，这回导致您无法通过<code>rollout history</code>进行回滚操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl rollout history deployment nginx-dlt</span><br><span class="line">deployment.apps/nginx-dlt </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         &lt;none&gt;</span><br></pre></td></tr></table></figure>





<h2 id="DaemonSet控制器"><a href="#DaemonSet控制器" class="headerlink" title="DaemonSet控制器"></a>DaemonSet控制器</h2><p>​	DaemonSet定义了提供节点本地设施的Pod。这些设施可能对于集群的运行至关重要，例如网络辅助工具、资源监控，或者作为add-on的一部分。</p>
<p>​	DaemonSet会确保全部（或者某些）节点上运行一个Pod的副本。当有节点加入集群时，也会为他自动新增一个Pod副本。当有节点被从集群中移除时，这些Pod也会被收回。删除DaemonSet将会删除它所创建的所有Pod。</p>
<p><strong>DaemonSet的一些经典用法</strong>：</p>
<ul>
<li>在每个节点上运行集群守护进程。</li>
<li>在每个节点上运行日志收集守护进程。</li>
<li>在每个节点上运行监控守护进程。</li>
</ul>
<p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。</p>
<h3 id="编写DaemonSet规约"><a href="#编写DaemonSet规约" class="headerlink" title="编写DaemonSet规约"></a>编写DaemonSet规约</h3><ul>
<li><strong>kind: DaemonSet</strong>：创建一个资源类型为DaemonSet的资源。</li>
<li><strong>spec.template.spec.tolerations</strong>：该参数为容忍度，由于目前的要求是在所有节点上都要运行一个这样模板的Pod，在K8s默认的调度机制中，master节点是不允许运行的，所有这里要加个容忍度，让节点能够容忍该污点，具体细节后续章节中详细介绍。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; daemonSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: DaemonSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-ds</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ds</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx-ds</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: nginx-ds</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx-ds</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      tolerations:</span></span><br><span class="line"><span class="string">      - effect: NoSchedule</span></span><br><span class="line"><span class="string">        key: node-role.kubernetes.io/control-plane</span></span><br><span class="line"><span class="string">        operator: Exists</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx-ds</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行yaml，创建资源，可尝试使用如下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f daemonSet.yaml </span><br><span class="line">daemonset.apps/nginx-ds created</span><br></pre></td></tr></table></figure>

<p>​	执行后，查看想要运行结果。</p>
<p>​	<strong>发现该模板中我们并没有像deployment一样设定副本数，但是他能根据我们集群中拥有的节点数创建出对应数量的Pod副本。由于我们使用的允许容忍度，让本不执行实际工作Pod的master节点，也同时运行着该Pod副本。	所以这实验结果也就验证了最开始我们介绍的，DaemonSet的作用是可为您每个节点都运行一个Pod副本，有且只有一个。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pods -l app=nginx-ds --show-labels -o wide </span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP               NODE            NOMINATED NODE   READINESS GATES   LABELS</span><br><span class="line">nginx-ds-6wzn7   1/1     Running   0          24s   10.244.44.245    k8s-node-02     &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br><span class="line">nginx-ds-9rlrh   1/1     Running   0          24s   10.244.154.234   k8s-node-01     &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br><span class="line">nginx-ds-qm4f5   1/1     Running   0          24s   10.244.151.143   k8s-master-01   &lt;none&gt;           &lt;none&gt;            app=nginx-ds,controller-revision-hash=78b4cc6666,pod-template-generation=1</span><br></pre></td></tr></table></figure>



<h3 id="DaemonSet的调度"><a href="#DaemonSet的调度" class="headerlink" title="DaemonSet的调度"></a>DaemonSet的调度</h3><p>DaemonSet 可用于确保所有符合条件的节点都运行该 Pod 的一个副本。 DaemonSet 控制器为每个符合条件的节点创建一个 Pod，并添加 Pod 的 <code>spec.affinity.nodeAffinity</code> 字段以匹配目标主机。Pod 被创建之后，默认的调度程序通常通过设置 <code>.spec.nodeName</code> 字段来接管 Pod 并将 Pod 绑定到目标主机。如果新的 Pod 无法放在节点上，则默认的调度程序可能会根据新 Pod 的优先级抢占 （驱逐）某些现存的 Pod。</p>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>当 DaemonSet 中的 Pod 必须运行在每个节点上时，通常需要将 DaemonSet 的 <code>.spec.template.spec.priorityClassName</code> 设置为具有更高优先级的 PriorityClass， 以确保可以完成驱逐。</p>
<p>用户通过设置 DaemonSet 的 <code>.spec.template.spec.schedulerName</code> 字段，可以为 DaemonSet 的 Pod 指定不同的调度程序。</p>
<p>当评估符合条件的节点时，原本在 <code>.spec.template.spec.affinity.nodeAffinity</code> 字段上指定的节点亲和性将由 DaemonSet 控制器进行考量，但在创建的 Pod 上会被替换为与符合条件的节点名称匹配的节点亲和性。</p>
<p><code>ScheduleDaemonSetPods</code> 允许你使用默认调度器而不是 DaemonSet 控制器来调度这些 DaemonSet， 方法是将 <code>NodeAffinity</code> 条件而不是 <code>.spec.nodeName</code> 条件添加到这些 DaemonSet Pod。 默认调度器接下来将 Pod 绑定到目标主机。 如果 DaemonSet Pod 的节点亲和性配置已存在，则被替换 （原始的节点亲和性配置在选择目标主机之前被考虑）。 DaemonSet 控制器仅在创建或修改 DaemonSet Pod 时执行这些操作， 并且不会更改 DaemonSet 的 <code>spec.template</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodeAffinity:</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">    nodeSelectorTerms:</span><br><span class="line">    - matchFields:</span><br><span class="line">      - key: metadata.name</span><br><span class="line">        operator: In</span><br><span class="line">        values:</span><br><span class="line">        - target-host-name</span><br></pre></td></tr></table></figure>



<h3 id="DaemonSet滚动更新"><a href="#DaemonSet滚动更新" class="headerlink" title="DaemonSet滚动更新"></a>DaemonSet滚动更新</h3><p>​	首先我们需要先确保原有Pod模板中带有 <code>RollingUpdate</code> 更新策略的 DaemonSet，如果没有，可根据如下操作对资源设定一个具有 <code>RollingUpdate</code> 更新策略的 DaemonSet。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; daemonSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: DaemonSet</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-ds</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx-ds</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  updateStrategy: </span></span><br><span class="line"><span class="string">    type: RollingUpdate</span></span><br><span class="line"><span class="string">    rollingUpdate: </span></span><br><span class="line"><span class="string">    # 最大不可用</span></span><br><span class="line"><span class="string">      maxUnavailable: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx-ds</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      name: nginx-ds</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx-ds</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      tolerations:</span></span><br><span class="line"><span class="string">      - effect: NoSchedule</span></span><br><span class="line"><span class="string">        key: node-role.kubernetes.io/control-plane</span></span><br><span class="line"><span class="string">        operator: Exists</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx-ds</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	更新模板，可使用如下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl apply -f daemonSet.yaml </span><br><span class="line">Warning: resource daemonsets/nginx-ds is missing the kubectl.kubernetes.io/last-applied-configuration annotation <span class="built_in">which</span> is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.</span><br><span class="line">daemonset.apps/nginx-ds configured</span><br></pre></td></tr></table></figure>

<p>​	最后检查 DaemonSet 的更新策略，确保已经将其设置为 <code>RollingUpdate</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl apply -f daemonSet.yaml --dry-run=client -o go-template=<span class="string">&#x27;&#123;&#123;.spec.updateStrategy.type&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#x27;</span></span><br><span class="line">RollingUpdate</span><br></pre></td></tr></table></figure>

<p>​	命令的输出都应该为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RollingUpdate</span><br></pre></td></tr></table></figure>



<h4 id="声明式命令"><a href="#声明式命令" class="headerlink" title="声明式命令"></a>声明式命令</h4><p>如果你使用配置文件来更新 DaemonSet，请使用 <code>kubectl apply</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f daemonSet.yaml</span><br></pre></td></tr></table></figure>

<h4 id="指令式命令"><a href="#指令式命令" class="headerlink" title="指令式命令"></a>指令式命令</h4><p>如果你使用指令式命令来更新 DaemonSets，请使用 <code>kubectl edit</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit ds/nginx-ds -n kube-system</span><br></pre></td></tr></table></figure>

<h5 id="只更新容器镜像"><a href="#只更新容器镜像" class="headerlink" title="只更新容器镜像"></a>只更新容器镜像</h5><p>如果你只需要更新 DaemonSet 模板里的容器镜像，比如 <code>.spec.template.spec.containers[*].image</code>， 请使用 <code>kubectl set image</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl set image ds/nginx-ds nginx-ds=nginx:版本号 -n kube-system</span><br></pre></td></tr></table></figure>







<h2 id="StatefulSet控制器"><a href="#StatefulSet控制器" class="headerlink" title="StatefulSet控制器"></a>StatefulSet控制器</h2><p>​	StatefulSet从字面意思来理解，就是有状态的副本集合，那既然是有状态的那就肯定是有无状态的副本。</p>
<p>​	StatefulSet 运行一组 Pod，并为每个 Pod 保留一个稳定的标识。 这可用于管理需要持久化存储或稳定、唯一网络标识的应用。</p>
<p>​	StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p>
<p>​	StatefulSet 用来管理某 Pod集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p>
<p>和 <code>Deployment</code> 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p>
<p>​	如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p>
<h2 id="使用-StatefulSet"><a href="#使用-StatefulSet" class="headerlink" title="使用 StatefulSet"></a>使用 StatefulSet</h2><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值。</p>
<ul>
<li>稳定的、唯一的网络标识符。</li>
<li>稳定的、持久的存储。</li>
<li>有序的、优雅的部署和扩缩。</li>
<li>有序的、自动的滚动更新。</li>
</ul>
<p>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment可能更适用于你的无状态应用部署需要。</p>
<h3 id="什么是有状态和无状态？"><a href="#什么是有状态和无状态？" class="headerlink" title="什么是有状态和无状态？"></a>什么是有状态和无状态？</h3><p>​	在了解什么是有状态的和无状态之前，我们先来回顾一下deployments，我们前面了解过，deployments在当遇到某一组Pod异常下线后，控制器会为我们自动创建一个新的Pod来替换下线的Pod，替换过后原有未经过持久化存储的数据就会丢失，又或者无论请求发送到了哪个Pod，返回的结果都是一致的，每个Pod他都是平等的。这叫做<strong>无状态的应用</strong>。</p>
<p>​	而<strong>有状态的应用</strong>是需要具有持久化的存储，稳定的网络标识，Pod与Pod之前并不平等，即使它们用的是同一个镜像进行创建的。这类服务我们通常称之为“有状态”的服务。</p>
<p>​	他的视线不再依靠ReplicaSet，而是用StatefulSet，它具备以下特征：</p>
<ul>
<li>稳定的持久化存储，Pod重新调度后访问相同的持久化数据，可以使用PVC实现。</li>
<li>稳定的网络标识，Pod重新调度后PodName和HostName不变，基于Headless Service实现。</li>
<li>Pod都有一个”序号“，可以有序的进行扩展，部署等操作。</li>
</ul>
<h3 id="创建有状态的应用的三部曲"><a href="#创建有状态的应用的三部曲" class="headerlink" title="创建有状态的应用的三部曲"></a>创建有状态的应用的三部曲</h3><p><img src="/2025/08/06/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E5%9B%9B%E7%AB%A0/image-20251009153313117.png" alt="image-20251009153313117"></p>
<h3 id="创建statefulSet"><a href="#创建statefulSet" class="headerlink" title="创建statefulSet"></a>创建statefulSet</h3><p><strong>制作NFS共享目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建共享目录</span></span><br><span class="line">[root@k8s-master-01 data]# <span class="built_in">mkdir</span> -p /data/nfs&#123;1..3&#125;</span><br><span class="line"><span class="comment"># 如没有NFS服务，则需先安装NFS服务</span></span><br><span class="line">[root@k8s-master-01 dev]# yum -y  install nfs-kernel-server</span><br><span class="line"><span class="comment"># 开启自启及重启启动NFS服务</span></span><br><span class="line">[root@k8s-master-01 dev]# systemctl <span class="built_in">enable</span> nfs-server.service</span><br><span class="line">[root@k8s-master-01 dev]# systemctl restart nfs-server.service</span><br><span class="line"><span class="comment"># 最终查看验证得到我们NFS共享出来的三组共享目录</span></span><br><span class="line">[root@k8s-master-01 dev]# showmount -e </span><br><span class="line">Export list <span class="keyword">for</span> k8s-master-01:</span><br><span class="line">/data/nfs3 *</span><br><span class="line">/data/nfs2 *</span><br><span class="line">/data/nfs1 *</span><br></pre></td></tr></table></figure>



<p><strong>准备StorageClass（存储类）的yaml文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; my-StorageClass.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: storage.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: StorageClass</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: my-storage-class</span></span><br><span class="line"><span class="string">  annotations:</span></span><br><span class="line"><span class="string">    storageclass.kubernetes.io/is-default-class: &quot;false&quot;</span></span><br><span class="line"><span class="string">provisioner: csi-driver.example-vendor.example</span></span><br><span class="line"><span class="string">reclaimPolicy: Retain # default value is Delete</span></span><br><span class="line"><span class="string">allowVolumeExpansion: true</span></span><br><span class="line"><span class="string">mountOptions:</span></span><br><span class="line"><span class="string">  - discard # this might enable UNMAP / TRIM at the block storage layer</span></span><br><span class="line"><span class="string">volumeBindingMode: WaitForFirstConsumer</span></span><br><span class="line"><span class="string">parameters:</span></span><br><span class="line"><span class="string">  guaranteedReadWriteLatency: &quot;true&quot; # provider-specific</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<p><strong>准备statefulSet的yaml文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; statefulSet.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 创建PV</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: PersistentVolume</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: mypv1</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  storageClassName: my-storage-class</span></span><br><span class="line"><span class="string">  capacity:</span></span><br><span class="line"><span class="string">    storage: 1Gi</span></span><br><span class="line"><span class="string">  accessModes:</span></span><br><span class="line"><span class="string">    - ReadWriteOnce</span></span><br><span class="line"><span class="string">  persistentVolumeReclaimPolicy: Recycle</span></span><br><span class="line"><span class="string">  nfs:</span></span><br><span class="line"><span class="string">    path: /data/nfs1</span></span><br><span class="line"><span class="string">    server: 192.168.8.136</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建service</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - port: 80</span></span><br><span class="line"><span class="string">    name: web</span></span><br><span class="line"><span class="string">  clusterIP: None</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 创建StatefulSet</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: StatefulSet</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: web</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx # 必须匹配 .spec.template.metadata.labels</span></span><br><span class="line"><span class="string">  serviceName: &quot;nginx&quot;</span></span><br><span class="line"><span class="string">  replicas: 3 # 默认值是 1</span></span><br><span class="line"><span class="string">  minReadySeconds: 10 # 默认值是 0</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx # 必须匹配 .spec.selector.matchLabels</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      terminationGracePeriodSeconds: 10</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">        - containerPort: 80</span></span><br><span class="line"><span class="string">          name: web</span></span><br><span class="line"><span class="string">        volumeMounts:</span></span><br><span class="line"><span class="string">        - name: www</span></span><br><span class="line"><span class="string">          mountPath: /usr/share/nginx/html</span></span><br><span class="line"><span class="string">  # 在创建StatefulSet的同时，创建PVC</span></span><br><span class="line"><span class="string">  volumeClaimTemplates:</span></span><br><span class="line"><span class="string">  - metadata:</span></span><br><span class="line"><span class="string">      name: www</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span></span><br><span class="line"><span class="string">      storageClassName: &quot;my-storage-class&quot;</span></span><br><span class="line"><span class="string">      resources:</span></span><br><span class="line"><span class="string">        requests:</span></span><br><span class="line"><span class="string">          storage: 1Gi</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<p><strong>创建StatefulSet</strong></p>
<p>​	在准备好所有所需yaml文件后，可参考以下方式依次执行创建资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建存储类</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f my-StorageClass.yaml</span><br><span class="line">storageclass.storage.k8s.io/my-storage-class created</span><br><span class="line"><span class="comment"># 创建PV、service和PVC及StatefulSet</span></span><br><span class="line">[root@k8s-master-01 controller]# kubectl create -f statefulSet.yaml </span><br><span class="line">Warning: spec.persistentVolumeReclaimPolicy: The Recycle reclaim policy is deprecated. Instead, the recommended approach is to use dynamic provisioning.</span><br><span class="line">persistentvolume/mypv1 created</span><br><span class="line">service/nginx created</span><br></pre></td></tr></table></figure>



<p><strong>查看StatefulSet运行效果</strong></p>
<p>​	这里我们也发现它分别运行了2个副本，它们的Pod副本名称都有有序的，web是我们为资源取的名称，它会在我们自定义的名称后增加-0、-1….的序号，它们的启动顺序是固定的，只有等前面的启动完成，后面的才会启动，所以我们这里序号0成功，序号1目前的卡着不动了。	</p>
<p>​	这里可能就会有小伙伴有疑问了，我们要求该StatefulSet具有3个副本，但是第一个运行成功，但是第二个为什么一直在Pending等待，这就跟我们创建的PVC有关系了，我们创建PVC的时候是采用的【ReadWriteOnce】，意思就是一个读写模式，所以当我序号0的副本跟这个PVC绑定后，第二个再来请求绑定时，则就会出现失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 data]# kubectl get statefulsets.apps </span><br><span class="line">NAME   READY   AGE</span><br><span class="line">web    1/3     12m</span><br><span class="line">[root@k8s-master-01 data]# kubectl get pods --show-labels -l app=nginx</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">web-0   1/1     Running   0          13m   app=nginx,apps.kubernetes.io/pod-index=0,controller-revision-hash=web-69cd7d45cc,statefulset.kubernetes.io/pod-name=web-0</span><br><span class="line">web-1   0/1     Pending   0          13m   app=nginx,apps.kubernetes.io/pod-index=1,controller-revision-hash=web-69cd7d45cc,statefulset.kubernetes.io/pod-name=web-1</span><br></pre></td></tr></table></figure>

<p>​	到这里不要感觉懵，我们目前是还未介绍到存储和service服务发现，目前您只需要了解StatefulSet它的作用，及StatefulSet与deployment一个有状态的应用和无状态应用的区别即可。</p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>​	Job 表示一次性任务，运行完成后就会停止。</p>
<p>​	Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>
<p>​	一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p>
<p>​	你也可以使用 Job 以并行的方式运行多个 Pod。</p>
<p>​	如果你想按某种排期表（Schedule）运行 Job（单个任务或多个并行任务），可参考下面的CronJob。</p>
<p>​	该job任务负责计算 π 到小数点后 2000 位，并将结果打印出来。 此计算大约需要 10 秒钟完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; job.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: batch/v1</span></span><br><span class="line"><span class="string">kind: Job</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: pi</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: pi</span></span><br><span class="line"><span class="string">        image: perl:5.34.0</span></span><br><span class="line"><span class="string">        imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]</span></span><br><span class="line"><span class="string">      restartPolicy: Never</span></span><br><span class="line"><span class="string">  backoffLimit: 4</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可使用如下指令创建资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f job.yaml </span><br><span class="line">job.batch/pi created</span><br></pre></td></tr></table></figure>

<p>​	可使用以下指令查看运行结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl logs pi-4r9z8</span><br><span class="line">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822......</span><br></pre></td></tr></table></figure>





<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>​	CronJob 通过重复调度启动一次性的 Job。</p>
<p>​	<strong>CronJob</strong> 创建基于时隔重复调度的 Job。</p>
<p>CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 <strong>crontab</strong>（cron table）文件中的一行。 它用 Cron格式进行编写， 并周期性地在给定的调度时间执行 Job。</p>
<p>CronJob 有所限制，也比较特殊。 例如在某些情况下，单个 CronJob 可以创建多个并发任务。 请参阅下面的限制。</p>
<p>当控制平面为 CronJob 创建新的 Job 和（间接）Pod 时，CronJob 的 <code>.metadata.name</code> 是命名这些 Pod 的部分基础。 CronJob 的名称必须是一个合法的 DNS 子域值， 但这会对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 DNS 标签规则。 即使名称是一个 DNS 子域，它也不能超过 52 个字符。这是因为 CronJob 控制器将自动在你所提供的 Job 名称后附加 11 个字符，并且存在 Job 名称的最大长度不能超过 63 个字符的限制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# <span class="built_in">cat</span> &gt; cronJob.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: batch/v1</span></span><br><span class="line"><span class="string">kind: CronJob</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: hello</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  schedule: &quot;* * * * *&quot;</span></span><br><span class="line"><span class="string">  jobTemplate:</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      template:</span></span><br><span class="line"><span class="string">        spec:</span></span><br><span class="line"><span class="string">          containers:</span></span><br><span class="line"><span class="string">          - name: hello</span></span><br><span class="line"><span class="string">            image: busybox:1.28</span></span><br><span class="line"><span class="string">            imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">            command:</span></span><br><span class="line"><span class="string">            - /bin/sh</span></span><br><span class="line"><span class="string">            - -c</span></span><br><span class="line"><span class="string">            - date; echo Hello from the Kubernetes cluster</span></span><br><span class="line"><span class="string">          restartPolicy: OnFailure</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	可使用如下指令创建资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl create -f cronJob.yaml </span><br><span class="line">cronjob.batch/hello created</span><br></pre></td></tr></table></figure>



<p>​	它会根据您设置的时间，定时执行固定的任务，每次执行都会产生一个随机Pod，这里我设置的是每秒执行一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl get pods</span><br><span class="line">NAME                         READY   STATUS              RESTARTS         AGE</span><br><span class="line">centos                       0/1     ImagePullBackOff    0                49d</span><br><span class="line">centos-01                    0/1     ImagePullBackOff    0                79d</span><br><span class="line">hello-29333343-gfkcb         0/1     Completed           0                3m47s</span><br><span class="line">hello-29333344-zjbct         0/1     Completed           0                2m47s</span><br><span class="line">hello-29333345-qvcrv         0/1     Completed           0                107s</span><br><span class="line">hello-29333346-bsb4q         0/1     ContainerCreating   0                47s</span><br></pre></td></tr></table></figure>

<p>​	可通关logs指令查看运行日志结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 controller]# kubectl logs hello-29333344-zjbct </span><br><span class="line">Thu Oct  9 09:03:28 UTC 2025</span><br><span class="line">Hello from the Kubernetes cluster</span><br></pre></td></tr></table></figure>



<h3 id="Cron-时间表语法"><a href="#Cron-时间表语法" class="headerlink" title="Cron 时间表语法"></a>Cron 时间表语法</h3><p><code>.spec.schedule</code> 字段是必需的。该字段的值遵循 <a href="https://zh.wikipedia.org/wiki/Cron">Cron</a> 语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ┌───────────── 分钟 (0 - 59)</span></span><br><span class="line"><span class="comment"># │ ┌───────────── 小时 (0 - 23)</span></span><br><span class="line"><span class="comment"># │ │ ┌───────────── 月的某天 (1 - 31)</span></span><br><span class="line"><span class="comment"># │ │ │ ┌───────────── 月份 (1 - 12)</span></span><br><span class="line"><span class="comment"># │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周六）</span></span><br><span class="line"><span class="comment"># │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># │ │ │ │ │</span></span><br><span class="line"><span class="comment"># * * * * *</span></span><br></pre></td></tr></table></figure>

<p>例如 <code>0 3 * * 1</code> 表示此任务计划于每周一凌晨 3 点运行。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第二章节</title>
    <url>/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="从命令行管理文件"><a href="#从命令行管理文件" class="headerlink" title="从命令行管理文件"></a>从命令行管理文件</h1><p>​	</p>
<p>欢迎阅览我的文章，本章节将介绍什么是Linux，演示环境为RedHat-9</p>
<h3 id="描述Linux文件系统层次结构概念"><a href="#描述Linux文件系统层次结构概念" class="headerlink" title="描述Linux文件系统层次结构概念"></a>描述Linux文件系统层次结构概念</h3><p>​	Linux系统中的所有文件存储在文件系统中，他们被组织到一颗上下颠倒的树中，称为文件系统层次结构。这个层次结构是上下颠倒的树，因为树根在顶部，树根下方延伸处目录和子目录的分支。</p>
<p><img src="/2025/03/01/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%8A%82/image-20250520165728913.png" alt="image-20250520165728913"></p>
<p>​	&#x2F; 目录是根目录，位于文件系统层次结构的顶部。&#x2F; 字符还用做文件名中的目录分隔符。例如：如果etc是&#x2F; 根目录的子目录，则可将该目录指代为 &#x2F;etc。类似的，如果&#x2F;etc目录包含一个名为issue的文件，可以将该文件指代为&#x2F;etc&#x2F;issue。</p>
<p>​	&#x2F; 的子目录用于标准化用途，以便根据类型和用途整理文件，从而更加轻松的找到文件，例如：在根目录中，子目录&#x2F;boot用于存储启动系统所需的文件。</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">位置</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;boot</td>
<td>操作系统启动过程所需文件</td>
</tr>
<tr>
<td align="left">&#x2F;dev</td>
<td>供操作系统访问硬件的特殊设备文件</td>
</tr>
<tr>
<td align="left">&#x2F;etc</td>
<td>供系统及软件的配置文件</td>
</tr>
<tr>
<td align="left">&#x2F;home</td>
<td>供普通用户存储其个人数据及配置文件的主目录</td>
</tr>
<tr>
<td align="left">&#x2F;root</td>
<td>供超级用户root存储其个人数据及配置文件的主目录</td>
</tr>
<tr>
<td align="left">&#x2F;run</td>
<td>自上一次系统启动以来启动的进程的运行时数据。这些数据包括进程ID文件和锁定文件。此目录中的内容在重启时重新创建。所以该目录的数据在重启后，存放在该目录下的数据就会丢失。</td>
</tr>
<tr>
<td align="left">&#x2F;tmp</td>
<td>供临时文件使用的全局可写空间，天内未曾访问、更改或者修改的文件将自动从该目录中删除。&#x2F;var&#x2F;tmp目录也是一个临时目录，其中的文件如果在30天内为曾访问、更改或者修改过，将被自动删除</td>
</tr>
<tr>
<td align="left">&#x2F;usr</td>
<td>安装的软件、共享的库（包括文件）和只读程序数据。重要的子目录有：                                                                                       - &#x2F;usr&#x2F;bin：用户命令                                                                            - &#x2F;usr&#x2F;sbin：系统管理命令                                                               - &#x2F;usr&#x2F;local：本地自定义软件</td>
</tr>
<tr>
<td align="left">&#x2F;var</td>
<td>特定于系统的可变数据应在系统启动之间保持永久性。动态变化的文件（如数据库、缓存目录、日志文件、打印机后台处理文档和网页内容）可在&#x2F;var下找到</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="通过名称指定文件"><a href="#通过名称指定文件" class="headerlink" title="通过名称指定文件"></a>通过名称指定文件</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>​	文件或目录的路径指定其唯一的文件系统位置。跟随文件路径会遍历出一个或多个指定的子目录，用正斜杠 (&#x2F;) 分隔，直到达到目标位置。目录也称之为文件夹，可以包含其文件和其他子目录。目录的引用方式可以与文件相同</p>
<p>​	<code>注意：Linux文件名中可以接收空格字符。但是shell也使用空格来分割命令行上的选项和参数。如果命令中包含了名称带有空格的文件，则shell可能会误解释该参数，并认为该文件名是多个参数。为避免这样的情况，请将此类文件名括在引号中，以便shell激昂名称解释为单个参数。当然最好避免在文件中名中使用空格是最好的。</code></p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>​	绝对路径是一个完全限定名称，用于指定文件在文件系统层次结构中的确切位置。绝对路径从根 (&#x2F;) 目录开始寻找目标文件或目录，并包括到达特定文件所必须遍历的每个子目录。文件系统中的每个文件都有一个唯一绝对路径名，可通过一个简单的规则识别：第一个字符是正斜杠 (&#x2F;) 的路径名是绝对路径名。</p>
<p>​	例如，系统消息日志文件的绝对路径名是 &#x2F;var&#x2F;log&#x2F;messages。绝对路径名输入起来可能会太长，所以也可以通过相对于shell提示符当前工作目录的位置来查找文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation ~]# <span class="built_in">ls</span> /var/log/messages</span><br><span class="line">/var/log/messages</span><br><span class="line">[root@workstation ~]# </span><br></pre></td></tr></table></figure>



<h3 id="当前工作目录和相对路径"><a href="#当前工作目录和相对路径" class="headerlink" title="当前工作目录和相对路径"></a>当前工作目录和相对路径</h3><p>​	当用户登录并打开shell命令提示符时，初始位置通常是该用户的主目录。系统进程也有一个初始目录。用户和进程根据需要更改到其他目录。属于工作目录和当前目录指它们的当前位置</p>
<p>​	与绝对路径类似，相对路径也是标识唯一文件，但仅指定从工作目录到达文件所需的路径。相对路径遵循一个简单原则：第一字符是正斜杠之外的其他字符的路径名就是相对路径名。例如：我当前工作目录为&#x2F;var，我要找到消息日志文件则是：log&#x2F;messages</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation var]# <span class="built_in">ls</span> <span class="built_in">log</span>/messages</span><br><span class="line"><span class="built_in">log</span>/messages</span><br><span class="line">[root@workstation var]# </span><br></pre></td></tr></table></figure>

<p>​	Linux文件系统（包括ext4、XFS、GFS2和GlusterFS）是区分大小写的。在同一目录中创建FileCase.txt和filecase.txt文件将会生成两个不同的文件。</p>
<p>​	非Linux文件系统的工作方式可能会有所不同。例如：VFAT、Microsoft的NTFS和Apple的HFS+具有大小写保留行为。虽然这些文件系统不区分大小写，它们确实使用文件的原始大小写形式显示的文件名。如果在VFAT文件系统上创建上述示例中的文件，这两个名称指向同一文件，而部署指向两个不同的文件。</p>
<h3 id="浏览文件系统中的路径"><a href="#浏览文件系统中的路径" class="headerlink" title="浏览文件系统中的路径"></a>浏览文件系统中的路径</h3><p>​	pwd命令显示改shell的当前工作目录的完整路径名。此命令可帮助您却独使用当前相对路径来访问文件的语法。ls命令列出指定目录的目录内容。如果未指定目录，则列出当前工作目录的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@workstation var]# <span class="built_in">pwd</span></span><br><span class="line">/var</span><br><span class="line">[root@workstation var]# <span class="built_in">ls</span></span><br><span class="line">account  cache  db     ftp    kerberos  <span class="built_in">local</span>  <span class="built_in">log</span>   nis  preserve  spool  yp</span><br><span class="line">adm      crash  empty  games  lib       lock   mail  opt  run       tmp</span><br><span class="line">[root@workstation var]# </span><br></pre></td></tr></table></figure>



<p>​	使用cd命令可更改shell当前工作目录。如果没有未该命令指定任何参数，它将切换到您用户的主目录。</p>
<p>​	以下示例中，cd命令混用绝对路径和相对路径，以更改shell当前工作目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd查看当前工作目录</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line"><span class="comment"># 通过相对路径进去主目录的test1</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> test1/</span><br><span class="line">[student@workstation test1]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test1</span><br><span class="line">[student@workstation test1]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line"><span class="comment"># 通过绝对路径到主目录下的test3</span></span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> /home/student/test3</span><br><span class="line">[student@workstation test2]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test3</span><br><span class="line"><span class="comment"># 通过相对路径进去主目录的test2</span></span><br><span class="line">[student@workstation test1]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">cd</span> test2/</span><br><span class="line">[student@workstation test2]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student/test2</span><br><span class="line"><span class="comment"># 通过cd不加参数，返回主目录</span></span><br><span class="line">[student@workstation test2]$ <span class="built_in">cd</span> </span><br><span class="line">[student@workstation ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/student</span><br><span class="line">[student@workstation ~]$</span><br></pre></td></tr></table></figure>

<p>​	在上述示例中，默认shell提示符还显示当前工作目录绝对路径的最后一个目录。例如，对于&#x2F;home&#x2F;student&#x2F;test1目录，仅显示test1。当您的当前目录是主目录时，提示符显示波浪号字符 (~)。</p>
<p>​	touch 命令可将文件的时间戳更新为当前日期和时间，而不进行其他修改。此命令同时也可以用于创建空的文件，因为使用touch命令加上不存在的文件名参数就会导致创建该文件。在以下示例中，touch命令在Videos子目录中创建文件，以及修改文件更新时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch 接上一个不存在的文件名参数，则创建文件</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">touch</span> test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:35 test1.txt</span><br><span class="line"><span class="comment"># 向该文件添加内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">echo</span> hahaah &gt; test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cat</span> test1.txt </span><br><span class="line">hahaah</span><br><span class="line"><span class="comment"># 修改时间为17:36</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:36 test1.txt</span><br><span class="line"><span class="comment"># 当touch 接上已存在的文件名参数，则最新修改时间更新</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">touch</span>  test1.txt </span><br><span class="line"><span class="comment"># 修改时间为：17:38</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 切文件的内容未作更改</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cat</span> test1.txt </span><br><span class="line">hahaah</span><br><span class="line">[kiosk@foundation0 Videos]$ </span><br></pre></td></tr></table></figure>



<p>​	ls 命令具有多个选项，用于显示文件的属性。最常的选项是 -l （长列表格式）、-a（包含隐藏文件在内的所有文件），以及 -R （递归方式，包含所有子目录的内容）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 长格式显示目录或指定目录下的内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 6 Mar  4 17:45 dir1</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:45 dir-1.txt</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 6 Mar  4 17:45 dir2</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:45 dir-2.txt</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 长格式显示，并且显示包含隐藏文件（.haha.txt）</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -la</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x.  4 kiosk kiosk   98 Mar  4 17:45 .</span><br><span class="line">drwx------. 18 kiosk kiosk 4096 Feb 27 15:08 ..</span><br><span class="line">drwxrwxr-x.  2 kiosk kiosk    6 Mar  4 17:45 dir1</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 dir-1.txt</span><br><span class="line">drwxrwxr-x.  2 kiosk kiosk    6 Mar  4 17:45 dir2</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 dir-2.txt</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    0 Mar  4 17:45 .haha.txt</span><br><span class="line">-rw-rw-r--.  1 kiosk kiosk    7 Mar  4 17:38 test1.txt</span><br><span class="line"><span class="comment"># 长格式及递归显示dir1目录下的内容</span></span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span> -lR dir1/</span><br><span class="line"><span class="comment"># dir1下具有test-dir、test-dir-2目录</span></span><br><span class="line">dir1/:</span><br><span class="line">total 0</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 23 Mar  4 17:50 test-dir</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk 23 Mar  4 17:50 test-dir-2</span><br><span class="line"><span class="comment"># test-dir目录下具有test1.txt文件</span></span><br><span class="line">dir1/test-dir:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:50 test1.txt</span><br><span class="line"><span class="comment"># test-dir-2目录下具有test2.txt文件</span></span><br><span class="line">dir1/test-dir-2:</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 0 Mar  4 17:50 test2.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ </span><br></pre></td></tr></table></figure>

<p>​	ls -la中的显示了所有的目录，包括隐藏目录，其中顶部具有两个特殊的目录。一个圆点（.）代表当前目录，两个原点（..）则代表父级目录，也就是当前目录的上一级目录。这些特殊目录存在于系统中的每一个目录中，在使用文件管理命令时非常有用。</p>
<p>​	<code>重要：开头为圆点（.）的文件名表示为隐藏文件；在使用ls和其他命令时，无法在普通视图中看到这些文件。此行为并非一种安全功能。因为ls -a加上选项还是可以很轻松的看到该文件。隐藏文件主要还是用于必要的用户配置文件让主目录凌乱不堪，同时也可以避免重要的配置文件被误操作，复制到其他目录或被修改、删除掉。</code></p>
<p>​	您也可以讲波浪号（~）特殊字符于其他命令组合使用，以促进于主目录的交互。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前工作目录/var，通过波浪号查看主目录内容</span></span><br><span class="line">[kiosk@foundation0 var]$ <span class="built_in">ls</span> -l ~</span><br><span class="line">total 152588</span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk       127 Oct  9  2023 <span class="string">&#x27;\&#x27;</span></span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     33577 Sep 16  2022  ClassPrep.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     10853 Nov 16  2021  ClassRHAPrep.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk     18852 Jul  7  2022  ClassroomReset.txt</span><br><span class="line">****忽略****</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk      7900 Nov 22  2022  History.txt</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Music</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Pictures</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Public</span><br><span class="line">-rwxrwxrwx. 1 kiosk kiosk        12 Feb 27 11:35  ssh.sh</span><br><span class="line">drwxrwxr-x. 2 kiosk kiosk        72 Jan 31  2023  survey</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk         6 Feb  1  2023  Templates</span><br><span class="line">drwxr-xr-x. 4 kiosk kiosk        98 Mar  4 17:45  Videos</span><br><span class="line">[kiosk@foundation0 var]$ </span><br></pre></td></tr></table></figure>



<p>​	cd 命令同样有着许多选项。其中一些实用的应该尽早熟悉使用，要形成一种肌肉记忆。cd - 命令可更改到用户在进入当前目录之前所处的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过cd - 命令，迅速返回到之前所处的目录</span></span><br><span class="line">[kiosk@foundation0 var]$ <span class="built_in">cd</span> -</span><br><span class="line">/home/kiosk</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	<code>cd ..</code> 命令使用（..）隐藏目录上移一个级别，进入当前目录的父目录，而不必知道确切的父目录名称。其他隐藏目录（.）可为当前位置是来源或者目标参数的命令指定当前目录，以此免除输入目录绝对路径名的必要。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回上级目录</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> ..</span><br><span class="line">[kiosk@foundation0 home]$ <span class="built_in">pwd</span></span><br><span class="line">/home</span><br><span class="line"><span class="comment"># cd -返回上次所在目录</span></span><br><span class="line">[kiosk@foundation0 home]$ <span class="built_in">cd</span> -</span><br><span class="line">/home/kiosk</span><br><span class="line"><span class="comment"># 执行当前目录下的test.sh脚本文件</span></span><br><span class="line">[kiosk@foundation0 ~]$ bash ./test.sh </span><br><span class="line">Hello World</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用命令行工具管理文件"><a href="#使用命令行工具管理文件" class="headerlink" title="使用命令行工具管理文件"></a>使用命令行工具管理文件</h2><h3 id="命令行文件管理"><a href="#命令行文件管理" class="headerlink" title="命令行文件管理"></a>命令行文件管理</h3><p>​	创建、删除、复制和移动文件和目录，是系统管理员的常用操作。不带选项时，一些命令讲用于文件交互，或者可以通过相应的选项集来操作目录。</p>
<p>​	请注意运行命令时使用的选项。某些选项的含义可能因命令而异。</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>​	mkdir 命令可创建一个或多个目录或子目录。他取您要创建的目录的路径列表作为参数。</p>
<p>​	以下实例，将在&#x2F;home&#x2F;kiosk&#x2F;Documents目录下。使用mkdir命令和空格分割的目录名称列表来一次性创建多个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk/Documents</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">mkdir</span> ProjectX ProjectY ProjectZ</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span></span><br><span class="line">ProjectX  ProjectY  ProjectZ</span><br><span class="line">[kiosk@foundation0 Documents]$</span><br></pre></td></tr></table></figure>

<p>​	如果创建的目录参数已存在，或者您尝试创建的目录的父目录不存在，则mkdir命令将失败显示错误。</p>
<p>​	mkdir 命令 -p（父级）选项将为请求的目标位置创建缺失的父目录。在以下示例中，mkdir命令可以在缺少父级目录的情况下，用一个命令创建三个ChapterN子目录。 -p 选项可创建缺失的父目录Thesis。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiosk@foundation0 Documents]$ <span class="built_in">mkdir</span> -p Thesis/Chapter1 Thesis/Chapter2 Thesis/Chapter3</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> -R Thesis/</span><br><span class="line">Thesis/:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line"></span><br><span class="line">Thesis/Chapter1:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter2:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter3:</span><br><span class="line">[kiosk@foundation0 Documents]$</span><br></pre></td></tr></table></figure>

<p>​	请谨慎使用mkdir 命令的 -p 选项，因为在错误的拼写中可能会创建非预期的目录，不会因为对于您是非预期的目录，而生成错误消息。在以下示例中，假设您试图在Videos中创建一个Watched子目录，但在mkdir命令中不小心遗漏了Videos中的字母 “s”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> Video/Watched</span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘Video/Watched’: No such file or directory</span><br><span class="line"><span class="comment"># 加入-p选项，Watched目录将会创建在错误父目录中</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> -p Video/Watched</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -R Video</span><br><span class="line">Video:</span><br><span class="line">Watched</span><br><span class="line"></span><br><span class="line">Video/Watched:</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	mkdir 命令失败，因为Video目录不存在。如果您使用带有-p 选项的mkdir 命令，则会无意中创建Video目录。Watched子目录将会在不正确的目录中创建。</p>
<h3 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h3><p>​	cp 命令可以复制文件，并在当前目录或者其他指定目录中创建一个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> Videos/</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span></span><br><span class="line">test1.txt</span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">cp</span> test1.txt test2.txt </span><br><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">ls</span></span><br><span class="line">test1.txt  test2.txt</span><br><span class="line">[kiosk@foundation0 Videos]$</span><br></pre></td></tr></table></figure>

<p>​	也可以使用cp命令将多个文件复制到某一目录中。这种情况下，最后一个参数必须是目录。复制的文件在新目录中保留其原有名称。如果目标目录中存在同名的文件，则会覆盖原有文件。默认情况下，cp 命令不复制目录，而是会忽略它。</p>
<p>​	以下示例中列出两个目录作为参数，即Thesis和ProjecrX目录。最后一个参数（ProjecrX目录）是目标，可用作目的地。cp命令忽略了Thesis参数，因为它是要复制的对象是一个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> </span><br><span class="line">ProjecrX  text1.txt  text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">cp</span> text1.txt text2.txt Thesis ProjecrX</span><br><span class="line"><span class="built_in">cp</span>: -r not specified; omitting directory <span class="string">&#x27;Thesis&#x27;</span></span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> Thesis ProjecrX</span><br><span class="line">ProjecrX:</span><br><span class="line">text1.txt  text2.txt</span><br><span class="line"></span><br><span class="line">Thesis:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>

<p>​	Thesis目录复制失败，但test1.txt和test2.txt文件复制成功。</p>
<p>​	您可以使用cp 命令 -r 选项复制目录及其内容，请记住，您可以在命令组合中使用.和..特殊目录。在以下示例中，Thesis目录及其内容复制到ProjecrX目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">cd</span> ProjecrX/</span><br><span class="line"><span class="comment"># cp 复制， ../上级目录的Thesis目录， .目的地当前所在工作目录</span></span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">cp</span> -r ../Thesis/ .</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text1.txt  text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> -R Thesis/</span><br><span class="line">Thesis/:</span><br><span class="line">Chapter1  Chapter2  Chapter3</span><br><span class="line"></span><br><span class="line">Thesis/Chapter1:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter2:</span><br><span class="line"></span><br><span class="line">Thesis/Chapter3:</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ </span><br></pre></td></tr></table></figure>



<h3 id="移动文件和目录"><a href="#移动文件和目录" class="headerlink" title="移动文件和目录"></a>移动文件和目录</h3><p>​	mv 命令可将文件从一个位置移动到另一个位置。如果您将文件的绝对路径视为它的全名，那么移动文件实际上和重命名文件名一样。文件内容正在移动后保持不变。</p>
<p>​	使用mv命令来重命名文件。以下示例中，mv text1.txt命令将目录中的text1.txt 文件重命名为 text2.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text1.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">mv</span> text1.txt text2.txt </span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span></span><br><span class="line">text2.txt  Thesis</span><br><span class="line">[kiosk@foundation0 ProjecrX]$</span><br></pre></td></tr></table></figure>

<p>​	使用mv 命令将文件移动到另一个目录。再以下示例中，text2.txt 文件从<del>&#x2F;Documents&#x2F;ProjecrX目录移动到</del>&#x2F;Documents&#x2F;Thesis&#x2F;Chapter1目录中。您可以使用mv命令 -v选项来显示命令操作的详细输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> ../Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">mv</span> -v text2.txt ../Thesis/Chapter1/</span><br><span class="line">renamed <span class="string">&#x27;text2.txt&#x27;</span> -&gt; <span class="string">&#x27;../Thesis/Chapter1/text2.txt&#x27;</span></span><br><span class="line">[kiosk@foundation0 ProjecrX]$ <span class="built_in">ls</span> ../Thesis/Chapter1/</span><br><span class="line">text2.txt</span><br><span class="line">[kiosk@foundation0 ProjecrX]$ </span><br></pre></td></tr></table></figure>



<h3 id="删除文件和目录"><a href="#删除文件和目录" class="headerlink" title="删除文件和目录"></a>删除文件和目录</h3><p>​	rm 命令可删除文件。默认情况下，rm不会删除目录。您可以使用rm命令的 -r或 –recursive选项，使rm命令删除目录及其内容（文件）。rm -r命令首先遍历每个子目录，并在删除每个目录之前逐一删除其中的文件。</p>
<p>​	在以下示例中，不带选项时rm 命令会删除test1.txt文件，但若要删除Thesis&#x2F;Chhapter1目录，您必须添加-r 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line">test1.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> Documents/Thesis/Chapter1/test1.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> Documents/Thesis/Chapter1/</span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;Documents/Thesis/Chapter1/&#x27;</span>: Is a directory</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -r  Documents/Thesis/Chapter1/</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis/Chapter1/</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;Documents/Thesis/Chapter1/&#x27;</span>: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> Documents/Thesis</span><br><span class="line">Chapter2  Chapter3</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>重要：红帽Linux不提供命令行取消删除功能，也没有可从中恢复报关被删除文件的“垃圾桶”。垃圾桶是桌面环境（如：GNOME）的一个组件，但是不供从shell运行的命令使用。所有在使用相对路径删除文件或目录之前，最好先使用pwd命令验证您当前的工作目录。</code></p>
<p>​	您可以使用rm命令 -i 选项以交互式提示确认后再删除。这基本上与使用rm命令-f选项相反，-f选项强制删除并且不提示用户进行确认。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rm</span> -ri Thesis/</span><br><span class="line"><span class="built_in">rm</span>: descend into directory <span class="string">&#x27;Thesis/&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/Chapter2&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/Chapter3&#x27;</span>? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory <span class="string">&#x27;Thesis/&#x27;</span>? y</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rm</span> -rf ProjecrX/</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>注意：如果同时使用-i和-f选项，-f选项将具有优先权，所以再rm删除文件之前，不会提示您进行确认。</code></p>
<p>​	您也可以使用rmdir命令来删除空目录。使用rm命令-r选项可删除非空目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dir1目录非空，dir2空目录，rmdir命令无法删除非空目录，rm -r可删除非空目录</span></span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> dir1/</span><br><span class="line">text1.txt</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span> dir2</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rmdir</span> dir1/</span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;dir1/&#x27;</span>: Directory not empty</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">rmdir</span> dir2/</span><br><span class="line">[kiosk@foundation0 Documents]$ <span class="built_in">ls</span></span><br><span class="line">dir1</span><br><span class="line">[kiosk@foundation0 Documents]$ </span><br></pre></td></tr></table></figure>



<h2 id="制作文件间的链接"><a href="#制作文件间的链接" class="headerlink" title="制作文件间的链接"></a>制作文件间的链接</h2><h3 id="管理文件间的链接"><a href="#管理文件间的链接" class="headerlink" title="管理文件间的链接"></a>管理文件间的链接</h3><p>​	您可以创建指向同一文件的多个文件名。这些文件名称为链接。</p>
<p>​	您可以创建的两种类型的链接：硬链接或符号链接（同时也称为软链接）。每种方法各有利弊。</p>
<h3 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h3><p>​	从初始名称到文件系统上的数据，每个文件都以一个硬链接开始。当创建指向文件的硬链接时，也会创建另一个指向同一数据的名称。新的硬链接与原始文件名的作用完全相同。创建之后，新的硬链接与文件的原始名称毫无二致。</p>
<p>​	您可以使用ls -l命令来确认文件是否具有多个硬链接。他报告的项目之一就是每个文件的链接数，即文件所具有的硬链接数。再下面的示例中，newfile.txt的链接数位1。它恰好有一个绝对路径，即&#x2F;home&#x2F;kiosk&#x2F;newfile.txt。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l newfile.txt </span><br><span class="line">-rw-rw-r--. 1 kiosk kiosk 6 Mar  5 16:47 newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	您可以使用ln命令来创建一个指向现有文件的硬链接（也就是指向该文件的另一个名称）。该命令至少需要两个参数：现有文件的路径，以及要创建的硬链接的路径。</p>
<p>​	以下示例将为现有文件newfile.txt，在&#x2F;tmp目录中创建一个名为newfile-hlink2.txt的硬链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> newfile.txt </span><br><span class="line">hahah</span><br><span class="line"><span class="comment"># 创建硬链接</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> newfile.txt /tmp/newfile-hlink2.txt</span><br><span class="line"><span class="comment"># 硬链接已生成</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l /tmp/newfile-hlink2.txt</span><br><span class="line">-rw-rw-r--. 2 kiosk kiosk 6 Mar  5 16:47 /tmp/newfile-hlink2.txt</span><br><span class="line"><span class="comment"># 硬链接与原始文件具有相同的数据</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">hahah</span><br><span class="line"><span class="comment"># 修改原始文件内容的同时，硬链接的内容也同时随原文件更新</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> xixixi &gt; newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">xixixi</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	要确定两个文件是否被硬链接，请使用ls命令配合-i 选项列出每个文件索引节点编码。如果两个文件位于同一文件系统上，而且他们的索引节点编号相同，那么这两个文件就是指向同一数据的硬链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -li newfile.txt /tmp/newfile-hlink2.txt</span><br><span class="line">269337410 -rw-rw-r--. 2 kiosk kiosk 7 Mar  5 16:55 newfile.txt</span><br><span class="line">269337410 -rw-rw-r--. 2 kiosk kiosk 7 Mar  5 16:55 /tmp/newfile-hlink2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>重要：引用同一文件的硬链接具有相同的链接数、访问权限、用户和组所有权、时间戳，以及文件内容。当一个硬链接的内容发生更改，同一文件的其他硬链接也会显示更新后的新内容。这是因为每个硬链接都指向存储设备中的同一数据</code></p>
<p>​	即使原始文件被删除，只要还存在至少一个硬链接，该文件的内容就依然可用。只有最后一个硬链接被删除时，数据才会从存储中删除，从而使任何硬链接都不会引用该文件内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -rf newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -li /tmp/newfile-hlink2.txt </span><br><span class="line">269337410 -rw-rw-r--. 1 kiosk kiosk 7 Mar  5 16:55 /tmp/newfile-hlink2.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-hlink2.txt</span><br><span class="line">xixixi</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h3 id="硬链接的局限性"><a href="#硬链接的局限性" class="headerlink" title="硬链接的局限性"></a>硬链接的局限性</h3><p>​	硬链接存在一些局限性。首先，您只能将硬链接用于常规文件。无法使用ln命令来创建指向目录或特殊文件的硬链接。</p>
<p>​	其次，只有当两个文件位于同一文件系统上时，您才能使用硬链接。文件系统层次结构可以由多个存储设备组成。当切换到新目录时，该目录及其内容可能会存储在不同的文件系统中，具体取决于您的系统配置。</p>
<p>​	您可用使用df命令来列出位于不同文件系统上的目录。例如，您可能会看到以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">df</span> </span><br><span class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">devtmpfs         8155384        0   8155384   0% /dev</span><br><span class="line">tmpfs            8175032        0   8175032   0% /dev/shm</span><br><span class="line">tmpfs            3270016    10264   3259752   1% /run</span><br><span class="line">/dev/nvme0n1p3 191037300 70391952 120645348  37% /</span><br><span class="line">/dev/loop2       7866562  7866562         0 100% /content/rhel9.0/x86_64/rhel8-additional</span><br><span class="line">/dev/loop1           456      456         0 100% /content/rhel9.0/x86_64/rhcsa-practice</span><br><span class="line">/dev/nvme0n1p1   2086912   971540   1115372  47% /boot</span><br><span class="line">/dev/loop0       8377364  8377364         0 100% /content/rhel9.0/x86_64/dvd</span><br><span class="line">tmpfs            1635004      104   1634900   1% /run/user/1000</span><br></pre></td></tr></table></figure>

<p>​	两个不同的目录及其子目录中的文件位于不同的文件系统上。因此，本示例中的系统而言，您可以在<code>/tmp/newfile-hlink2.txt</code>和<code>/home/kiosk/newfile.txt</code> 文件之间创建一个硬链接，因为它们都说 &#x2F; 目录的子目录，而不是列表中其他任何目录的子目录。但是您不能在<code>/boot</code>和<code>/home/kiosk/newfile.txt</code> 之间建立硬链接，因为第一个文件位于&#x2F;boot目录下的子目录并且在<code>/dev/nvme0n1p1</code>文件系统中，而第二个文件在<code>/dev/nvme0n1p3</code>文件系统中</p>
<h3 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><p>​	ln 命令 -s 选项可创建符号链接，也称为“软链接”。符号链接不是常规文件，而是指向现有文件或目录的特殊类型的文件。</p>
<p>​	符号链接相比硬链接有着一定的优势：</p>
<ul>
<li>符号链接可以链接位于不同文件系统上的两个文件。</li>
<li>符号链接可以指向目录或特殊文件，而不仅限于常规文件。</li>
</ul>
<p>​	在以下示例中，ln -s命令为&#x2F;home&#x2F;kiosk&#x2F;newfile.txt文件创建符号链接。符号链接在名称是&#x2F;tmp&#x2F;newfile-symlink.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> -s /home/kiosk/newfile.txt /tmp/newfile-symlink.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l newfile.txt /tmp/newfile-symlink.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk  6 Mar  5 17:46 newfile.txt</span><br><span class="line">lrwxrwxrwx. 1 kiosk kiosk 23 Mar  5 17:48 /tmp/newfile-symlink.txt -&gt; /home/kiosk/newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-symlink.txt</span><br><span class="line">hahah</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	在上面示例中，&#x2F;tmp&#x2F;newfile-symlink.txt文件的长列表的第一个字符是l（字母 l）而不是 - 。这个字符表示该文件是符号链接而非常规文件。</p>
<p>​	当原始常规文件被删除后，符号链接会指向原始文件，但目标已消失。指向缺少文件的符号链接称为“悬空符号链接”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> -f newfile.txt </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l /tmp/newfile-symlink.txt </span><br><span class="line">lrwxrwxrwx. 1 kiosk kiosk 23 Mar  5 17:48 /tmp/newfile-symlink.txt -&gt; /home/kiosk/newfile.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/newfile-symlink.txt</span><br><span class="line"><span class="built_in">cat</span>: /tmp/newfile-symlink.txt: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	<code>重要：在上述示例中，悬空符号链接有个副作用，那就是：如果您稍后创建了一个与删除文件同名的新文件（/home/kiosk/newfile.txt），那么符号链接将不再“悬空”，而是指向这个新文件，硬链接的工作方式却不是这样的。如果您删除硬链接，然后使用常规工具（而不是ln）创建一个同名的文件，那么新文件将不会链接到旧文件，不妨通过以下方式比较硬链接和符号链接，以了解它们的工作原理：</code></p>
<ul>
<li><code>硬链接是将名称指向存储设备上的数据。</code></li>
<li><code>符号链接是将名称指向另一个名称，原文件指向存储设备上的数据。</code></li>
</ul>
<p>​	符合链接可以指向目录，而且，符号链接发挥目录一样的作用。如果使用cd进入到符合链接的目录，则当前工作目录将变为被链接的目录。有些工具可以跟踪您如何通过软链接到达这个目录的。例如，默认情况下，cd将使用符号链接的名称（而非实际的名称）来更新当前工作目录。如果要使用实际目录的名称更新当前工作目录，则可以使用 -P 选项。</p>
<p>​	以下示例将创建&#x2F;home&#x2F;kiosk&#x2F;configfiles的不好链接，它将指向&#x2F;etc目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ln</span> -s /etc/ /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cd</span> /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 configfiles]$ <span class="built_in">pwd</span></span><br><span class="line">/home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 configfiles]$ <span class="built_in">cd</span> -P /home/kiosk/configfiles</span><br><span class="line">[kiosk@foundation0 etc]$ <span class="built_in">pwd</span></span><br><span class="line">/etc</span><br><span class="line">[kiosk@foundation0 etc]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用shell扩展匹配文件名"><a href="#使用shell扩展匹配文件名" class="headerlink" title="使用shell扩展匹配文件名"></a>使用shell扩展匹配文件名</h2><h3 id="命令行扩展"><a href="#命令行扩展" class="headerlink" title="命令行扩展"></a>命令行扩展</h3><p>​	当您在Bash shell提示符中键入命令时，shell在运行该命令行之前通过多个扩展对其进行处理。您可以使用这些shell扩展来执行原本很难或不可能完成的复杂任务。</p>
<p>​	Bash执行的主要扩展有：</p>
<ul>
<li>大括号扩展，可以生成多个字符串。</li>
<li>波浪号扩展，扩展至用户主目录路径。</li>
<li>变量扩展，将文本替换为shell变量中存储的值。</li>
<li>命令替换，加ing文本替换为命令的输出。</li>
<li>路径名扩展，帮助按模式匹配选择一个或多个文件。</li>
</ul>
<p>​	路径名扩展也称为通配符，是Bash最有用的功能之一。使用此功能，可以更加轻松地管理多个文件。使用“扩展”的元字符来匹配要寻找的文件名和路径名，可以一次性针对集中的一组文件执行命令。</p>
<h3 id="路径名扩展和模式匹配"><a href="#路径名扩展和模式匹配" class="headerlink" title="路径名扩展和模式匹配"></a>路径名扩展和模式匹配</h3><p>​	路径名扩展将表示为通配符或字符类别的特殊字符模式扩展为该模式匹配的文件名列表。在shell运行您的命令之前，它会将模式替换为匹配的文件名列表。如果该模式与任何内容都不匹配，则shell将尝试使用该模式作为其运行命令的字面参数。下表列出了用于模式匹配的常见元字符和模式类型。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>由零个或跟多字符组成的任意字符串。</td>
</tr>
<tr>
<td>?</td>
<td>任何一个字符。</td>
</tr>
<tr>
<td>[abc…]</td>
<td>括起的类型（位于两个方括号之间）中的任何一个字符。</td>
</tr>
<tr>
<td>[!abc…]</td>
<td>不在括起的类型中的任意字符。</td>
</tr>
<tr>
<td>[^abc…]</td>
<td>不在括起的类型中的任意字符。</td>
</tr>
<tr>
<td>[[:alpha:]]</td>
<td>任何字母字符</td>
</tr>
<tr>
<td>[[:lower:]]</td>
<td>任何小写字符</td>
</tr>
<tr>
<td>[[:upper:]]</td>
<td>任何大写字符</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>任何字母字符或数字</td>
</tr>
<tr>
<td>[[:punct:]]</td>
<td>除空格和字母数字意外的任何可打印字符。</td>
</tr>
<tr>
<td>[[:digit:]]</td>
<td>从0到9的任何单个数字。</td>
</tr>
<tr>
<td>[[:space:]]</td>
<td>任何单个空格字符，可能包括制表符、换行符、回车符、换页符或空格。</td>
</tr>
</tbody></table>
<p>​	便于演示，以下命令创建一些示例文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 Videos]$ <span class="built_in">mkdir</span> glob; <span class="built_in">cd</span> glob</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> alpha bravo charlie dalta <span class="built_in">echo</span> able baker cast dog easy Able Aplha Cast 123</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">able  alpha  baker  bravo  cast  charlie  dalta  dog  easy  <span class="built_in">echo</span></span><br><span class="line">[kiosk@foundation0 glob]$</span><br></pre></td></tr></table></figure>

<p>​	以下示例中，前面两个命令通过星号（*）使用简单模式匹配，分别匹配以“a”开头的所有文件名和包含“a”的所有文件名。第三个命令使用星号和方括号匹配以“a”或“c”开头的所有文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> a*</span><br><span class="line">able  alpha</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> *a*</span><br><span class="line">able  alpha  baker  bravo  cast  charlie  dalta  easy</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> [ac]*</span><br><span class="line">able  alpha  cast  charlie</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	第一、二个命令，开头不包括“a”或“c”的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ ls [!ac]*</span><br><span class="line">baker  bravo  dalta  dog  easy  echo</span><br><span class="line">[kiosk@foundation0 glob]$ ls [^ac]*</span><br><span class="line">baker  bravo  dalta  dog  easy  echo</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	过滤出文件内任何字母字符的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">cat</span> able </span><br><span class="line">daf</span><br><span class="line">fasfa</span><br><span class="line">154512</span><br><span class="line"></span><br><span class="line">fadfa</span><br><span class="line"></span><br><span class="line">fa</span><br><span class="line">dggf</span><br><span class="line">gf</span><br><span class="line">fgd</span><br><span class="line">eq</span><br><span class="line">bnv</span><br><span class="line"></span><br><span class="line">cz</span><br><span class="line">rew</span><br><span class="line">vbc`:</span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 glob]$ grep [[:alpha:]] able </span><br><span class="line">daf</span><br><span class="line">fasfa</span><br><span class="line">fadfa</span><br><span class="line">fa</span><br><span class="line">dggf</span><br><span class="line">gf</span><br><span class="line">fgd</span><br><span class="line">eq</span><br><span class="line">bnv</span><br><span class="line">cz</span><br><span class="line">rew</span><br><span class="line">vbc`:</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	以下示例中也可以使用问号 “？”来匹配其中的一些文件名，这两个命令分别仅匹配长度为四个和五个字符的文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> ????</span><br><span class="line">able  cast  easy  <span class="built_in">echo</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> ?????</span><br><span class="line">alpha  baker  bravo  dalta</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h3><p>​	大括号扩展用于生成任意字符串。大括号包含字符串的都好分割列表或顺序表达式。结果包含大括号定义之前或之后的文本。大括号扩展可以相互嵌套。您也可以使用双点语法（..），它将扩展为一个顺序序列。例如，大括号内的{a..d}双点语法扩展为 b c d。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> &#123;tmp,nginx,docker,kubelet&#125;.<span class="built_in">log</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">docker.log  kubelet.log  nginx.log  tmp.log</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> file&#123;a..c&#125;.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span> file*</span><br><span class="line">filea.txt  fileb.txt  filec.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">touch</span> file&#123;a..c&#125;&#123;1..3&#125;.txt</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">ls</span></span><br><span class="line">filea1.txt  filea2.txt  filea3.txt  fileb1.txt  fileb2.txt  fileb3.txt  filec1.txt  filec2.txt  filec3.txt</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	可以通过大括号扩展的方式去快速创建多个文件或目录及查找等操作。</p>
<h3 id="波形符扩展"><a href="#波形符扩展" class="headerlink" title="波形符扩展"></a>波形符扩展</h3><p>​	波形符（<del>）可匹配当前用户的主目录。如果波形符后为斜杠（&#x2F;）以外的字符串，shell就会将波形符之后的字符串解释为用户名。如果存在匹配项，则用该用户的主目录绝对路径来替换字符串。如果找不到匹配的用户名，shell将使用实际波形符加上该字符串完整输出。如果您以（</del>&#x2F;）开头，shell就会将该解释为当前用户的主目录，在它之后的字符串就是当前用户主目录下的子目录。</p>
<p>​	一下示例中，echo命令用于显示波形字符最终输出的值。也可以使用echo命令来显示大括号和变量扩展字符等的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root的主目录绝对路径</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~root</span><br><span class="line">/root</span><br><span class="line"><span class="comment"># kiosk的主目录绝对路径</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~kiosk/</span><br><span class="line">/home/kiosk/</span><br><span class="line"><span class="comment"># ~/当前用户主目录，glob主目录下的子目录</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~/glob</span><br><span class="line">/home/kiosk/glob</span><br><span class="line"><span class="comment"># 匹配不到则将参数完整输出</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> ~ahahha</span><br><span class="line">~ahahha</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h3><p>​	变量的作用类似于可以在内存中存储值的命名容器。通过变量，可以从命令行或shell脚本内轻松访问和修改存储的数据。</p>
<p>​	您可以通过以下语法蒋数据作为值分配给变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ VARIABLENAME=value</span><br></pre></td></tr></table></figure>

<p>​	可以使用变量扩展蒋变量名转换为命令行上的值。如果字符串以美元符号（$）开头，那么shell就会尝试将该字符串的其余部分用作变量名称，并将它替换为变量中包含的任何值。也就是说美元符可以将它后面的字符串解释（标记）为这是一个变量，而非普通的字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个名为：USERNAME的变量，它的值为：Asimov</span></span><br><span class="line"><span class="comment"># 他们是一个键值对的关系</span></span><br><span class="line">[kiosk@foundation0 glob]$ USERNAME=Asimov</span><br><span class="line"><span class="comment"># $打入开头关键字同样也可以TAB为您补全上来</span></span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="variable">$USER</span>      <span class="variable">$USERNAME</span>  </span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$USERNAME</span></span><br><span class="line">Asimov</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<p>​	为了预防您取的变量名于其他shell扩展名其冲突而引起错误，您可以将变量的名称放在大括号中，如：${VARIABLENAME}</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ USERNAME=LiWeiHu</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$&#123;USER&#125;</span></span><br><span class="line"><span class="variable">$&#123;USER&#125;</span>      <span class="variable">$&#123;USERNAME&#125;</span>  </span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> <span class="variable">$&#123;USERNAME&#125;</span></span><br><span class="line">LiWeiHu</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>

<p>​	变量名只能包含字母（大小写均可）、数字和下划线。变量名称区分大小写，不能以数字开头。</p>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>​	命令替换允许命令的输出替换命令行上的命令本身。当命令阔在括号中并且前面有美元符号（$）时，会发生命令替换。$(command) 形式可以互相嵌套多个命令扩展。</p>
<p>​	将date +%A这个原本的命令，用它输出的值去替换这个命令，去输出今天是星期几，于我们没带命令替换的普通字符串，形成一段完整的输出内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> Today is $(<span class="built_in">date</span> +%A)</span><br><span class="line">Today is Thursday</span><br><span class="line">[kiosk@foundation0 glob]$ <span class="built_in">echo</span> Today <span class="keyword">time</span> is  $(<span class="built_in">date</span> +%M) minutes past $(<span class="built_in">date</span> +%l%p).</span><br><span class="line">Today <span class="keyword">time</span> is 18 minutes past 4PM.</span><br><span class="line">[kiosk@foundation0 glob]$ </span><br></pre></td></tr></table></figure>



<h3 id="防止参数被扩展"><a href="#防止参数被扩展" class="headerlink" title="防止参数被扩展"></a>防止参数被扩展</h3><p>​	在Bash shell中，许多字符有着特殊含义。为防止命令行的某些部分上执行shell扩展，您可以为字符和字符串加引号或执行转义。</p>
<p>​	反斜杠（\）是bash shell中的转义字符。它可以防止其后的字符被扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未被转义时，$HOME将作为变量去输出key值</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/kiosk</span><br><span class="line"><span class="comment"># 通过转义符，$HOME它就是一个普通的字符串输出</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> \<span class="variable">$HOME</span></span><br><span class="line"><span class="variable">$HOME</span></span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	在上面的示例中，保护美元符免于扩展，bash将其视为常规字符，因此也就未在$HOME上执行变量扩展。</p>
<p>​	如果要保护较长的字符串，则使用单引号 （’）或双引号（”）来括起字符串。它们的作用略有不同。单引号将阻止所有shell扩展。双引号则阻止大部分shell扩展。</p>
<p>​	双引号可抑制美元符号（ $ ）、反斜杠（ \ ）、反引号（ &#96; ）和感叹号（ ! ）以外的特殊字符，在引用文本内发挥作用。这回阻止路径名扩展，但仍允许命令替换和变量扩展。</p>
<p>​	以下示例中，演示了双引号无法抑制变量扩展，依然会输出变量具有的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&quot;****** hostname is <span class="variable">$&#123;HOSTNAME&#125;</span> ********&quot;</span></span><br><span class="line">****** hostname is foundation0.ilt.example.com ********</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	使用单引号则可以按字面解释抑制引号内所有的特殊字符，以文本输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line">foundation0.ilt.example.com</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&#x27;****** hostname is $&#123;HOSTNAME&#125; ********&#x27;</span></span><br><span class="line">****** hostname is <span class="variable">$&#123;HOSTNAME&#125;</span> ********</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第四章节</title>
    <url>/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="创建、查看和编辑文本文件"><a href="#创建、查看和编辑文本文件" class="headerlink" title="创建、查看和编辑文本文件"></a>创建、查看和编辑文本文件</h1><h2 id="将输出重定向到文件或程序"><a href="#将输出重定向到文件或程序" class="headerlink" title="将输出重定向到文件或程序"></a>将输出重定向到文件或程序</h2><p>标准输入、标准输出和标准错误</p>
<p>​	运行中的程序或进程会读取输入并写入输出。从shell提示符运行命令时，通常会从键盘读取其输入，并将输出发送到终端窗口。</p>
<p>​	进程使用称为文件描述符的编号通道来获取输入并发送输出。所有进程在开始时至少要有三个文件描述符。标准输入（通道0）从键盘读取输入。标准输出（通道1）将正常输出发送到终端。标准错误（通道2）将错误消息发送到终端。</p>
<p>​	如果程序打开连接至其他文件的单独连接，则可能要使用更大编号的文件描述符。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310171941393.png" alt="image-20250310171941393"></p>
<blockquote>
<p>​													进程I&#x2F;O通道（文件描述符）</p>
</blockquote>
<p>​	下表总结了有关文件夫描述符的信息：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>通道名称</th>
<th>描述</th>
<th>默认连接</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>stdin</td>
<td>标准输入</td>
<td>键盘</td>
<td>仅读取</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>标准输出</td>
<td>终端</td>
<td>仅写入</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>标准错误</td>
<td>终端</td>
<td>仅写入</td>
</tr>
<tr>
<td>3</td>
<td>filename</td>
<td>其他文件</td>
<td>无</td>
<td>读取或写入</td>
</tr>
</tbody></table>
<h2 id="将输出重定向到文件"><a href="#将输出重定向到文件" class="headerlink" title="将输出重定向到文件"></a>将输出重定向到文件</h2><p>​	输入&#x2F;输出（I&#x2F;O）重定向可给更改进程获取其输入或输出的方式。进程可以执行文件读取或写入，而不从键盘获取输入，也不将输出和错误发送到终端。通过重定向，您可以将消息保存到文件，而不在终端上显示输出。或者，您也可以使用重定向丢弃输出或错误输出，这样它们就不会显示在终端上或保存下来。</p>
<p>​	您可以重定向进程stdout以阻止进程输出显示在终端上。如果您将stdout重定向到某个文件，单该文件不存在，则会为您创建该文件。如果文件确实存在，但是您选择的重定向不是附加到文件，则重定向会覆盖文件原有内容。要丢弃进程的输出，您可以重定向到空的&#x2F;dev&#x2F;null特殊文件，该文件会静默丢弃重定向到该进程的通道输出。</p>
<p>​	如下表，仅对stdout重定向不会阻止stderr错误消息显示在终端上。</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>视觉辅助</th>
</tr>
</thead>
<tbody><tr>
<td>&gt; file</td>
<td>重定向stdout以覆盖文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180118758.png" alt="image-20250310180118758"></td>
</tr>
<tr>
<td>&gt;&gt; file</td>
<td>重定向stdout以追加到文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180306263.png" alt="image-20250310180306263"></td>
</tr>
<tr>
<td>2&gt; file</td>
<td>重定向stderr以覆盖文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180426539.png" alt="image-20250310180426539"></td>
</tr>
<tr>
<td>2&gt; &#x2F;dev&#x2F;null</td>
<td>重定向stderr错误消息到&#x2F;dev&#x2F;null，从而丢弃它</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180600483.png" alt="image-20250310180600483"></td>
</tr>
<tr>
<td>&gt; file 2&gt;&amp;1 和 &amp;&gt; file</td>
<td>重定向stdout和stderr以覆盖同一文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180738265.png" alt="image-20250310180738265"></td>
</tr>
<tr>
<td>&gt;&gt; file 2&gt;&amp;1 和 &amp;&gt;&gt; file</td>
<td>重定向stdout和stderr以追加到同一文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310180849243.png" alt="image-20250310180849243"></td>
</tr>
<tr>
<td>&gt; file 2&gt; file</td>
<td>分别将stdout和stderr以覆盖到不同的文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310181244864.png" alt="image-20250310181244864"></td>
</tr>
<tr>
<td>&gt;&gt; file 2&gt;&gt; file</td>
<td>分别将stdout和stderr以追加到不同的文件</td>
<td><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250310181402294.png" alt="image-20250310181402294"></td>
</tr>
</tbody></table>
<h2 id="输出重定向示例"><a href="#输出重定向示例" class="headerlink" title="输出重定向示例"></a>输出重定向示例</h2><p>​	通过重定向来简化许多日常管理任务。在是思考下列示例时，请参考前面表格。</p>
<p>​	在&#x2F;tmp&#x2F;saved-timestamp文件中保存时间戳以供日后参考。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">date</span> &gt; /tmp/saved-timestamp</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/saved-timestamp</span><br><span class="line">Tue Mar 18 04:54:43 PM CST 2025</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将&#x2F;var&#x2F;log&#x2F;secure文件的最后100行复制到&#x2F;tmp&#x2F;last-100-secure文件，这里需要使用root账户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> -n 100 /var/log/secure &gt; /tmp/last-100-secure</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>

<p>​	将所有四个step文件内容连接为一个，并保存到&#x2F;tmp&#x2F;all-four-steps-in-one文件中，没有该step文件可自行创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> step1.txt step2.txt step3.txt step4.txt </span><br><span class="line">step1</span><br><span class="line">step2</span><br><span class="line">step3</span><br><span class="line">step4</span><br><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> step1.txt step2.txt step3.txt step4.txt &gt; /tmp/all-four-steps-in-one</span><br><span class="line">[root@foundation0 step]# <span class="built_in">cat</span> /tmp/all-four-steps-in-one</span><br><span class="line">step1</span><br><span class="line">step2</span><br><span class="line">step3</span><br><span class="line">step4</span><br><span class="line">[root@foundation0 step]#</span><br></pre></td></tr></table></figure>

<p>​	列出主目录的隐藏文件名和常规文件名，并输出保存到my-file-names文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -a &gt; my-file-names</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> my-file-names </span><br><span class="line">.....忽略.....</span><br><span class="line">ClassroomSetup-RHCSA-9.0-1.r2022052407gitdd6fbd2.txt</span><br><span class="line">ClassroomSetup-RHCSA-9.0-1.r2022092007git75b8165.txt</span><br><span class="line">ClassroomTroubleshooting-9.x-7.r2022112118git21c9ff2.txt</span><br><span class="line">.cshrc</span><br><span class="line">.dbus</span><br><span class="line">foundation0-config-9.x-7.r2022112118git21c9ff2.noarch.rpm</span><br><span class="line">foundation0-config-post.log</span><br><span class="line">.....忽略.....</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	在现有的&#x2F;tmp&#x2F;many-lines-of-information文件中附加一行内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /tmp/many-lines-of-information</span><br><span class="line">hahaha</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">echo</span> <span class="string">&quot;new line of information&quot;</span> &gt; /tmp/many-lines-of-information</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /tmp/many-lines-of-information</span><br><span class="line">new line of information</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	接下来几个命令会产生错误消息，因为普通用户无法访问某些系统目录。观察错误消息的重定向。</p>
<p>​	在终端上查看普通命令输出时，将find命令的错误重定向到&#x2F;tmp&#x2F;errors文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd 2&gt; /tmp/errors</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors</span><br><span class="line">...忽略...</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	将进程输出保存到&#x2F;tmp&#x2F;output文件，并将错误消息保存到&#x2F;tmp&#x2F;errorss文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/output 2&gt; /tmp/errors</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/output </span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors </span><br><span class="line">...忽略...</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	将进程输出保存到&#x2F;tmp&#x2F;output文件，并丢弃错误消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/output 2&gt; /dev/null </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/output </span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/errors</span><br><span class="line"><span class="built_in">cat</span>: /tmp/errors: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将输出和生成的错误消息一起存储到&#x2F;tmp&#x2F;all-message-output文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt; /tmp/all-message-output 2&gt;&amp;1</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/all-message-output </span><br><span class="line">find: ‘/etc/pki/rsyslog’: Permission denied</span><br><span class="line">find: ‘/etc/dhcp’: Permission denied</span><br><span class="line">find: ‘/etc/ssh/sshd_config.d’: Permission denied</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">find: ‘/etc/lvm/archive’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/devices’: Permission denied</span><br><span class="line">/etc/passwd</span><br><span class="line">find: ‘/etc/grub.d’: Permission denied</span><br><span class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</span><br><span class="line">...忽略...</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将输出和生成的错误附加到&#x2F;tmp&#x2F;all-message-output文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc -name passwd &gt;&gt; /tmp/all-message-output 2&gt;&amp;1</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="构建管道"><a href="#构建管道" class="headerlink" title="构建管道"></a>构建管道</h2><p>​	管道是一个或多个命令的序列，永竖线字符（|）分割。管道将第一个命令的标准输出连接到下一个命令的标准输入。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250318180725621.png" alt="image-20250318180725621"></p>
<p>​	在某个进程输出到终端之前，使用管道来操作另一个进程并格式化进程的输出。可以想象一下，数据正在通过一个管道从一个进程“流”向另一个进程，并且在其流过的管道中每个命令都会对其做出些改动。</p>
<p>​	<code>注意：管道和I/O重定向都可以操作标准输出和输入。重定向会向文件发送标准输出或从文件获取标准输入。管道会将一个进程的标准输出发送到另一个进程的标准输入。</code></p>
<h2 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h2><p>​	以下列表显示了一些管道示例：</p>
<p>​	将ls命令的输出重定向到less命令，以在终端上以一次一屏的方式显示输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> /usr/bin/ | less</span><br></pre></td></tr></table></figure>

<p>​	将ls命令的输出重定向到wc -l命令，以统计ls收到的行数并将这个值显示在终端上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> | <span class="built_in">wc</span> -l</span><br><span class="line">23</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将ls -t命令的输出重定向到head命令，以显示前十行，并将最终结果重定向到&#x2F;tmp&#x2F;first-ten-changed-files文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 &gt; /tmp/first-ten-changed-files</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/first-ten-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="管道、重定向和附加到文件"><a href="#管道、重定向和附加到文件" class="headerlink" title="管道、重定向和附加到文件"></a>管道、重定向和附加到文件</h2><p>​	如果将重定向与管道组合，shell会首先设置整个管道，然后重定向输入&#x2F;输出。如果在管道的中间使用重定向，则输出将转至文件，而不会前往管道中的下一个命令。</p>
<p>​	在以下示例中，ls命令的输出将转至&#x2F;tmp&#x2F;saved-output文件，并且less命令不在终端上显示任何内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> &gt; /tmp/saved-output | less</span><br></pre></td></tr></table></figure>

<p>​	tee命令克服了这个限制。在管道中，tee将其标准输入复制到其标准输出中，并且还将标准输出重定向到指定的命令参数的文件。如果您将数据想象成流经管道的水，那么可将tee视觉化为管道中的T形接头，它负责输出在两个方向上的流向，所以该命令也称为“三通”。</p>
<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250318180625486.png" alt="image-20250318180625486"></p>
<h2 id="使用tee命令的管道示例"><a href="#使用tee命令的管道示例" class="headerlink" title="使用tee命令的管道示例"></a>使用tee命令的管道示例</h2><p>​	以下示例将ls命令的输出重定向到&#x2F;tmp&#x2F;saved-output文件，并且将它传递到less命令，以便在终端上一次一屏的方式显示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> | <span class="built_in">tee</span> /tmp/saved-output | less</span><br></pre></td></tr></table></figure>

<p>​	如果在管道末尾使用tee命令，则终端将显示管道中的命令输出，同时将其保存到文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 | <span class="built_in">tee</span> /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br></pre></td></tr></table></figure>

<p>​	使用tee命令配合-a选项将内容追加到文件，并非是覆盖它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -t | <span class="built_in">head</span> -n 10 | <span class="built_in">tee</span> -a /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">test1.txt</span><br><span class="line">Videos</span><br><span class="line">configfiles</span><br><span class="line">Documents</span><br><span class="line">Downloads</span><br><span class="line">Music</span><br><span class="line">Pictures</span><br><span class="line">Public</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /tmp/ten-last-changed-files</span><br><span class="line">ssh.sh</span><br><span class="line">...忽略...</span><br><span class="line">Templates</span><br><span class="line">ssh.sh</span><br><span class="line">...忽略...</span><br><span class="line">Templates</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	注意：您可以使用管道来重定向比标准错误，但不能使用合并重定向操作符（&amp;&gt;和&amp;&gt;&gt;）执行此操作。以下示例是通过管道重定向标准输出和标准错误的正确方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ find /etc/ -name passwd 2&gt;&amp;1 | less</span><br></pre></td></tr></table></figure>



<h1 id="从shell提示符编辑文本文件"><a href="#从shell提示符编辑文本文件" class="headerlink" title="从shell提示符编辑文本文件"></a>从shell提示符编辑文本文件</h1><h2 id="使用vim编辑文件"><a href="#使用vim编辑文件" class="headerlink" title="使用vim编辑文件"></a>使用vim编辑文件</h2><p>​	Linux的基本设计原则是支持将信息和配置设置存储再基于文件的文件中。这些文件可以采用各种结构，如设置列表、INI格式、结构化XML或YAML等等。以基于文本的结构存储文件的优点是可以使用任何简单的文本编辑器轻松的完成编辑。</p>
<h2 id="VIM编辑器的优势"><a href="#VIM编辑器的优势" class="headerlink" title="VIM编辑器的优势"></a>VIM编辑器的优势</h2><p>​	当系统使用纯文本shell提示符时，您应该知道如何至少一个文本编辑器来编辑文本。然后您可以从终端窗口，或是通过ssh或web控制台远程登录的方式来编辑基于文本的配置文件。您不需要访问图形桌面，就能编辑服务器上的文件，而且该服务器可能根本不需要运行图形桌面环境。</p>
<p>​	学习vim的关键在于，它几乎总是默认安装再服务器上，用于编辑基于文本的文件。可移植操作系统接口或POSIX标准制定了Linux上vi编辑器，许多其他类UNIX操作系统大致如此。</p>
<p>​	vim还经常被用作vi在其他标准操作系统或发行版上实现。例如，macOS目前默认是Vim的轻量级安装。因此，面向Linux学习vim技能也可能在别处有用。</p>
<h2 id="VIM入门"><a href="#VIM入门" class="headerlink" title="VIM入门"></a>VIM入门</h2><p>​	您可以使用如下两个软件包中的任何一个，在红帽Linux中安装vim编辑器。两个软件包为编辑基于文本的文件提供了不通的功能和vim命令。</p>
<p>​	通过vim-minimal软件包，您可以安装具有核心功能的vi编辑器。这是一个轻量级安装，仅包含核心功能和基本vi命令。您可以使用vi命令打开文本进行编辑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ vi filename</span><br></pre></td></tr></table></figure>

<p>​	或者您可以使用vim-enhanced软件包安装vim编辑器。此软件包提供一套更完整的功能、一个在线帮助系统和一个教程系统。使用vim命令，在这种增强模式下启动vim编辑文本文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ vim filename</span><br></pre></td></tr></table></figure>

<p>​	如果安装了vim-enhanced，则会设置一个shell别名，普通用户可设置一个shell别名，以便在运行vi命令时自动获取vim命令。此别名不适合于root用户及其UID小于200的用户（这些用户供系统服务使用）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ alias vi=&quot;vim&quot;</span><br><span class="line">[kiosk@foundation0 ~]$ alias </span><br><span class="line">...忽略...</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">...忽略...</span><br></pre></td></tr></table></figure>

<p>​	如果安装了vim-enhanced，并且普通用户想要使用vi命令，则它们可能必须使用\vi命令来临时覆盖别名。您可以使用\vi –version和vim –version来比较两个命令的功能集。</p>
<h2 id="VIM操作模式"><a href="#VIM操作模式" class="headerlink" title="VIM操作模式"></a>VIM操作模式</h2><p>​	vim编辑器提供各种操作模式，如命令模式、扩展命令模式、编辑模式和可视模式。作为vim用户，您要始终了解当前的模式，因为击键在不同模式下具有不通的效果。</p>
<p>​	<img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250319110333114.png" alt="image-20250319110333114"></p>
<p>​	第一次打开vim时，它会以命令模式启动，可用于导航、剪切和粘贴，以及其他文本修改。按所需的案件可访问特定的编辑模式。</p>
<ul>
<li><p>按i建进入插入模式，之后键入的所有文本将变为文件内容。按Esc键返回到命令模式。</p>
</li>
<li><p>按v键进入可视模式，可在其中选择多个字符进行文本操作。使用shift+V选择多行，使用 Ctrl+V可选择文本块。要退出可视模式，请按v、sheift+V或ctrl+V键。</p>
</li>
<li><p>按：键启动扩展命令模式，可执行的任务包含写入文件（保存文件），以及退出vim编辑器等。</p>
<p><code>注意：如果您不确定所使用的模式，可以按几次Esc来返回到命令模式。在命令模式重复按Esc键是安全的。</code></p>
</li>
</ul>
<h2 id="最低程度的基于vim工作流"><a href="#最低程度的基于vim工作流" class="headerlink" title="最低程度的基于vim工作流"></a>最低程度的基于vim工作流</h2><p>​	vim具有高效的组合击键操作，可进行高级编辑任务。虽说熟能生巧，但vim功能可能会难道新用户。</p>
<p>​	工贸建议学习一下vim键和命令。</p>
<ul>
<li>u键可撤销最近的编辑内容。</li>
<li>x键可删除单子字符。</li>
<li>:w 命令可写入（保存）文件，并停留在命令模式中以进行之后更多的编辑任务。</li>
<li>:wq 命令可写入（保存）文件并退出vim编辑页。</li>
<li>:q! 命令可退出vim，同时放弃一次写入以来进行的所有更改。</li>
</ul>
<p>​	学习这些命令有助于vim用户完成任何编辑任务</p>
<h2 id="重排现有文本"><a href="#重排现有文本" class="headerlink" title="重排现有文本"></a>重排现有文本</h2><p>​	在vim中，您可以通过使用y和p命令字符来执行拖拉和放置（复制和粘贴）。将光标定位到要选择的第一个字符，然后进去可视模式（按住v）。使用键盘左右箭头选择要操作的字符。选中所要操作的字符后，按y将所选内容拖拉（复制）到内存中。将光标定位到新位置，然后按p将所选内容放置（粘贴）到光标处。</p>
<h2 id="vim中的可视模式"><a href="#vim中的可视模式" class="headerlink" title="vim中的可视模式"></a>vim中的可视模式</h2><p>​	可视化模式可用于突出显示和操作不同行和列中的文本。您可以使用以下组合键在vim中进入可视模式。</p>
<ul>
<li>字符模式： v</li>
<li>行模式：shift+v</li>
<li>块（列）模式：ctrl+v</li>
</ul>
<p>字符模式可突出西安市文本块中的句子。屏幕底部会出现VISUAL一词。按v可进入可视字符模式。按shift+v可进入行模式。底部会出现VISUAL LINE一词。</p>
<p>可视块模式非常适合于操作数据文件。从光标处按Ctrl+v键进入可视块。屏幕底部会出现VISUAL BLOCK。使用左右箭头键可以来突出选择要更改的部分。</p>
<h2 id="vim配置文件"><a href="#vim配置文件" class="headerlink" title="vim配置文件"></a>vim配置文件</h2><p>​	&#x2F;etc&#x2F;vimrc和<del>&#x2F;.vimr配置文件分别用来该表整个系统或特定用户的vim编辑器行为。在这些配置文件中您可以指定行为，如默认的制表符间距、语法突出显示、颜色方案等。在使用yaml等具有严格语法要求的语言时，修改vim编辑器的行为非常有用。请考虑以下</del>&#x2F;.vimrc文件，他将在编辑yaml文件时将默认制表位（有ts字符表述）原先的四个空格，修改为两个空格。该文件还包括set number参数，可在表记所有文件时显示行号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> .vimrc </span><br><span class="line">autocmd FileType yaml setlocal ts=2</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	其余更多参数资料可使用man vim（5）进行查看。</p>
<h1 id="更改shell环境"><a href="#更改shell环境" class="headerlink" title="更改shell环境"></a>更改shell环境</h1><h2 id="shell变量用法"><a href="#shell变量用法" class="headerlink" title="shell变量用法"></a>shell变量用法</h2><p>​	使用Bash Shell时，您可以设置shell变量，来帮助运行命令或修改shell的行为。它们会自动复制到从改shell运行的程序中。您可以使用变量来更轻松的运行带有长参数的命令，或者将常用设置应用于该shell运行的命令。</p>
<p>​	shell变量对于特定的shell会话是唯一的。如果您打开两个终端窗口，或者通过两个独立的登录会话登录同以远程服务器，那么您在运行两个shell。每个shell都会有自己的一组shell变量值。</p>
<h2 id="为变量分配值"><a href="#为变量分配值" class="headerlink" title="为变量分配值"></a>为变量分配值</h2><p>​	使用以下语法将值分配给shell变量，VARIABLENAME（变量名）、value（变量值）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ VARIABLENAME=value</span><br></pre></td></tr></table></figure>

<p>​	变量名可以包含大写或小写、数字和下划线字符（_）。例如以下命令可设置shell变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ COUNT=40</span><br><span class="line">[kiosk@foundation0 ~]$ first_name=LiWeiHu</span><br><span class="line">[kiosk@foundation0 ~]$ file1=/tmp/abc</span><br><span class="line">[kiosk@foundation0 ~]$ _ID=RH124</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	请记住，此更改仅会影响在其中运行命令的shell环境中，而不影响您可能在在服务器上运行的其他任何shell。</p>
<p>​	您可以使用set命令列出当前设置的所有shell变量。（它还会列出所有shell喊出，您可以忽略它们）要提高可读性，您可以将输出通过管道传输到less命令，以便一次一页的查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ set | less</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/10/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%8A%82/image-20250319162742725.png" alt="image-20250319162742725"></p>
<p>​	</p>
<h2 id="使用变量扩展检索值"><a href="#使用变量扩展检索值" class="headerlink" title="使用变量扩展检索值"></a>使用变量扩展检索值</h2><p>​	您可以使用变量扩展来指代您设置的变量值。要使用变量扩展，您在变量名前加上美元符号（$）。</p>
<p>例如：以下命令可将变量COUNT设置为40.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ COUNT=40</span><br></pre></td></tr></table></figure>

<p>如果echo COUNT，他会显示COUNT字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> COUNT</span><br><span class="line">COUNT</span><br></pre></td></tr></table></figure>

<p>如果输入echo $COUNT，他会显示COUNT变量的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$COUNT</span></span><br><span class="line">40</span><br></pre></td></tr></table></figure>

<p>您也可以使用变量来指代多个命令的长文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ file1=/tmp/tmp.Z9s32js242</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> <span class="variable">$file1</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> <span class="variable">$file1</span></span><br><span class="line">/tmp/tmp.Z9s32js242</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">rm</span> <span class="variable">$file1</span></span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> <span class="variable">$file1</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;/tmp/tmp.Z9s32js242&#x27;</span>: No such file or directory</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	重要：您始终可以在变量扩展中使用花括号，尽管它们通常是不必要的。</p>
<p>​		在以下示例中，echo命令尝试扩展不存在的变量COUNTx，但不返回任何内容。该命令也不会报告任何错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> new <span class="variable">$COUNTx</span></span><br><span class="line">new</span><br></pre></td></tr></table></figure>

<p>​		如果变量名旁边有任何尾随字符，可以使用花括号来划定变量名称的界限。在以下示例中，echo命令现在扩展了COUNT变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> new <span class="variable">$&#123;COUNT&#125;</span>x</span><br><span class="line">new 40x</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<h2 id="使用Shell变量配置Bash"><a href="#使用Shell变量配置Bash" class="headerlink" title="使用Shell变量配置Bash"></a>使用Shell变量配置Bash</h2><p>​	一些shell变量在Bash启动时设置。您可以修改它们来调整shell的行为。</p>
<p>​	例如，HISTFILE、HISTFILESIZE和HISTTIMEFORMAT等shell变量可影响shell历史记录的history命令。HISTFILE变量指定要将shell历史记录保存到哪个文件，默认为~&#x2F;.bash_history。HISTTIMEFORMAT变量定义历史记录中每个命令的时间戳格式。默认情况下，此变量不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ history </span><br><span class="line">   15  vim filename</span><br><span class="line">   16  vim --version</span><br><span class="line">   17  \vi --version</span><br><span class="line">   18  alias </span><br><span class="line">   19  alias vi=&quot;vim&quot;</span><br><span class="line">   20  alias </span><br><span class="line">   21  vim filename </span><br><span class="line">[kiosk@foundation0 ~]$ HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">[kiosk@foundation0 ~]$ history </span><br><span class="line">   15  2025-03-19 10:16:06 vim filename</span><br><span class="line">   16  2025-03-19 10:17:37 vim --version</span><br><span class="line">   17  2025-03-19 10:17:43 \vi --version</span><br><span class="line">   18  2025-03-19 10:21:55 alias </span><br><span class="line">   19  2025-03-19 10:23:06 alias vi=&quot;vim&quot;</span><br><span class="line">   20  2025-03-19 10:23:10 alias </span><br><span class="line">   21  2025-03-19 11:31:39 vim filename </span><br></pre></td></tr></table></figure>

<p>​	另一个示例是PS1变量，该变量控制shell提示符的外观。如果更改此值，他将改变shell提示符的外观。bash（1）man page的“PROMPTING”部分列出了提示符支持的多个特殊字符扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ PS1=<span class="string">&quot;bash\$ &quot;</span></span><br><span class="line">bash$ PS1=<span class="string">&quot;[\u@\h \w]\$ &quot;</span></span><br><span class="line">[kiosk@foundation0 ~]$</span><br></pre></td></tr></table></figure>

<p>​	由于PS1变量设置的值是提示符，红帽建议以空格结尾。另外每当变量值包含某种形式的空格（包括空格、制表符（TAB）或回车）时，该值必须用单引号或双引号括起来。如果省略引号，可能会出现意外结果。前面的PS1变量符合尾随空格建议和引号规则。</p>
<h2 id="使用环境变量配置程序"><a href="#使用环境变量配置程序" class="headerlink" title="使用环境变量配置程序"></a>使用环境变量配置程序</h2><p>​	shell提供了一个环境，供您从该shell中运行程序。例如，此环境包括有关文件系统上当前工作目录的信息、传递给程序的命令行选项，以及环境变量的值。程序可以使用这些环境变量来更改其行为或其默认设置。</p>
<p>​	如果shell变量不是环境变量，则只有shell可以使用它。但是如果shell变量是环境变量，则shell和从该shell运行的任何程序都可以使用该变量。</p>
<p>​	您可以将shell中定义的任何变量分配为环境变量，方法是将它们用export命令导出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ EDITOR=vim</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$EDITOR</span></span><br><span class="line">vim</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> EDITOR</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span></span><br><span class="line">...忽略...</span><br><span class="line"><span class="built_in">declare</span> -x EDITOR=<span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	另一个重要的环境变量是PATH。PATH变量包含一个含有程序目录的冒号分割列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/home/kiosk/.local/bin:/home/kiosk/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	当您运行如ls等命令时，shell会按顺序逐一在这些目录中查找可执行文件ls，并且允许它找到的第一个匹配文件。（在经典的系统中，此文件位于&#x2F;usr&#x2F;bin&#x2F;ls）。</p>
<p>​	那您可以轻松地将目录附加到PATH变量。例如，您可能希望像常规命令一样允许&#x2F;home&#x2F;user&#x2F;sbin中一些可执行程序或脚本。您可以将&#x2F;home&#x2F;user&#x2F;sbin目录加到当前会话的PATH中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ export PATH=$&#123;PATH&#125;:/home/kiosk/sbin</span><br><span class="line">[kiosk@foundation0 ~]$ cat &gt; /home/kiosk/sbin/haha &lt;&lt; EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;这是/home/kiosk/sbin目录下的一个可执行文件&quot;</span><br><span class="line">EOF</span><br><span class="line">[kiosk@foundation0 ~]$ haha</span><br><span class="line">这是/home/kiosk/sbin目录下的一个可执行文件</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	要列出特定的shell的所有环境变量，请运行env命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ env</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">...忽略...</span><br><span class="line">PATH=/home/kiosk/.local/bin:/home/kiosk/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/kiosk/sbin</span><br><span class="line">SELINUX_LEVEL_REQUESTED=</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="设置默认文本编辑器"><a href="#设置默认文本编辑器" class="headerlink" title="设置默认文本编辑器"></a>设置默认文本编辑器</h2><p>​	EDITOR环境变量是指定要用于命令行程序的默认文本编辑器。如果不指定，很多系统会使用vi或者vim，您也可以覆盖原有选项，这里可以换成nano编辑器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> EDITOR=nano</span><br></pre></td></tr></table></figure>





<h2 id="自动设置变量"><a href="#自动设置变量" class="headerlink" title="自动设置变量"></a>自动设置变量</h2><p>​	当Bash启动时，会运行几个含有shell命令的文本文件，以初始化shell环境。要在shell启动时自动设置shell或环境变量，您可以编辑Bash启动脚本。也就是配置永久变量或环境变量。</p>
<p>​	运行的确切脚本取决于shell是交互式还是非交互式的，以及是登录还是非登录shell。用户直接在交互式shell中输入命令，而非交互式shell则是在后台运行且无需用户干预，例如脚本。当用户通过终端本地登录或通过SSH协议远程登录时，将调用登录shell。非登录shell从现有会话调用，例如从GNOME GUI打开终端。</p>
<p>​	对于交互式登录shell，&#x2F;etc&#x2F;profile和<del>&#x2F;.bash_profile文件配置Bash环境，&#x2F;etc&#x2F;profile和</del>&#x2F;.bash_profile文件也分别提供&#x2F;etc&#x2F;bashrc和<del>&#x2F;.bashrc文件。对于交互式非登录shell，只有&#x2F;etc&#x2F;bashrc和</del>&#x2F;.bashrc文件配置Bash环境。&#x2F;etc&#x2F;profile和&#x2F;etc&#x2F;bashrc文件适用于整个系统（全局Bash环境），而<del>&#x2F;.bash_profile和</del>&#x2F;.bashrc文件则是特定用户的（局部用户Bash环境）。非交互式shell调用BASH_ENV变量定义的任何文件。默认情况下不定义此变量。</p>
<p>​	要创建可供所有交互式shell使用的变量，请编辑<del>&#x2F;.bashrc文件。若也要在用户登录后使用的变量，可在</del>&#x2F;.bash_profile文件中定义。</p>
<p>​	例如，若要更改通过SSH登录时的默认编辑器，您可以修改~&#x2F;.bash_profile文件中的EDITOR变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="string">&quot;export EDITOR=nano&quot;</span> &gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：若要调整作用于所有用户账户的设置，最佳的方式是带有.sh扩展名的文件，并在改文件中包含对应的/etc/porfile.d目录中更改。要在/etc/porfile.d目录中创建文件，请以root用户身份登录。</code></p>
<h2 id="Bash-别名"><a href="#Bash-别名" class="headerlink" title="Bash 别名"></a>Bash 别名</h2><p>​	Bash别名是其他Bash命令的快捷方式。例如，如果必须繁琐的键入一个长命令，您可以创建一个较短的别名来调用它。使用alias命令来创建别名。例如，一下示例为echo命令创建hello别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ alias hello=&#x27;echo &quot;Hello, this is a long string.&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>​	然后，您可以运行hello命令，它会调用echo命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ hello </span><br><span class="line">Hello, this is a long string.</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	将别名添加到用户的~&#x2F;.bashrc文件中，以便它们在任何交互shell中可用。</p>
<h2 id="取消设置和取消导出变量于别名"><a href="#取消设置和取消导出变量于别名" class="headerlink" title="取消设置和取消导出变量于别名"></a>取消设置和取消导出变量于别名</h2><p>​	要取消设置和取消导出变量，请使用unset命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$file1</span></span><br><span class="line">/tmp/tmp.Z9sdai2W2c</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">unset</span> file1 </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">echo</span> <span class="variable">$file1</span></span><br><span class="line"></span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>



<p>​	要取消导出变量但不取消设置它，请使用export -n命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">export</span> -n PS1</span><br></pre></td></tr></table></figure>



<p>​	要取消设置别名，请使用unalias命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">unalias</span> hello </span><br><span class="line">[kiosk@foundation0 ~]$ hello</span><br><span class="line">bash: hello: <span class="built_in">command</span> not found...</span><br><span class="line">^C</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第五章节</title>
    <url>/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="管理本地用户和组"><a href="#管理本地用户和组" class="headerlink" title="管理本地用户和组"></a>管理本地用户和组</h1><h2 id="什么是用户？"><a href="#什么是用户？" class="headerlink" title="什么是用户？"></a>什么是用户？</h2><p>​	用户账户在可以运行命令的不同人员和程序之间提供安全界限。</p>
<p>​	用户使用用户名想人类用户标识自己并加强操作的便利性。在内部，系统通过分配的唯一标识号（用户ID或UID）来区分不同的用户账户。在大多数情况下，如果有人使用用户账号，则系统会位改用户分配一个机密密码，以证明他们是登录的授权用户。</p>
<p>​	用户账户构成了系统安全的基础。系统中的每个进程（运行的程序）都作为一个特定用户运行。每个文件都有一个特定用户作为其所有者。借助文件所有权，系统可以对文件的用户实施访问控制。与运行进程相关联的用户可确定该进程可访问的文件和目录。</p>
<p>​	用户账户有以下三种主要类型：超级用户、系统用户和普通用户。</p>
<ul>
<li>超级用户账户负责管理系统。超级用户的名称为root，其账户的UID为0.超级用户具有完全的系统访问权限。</li>
<li>系统用户账户提供支持服务进程使用。这些进程（或守护进程）通常不需要以超级用户身份运行。系统会为它们分配非特权账户，确保其文件和其他资源不受彼此以及系统上普通用户的影响。用户无法使用系统用户账户以交互式登录。</li>
<li>大多数用户都有用于日常工作的普通用户账户。与系统用户一样，普通用户对系统具有有限的访问权限。</li>
</ul>
<p>​	使用id命令可显示有关当前已登录用户的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	要查看有关其他用户的基本信息，请将用户作为参数传递给id命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">id</span> redhat01 </span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01)</span><br><span class="line">[kiosk@foundation0 home]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ls -l命令可查看文件的所有者。使用ls -ld命令可查看目录的所有者，而不是该目录的内容。在以下出书中，第三列显示所有者的用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l test1.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk 1 Mar  6 16:46 test1.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld Music/</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk 6 Feb  1  2023 Music/</span><br><span class="line">[kiosk@foundation0 ~]$ </span><br></pre></td></tr></table></figure>

<p>​	使用ps命令可查看进程信息。默认为仅显示当前shell中的进程。使用ps命令-a选项可查看与某一终端相关的所有进程。使用ps命令-u选项可查看与进程关联的用户。在以下输出中，第一列显示用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ ps -au</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">kiosk       2342  0.0  0.0 374120  5872 tty2     Ssl+ 14:28   0:00 /usr/libexec/gdm-wayland-session --register-s</span><br><span class="line">kiosk       2352  0.0  0.1 521392 19632 tty2     Sl+  14:28   0:00 /usr/libexec/gnome-session-binary</span><br><span class="line">kiosk       3200  0.0  0.0 224212  5800 pts/0    Ss+  14:29   0:00 bash</span><br><span class="line">kiosk       4447  0.0  0.0 224228  5768 pts/6    Ss   14:35   0:00 -bash</span><br><span class="line">kiosk       4918  1.5  0.0 224096  5556 pts/7    Ss+  15:13   0:00 -bash</span><br><span class="line">kiosk       4952  0.0  0.0 225500  3648 pts/6    R+   15:13   0:00 ps -au</span><br></pre></td></tr></table></figure>

<p>​	以上命令输出按名称显示用户名，但操作系统内部利用UID来跟踪用户。用户名到UID的映射在账户信息数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;passwd文件存储有关本地用户的信息。</p>
<p>​	&#x2F;etc&#x2F;passwd文件的每一行都包含了有关某个用户的信息。该文件划分为7个以上的冒号分割的字段。以下是来自&#x2F;etc&#x2F;passwd行的示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line">redhat01:x:1001:1001:User One:/home/redhat01:/bin/bash</span><br></pre></td></tr></table></figure>

<p>​	代码块的每个部分，用冒号分割</p>
<ul>
<li>redhat01：此为用户的用户名</li>
<li>x：用户的加密密码历来存储在这里；但在此是一个占位符。</li>
<li>1001：此用户账户的UID编号</li>
<li>1001：此用户账户的主要组的GID编号。本章节稍后将对组进行讨论</li>
<li>User One：此用户的简短注释、描述或真实姓名等。</li>
<li>&#x2F;home&#x2F;redhat01：用户的主目录，以及登录shell启动时的初始工作目录。</li>
<li>&#x2F;bin&#x2F;bash：此用户的默认shell程序，在登陆时运行，一些账户使用&#x2F;sbin&#x2F;nologin shell来禁止该用户使用交互式登录。</li>
</ul>
<h2 id="什么是组"><a href="#什么是组" class="headerlink" title="什么是组"></a>什么是组</h2><p>​	组是需要共享文件和其他系统资源访问权限的用户集合。组可用于向一组用户授予文件访问权限，而非向一个用户授予访问权限。</p>
<p>​	与用户一样，组也具有组名以便识别。在内部，系统通过分配的唯一标识号（组ID或GID）来区分不同的组。组名到GID映射在组账户信息身份管理数据库中定义。默认情况下，系统使用&#x2F;etc&#x2F;group文件存储有关本地组的信息。</p>
<p>​	&#x2F;etc&#x2F;group文件的每行都包含了有关某个组的信息。每个组条目被分为四个以冒号分割的字段。以下来自&#x2F;etc&#x2F;group行的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...忽略...</span><br><span class="line">redhat01:x:1001:user01,user02</span><br></pre></td></tr></table></figure>

<p>​	考虑代码块的每个部分用冒号分割：</p>
<ul>
<li>redhat01：此组的名称</li>
<li>x：以前的组密码字段；现在是一个占位符。</li>
<li>1001：此组的GID编号。</li>
<li>user01,user02：属于此组成员的用户列表，作为一个补充组。</li>
</ul>
<h2 id="主要组和补充组"><a href="#主要组和补充组" class="headerlink" title="主要组和补充组"></a>主要组和补充组</h2><p>​	每一个用户有且只有一个主要组。对于本地用户而言，这个组按照GID列在&#x2F;etc&#x2F;passwd文件中。主要组拥有用户创建的文件。</p>
<p>​	在创建普通用户时，会创建一个与用户名同名的组，作为该用户的主要组。该用户是这个私有组的唯一成员。这种组成员资格设计简化了文件权限的管理，默认为区隔不同的用户组。</p>
<p>​	用户还可以拥有多个补充组。补充组中的成员资格存储在&#x2F;etc&#x2F;group文件中。根据所在组身份具有访问权限，将授予用户对文件的访问权限，不论这些组是主要组还是补充组。例如，如果user01用户有一个主要组user01以下两个补充组wheel和webadmin，那么该用户就可以读取这三个组中任何一个组，有权读取的文件。</p>
<p>​	id命令可以显示用户的组成员资格。在以下示例中，kiosk用户具有组kiosk作为自己的主要组（gid）。groups项列出此用户的所以组成员资格，而且用户还具有libvirt组作为补充组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1000(kiosk) gid=1000(kiosk) <span class="built_in">groups</span>=1000(kiosk),982(libvirt) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="获取超级用户访问权限"><a href="#获取超级用户访问权限" class="headerlink" title="获取超级用户访问权限"></a>获取超级用户访问权限</h1><h2 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h2><p>​	大多数操作系统具有一个超级用户，该用户拥有系统的全部权限。在红帽Linux中，此为root用户。此用户的特权高于文件系统上的一般特权，您可以使用它来管理系统。若要执行诸如安装或删除软件以及管理系统文件和目录任务，必须将特权升级到root用户。</p>
<p>​	通常，普通用户中只有root用户才能控制大部分设备，但也有一些例外。例如，普通用户可以控制可移动设备，如USB设备。因此，虽然普通用户可以添加和删除文件并可管理可移动的设备，但默认情况下，只有root用户才能管理硬盘。</p>
<p>​	尽管如此，这种无限制的特权也带来了职责问题。root用户拥有足以破坏系统的无限制特权：删除文件和目录、删除用户账户，以及添加后门等。一旦root用户账户被盗，系统将处于危险之中，您也可能会失去管理控制。红帽建议系统管理员始终以普通用户身份登录，仅在需要时升级到root用户特权。</p>
<p>​	Linux上root账户大致相当于Windows上的本地Admininstrator账户。在Linux中，大多数系统管理员都作为无特权的用户登录，然后使用特种工具临时获得root特权。</p>
<p>​	<code>警告：Windows用户可能熟悉以本地Administrator用户身份登录以执行系统管理员职责的做法。如今不建议这样做，用户通过Administrator组中的成员资格来获取执行管理的特权。RHEL中同样如此，红帽建议系统管理员不要直接以root身份登录。取而代之，系统管理员以普通用户身份登录，然后使用其他机制（例如：su、sudo或policykit）临时获得超级用户特权。</code></p>
<h2 id="切换用户账户"><a href="#切换用户账户" class="headerlink" title="切换用户账户"></a>切换用户账户</h2><p>​	通过使用su命令，用户可以切换至另一个用户账户。如果从普通用户账户运行su命令并将另一用户账户作为参数，则必须提供要切换到的用户账户密码。以root用户身份运行su时，则无需输入用户密码。</p>
<p>​	本示例从kiosk账户运行su命令来切换到redhat01账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ su redhat01</span><br><span class="line">Password: <span class="comment"># redhat01的密码</span></span><br><span class="line">[redhat01@foundation0 kiosk]$ <span class="built_in">id</span></span><br><span class="line">uid=1001(redhat01) gid=1001(redhat01) <span class="built_in">groups</span>=1001(redhat01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[redhat01@foundation0 kiosk]$</span><br></pre></td></tr></table></figure>

<p>​	如果省略用户名作为su命令的参数，则默认情况下su 或 su - 命令会尝试切换到root。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 kiosk]$ su -</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Apr  3 18:01:23 CST 2025 on pts/6</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	命令su将启动非登录shell，而命令su - （带有短划线选项）会启动登录shell。两个命令的主要区别在于，su - 会将shell环境变量设置为如同该用户身份重新登录一样，而su以该用户身份启动shell，但使用的是原始用户环境变量设置。</p>
<p>​	<code>注意：su命令最常用于获得另一个用户身份（通常root）运行的命令行界面（shell提示符）。但是，您还可以通过su命令结合-c选项，以另一个用户身份运行任意程序。具体su命令更多选项可通过man su(1)查看</code></p>
<h2 id="通过sudo运行命令"><a href="#通过sudo运行命令" class="headerlink" title="通过sudo运行命令"></a>通过sudo运行命令</h2><p>​	出于安全原因，在某些情况下，系统管理员会将root用户配置为没有有限的密码。因此，用户无法使用密码直接以root身份登录系统。此外，您也无法使用su来获取交互式shell。在这种情况下，您可以使用sudo命令来获取root访问权限。</p>
<p>​	与su命令不同，sudo通常要求用户输入自己的密码以进行身份验证，而不是输入他们正尝试访问的用户账户的密码。也就是说，用户使用sudo命令以root身份运行命令时，是不需要知道root密码。相反，他们将使用自己的密码来验证访问权限。</p>
<p>​	下表总结了su、su - 和sudo命令之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>su</th>
<th>su -</th>
<th>sudo</th>
</tr>
</thead>
<tbody><tr>
<td>成为新用户</td>
<td>是</td>
<td>是</td>
<td>权限升级的命令</td>
</tr>
<tr>
<td>环境</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>需要密码</td>
<td>新用户的</td>
<td>新用户的</td>
<td>当前用户的</td>
</tr>
<tr>
<td>特权</td>
<td>与新用户相同</td>
<td>与新用户相同</td>
<td>有配置定义</td>
</tr>
<tr>
<td>记录的活动</td>
<td>仅su命令</td>
<td>仅su命令</td>
<td>权限升级的命令</td>
</tr>
</tbody></table>
<p>​	此外，您可以将sudo配置为允许特定用户像某个其他用户一样运行任何命令，或仅允许以该用户是否允许部分命令。例如，如果您将sudo命令配置为允许redhat01用户以root身份允许usermod命令，那么您可以允许一下命令来锁定或解锁用户账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> usermod -L redhat01 </span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[kiosk@foundation0 home]$ su - redhat01 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br><span class="line">[kiosk@foundation0 home]$</span><br></pre></td></tr></table></figure>

<p>​	如果某用户尝试以另一用户身份允许命令，但sudo配置不允许，则bash会阻止该命令，记录这次尝试，并向root发送一封邮件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> -f /var/log/secure</span><br><span class="line">Apr 17 15:53:04 foundation0 su[2569]: pam_unix(su-l:auth): authentication failure; <span class="built_in">logname</span>=kiosk uid=1000 euid=0 <span class="built_in">tty</span>=/dev/pts/0 ruser=kiosk rhost=  user=redhat01</span><br></pre></td></tr></table></figure>

<p>​	sudo的另一个好处是默认将所有执行的命令记录到&#x2F;var&#x2F;log&#x2F;secure中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# tail -f /var/log/secure</span><br><span class="line">Apr 17 15:50:06 foundation0 sudo[2373]:   kiosk : command not allowed ; TTY=pts/0 ; PWD=/home ; USER=root ; COMMAND=/sbin/usermod -L redhat01</span><br></pre></td></tr></table></figure>

<p>​	在红帽Linux中，wheel组所有成员都可以使用自己的密码通过sudo以任何用户身份允许命令，包括root在内</p>
<h2 id="通过Sudo获取交互式Root-Shell"><a href="#通过Sudo获取交互式Root-Shell" class="headerlink" title="通过Sudo获取交互式Root Shell"></a>通过Sudo获取交互式Root Shell</h2><p>​	要通过sudo访问root账户，请使用sudo -i命令。此命令将切换root账户并运行该用户的默认shell及关联的交互式登录脚本。要在没有交互式脚本的情况下运行shell，请使用sudo -s命令。</p>
<p>​	例如，管理员可以获取kiosk实例上root用户的交互式shell，方法是使用SSH公钥身份验证作为普通用户kiosk登录，在运行sudo -i命令获取root用户的shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 home]$ <span class="built_in">sudo</span> -i</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> kiosk: </span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="配置Sudo"><a href="#配置Sudo" class="headerlink" title="配置Sudo"></a>配置Sudo</h2><p>​	&#x2F;etc&#x2F;sudoers文件是sudo命令的主要配置文件。如果多个管理员试图编辑该文件，为了避免出现问题，您只能特殊的visudo命令进行编辑。visudo编辑器也会验证该文件，确保没有语法错误。</p>
<p>​	例如，以下来自&#x2F;etc&#x2F;sudoers文件的这一行可为wheel组成员启用sudo访问权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%wheel  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>

<ul>
<li>%wheel字符串是规则所应用到的用户或组。词语wheel前的%符号指定该是对一个组进行权限的设置。</li>
<li>ALL&#x3D;(ALL:ALL)命令指定在具有此文件的任何主机上（第一个ALL），wheel组中的用户可以在系统上以任何其他用户（第二个ALL）和任何其他组（第三个ALL）运行命令。</li>
<li>最后的ALL命令指定wheel组中的用户可以运行任何命令。</li>
</ul>
<p>​	默认情况下，&#x2F;etc&#x2F;sudoers文件还包含&#x2F;etc&#x2F;sudoers.d目录中所有文件的内容，作为配置文件的一部分。通过使用这种层次结构，您只需将相应的文件放入该目录中，即可为用户添加sudo访问权限。</p>
<p>​	<code>注意：将配置文件放在/etc/sudoers.d目录下比较方便。将文件复制到目录中或从目录中删除文件，即可启用或禁用sudo访问权限。通常每个文件都会以用户或组来进行命名，当要启用或是禁用时，只需将文件在该目录中复制或删除即可。避免一个文件长篇大论，难以维护</code></p>
<p>​	要为redhat01用户启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;redhat01文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">cat</span> /etc/sudoers.d/redhat01 </span><br><span class="line">redhat01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要为group01组启用完整的sudo访问权限，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;group01文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/group01</span><br><span class="line">%group01 ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<p>​	要使games组中的用户能够以operator用户身份运行id命令，您可以创建含有以下内容的&#x2F;etc&#x2F;sudoers.d&#x2F;games文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/games</span><br><span class="line">%games ALL=(operator) /bin/id</span><br></pre></td></tr></table></figure>

<p>​	此外，也可以设置sudo，以允许用户通过使用NOPASSWD:ALL命令在不输入密码的前提下以其他用户身份允许命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# cat /etc/sudoers.d/ansible</span><br><span class="line">%ansible ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p>​	虽然授权用户或组这种级别的访问权限存在明显的安全风险，但系统会将这种做法用于云实例、虚拟机和调配系统，以配置服务器。您必须谨慎地保护具有此访问权限的账户，并且要求使用SSH公钥身份验证，以便远程系统上的用户能访问它。</p>
<h1 id="管理本地用户账户"><a href="#管理本地用户账户" class="headerlink" title="管理本地用户账户"></a>管理本地用户账户</h1><h2 id="从命令行创建用户"><a href="#从命令行创建用户" class="headerlink" title="从命令行创建用户"></a>从命令行创建用户</h2><p>​	useradd username命令可以创建名为username的用户。它会设置用户的主目录和账户信息，并为名为username的用户创建一个私有组。此时，该账户尚未设置有效密码，用户也要设置了密码后才能登录。</p>
<p>​	useradd –help 命令将显示可用于覆盖默认设置的基本选项。大多数情形中，您可以将相同的选项用于usermod命令，以修改现有用户。</p>
<p>​	在红帽linux9中，useradd命令为新用户分配的第一个大于或等于1000的可用UID，除非您通过-u选项进行明确指定。</p>
<h2 id="从命令行修改现有的用户"><a href="#从命令行修改现有的用户" class="headerlink" title="从命令行修改现有的用户"></a>从命令行修改现有的用户</h2><p>​	usermod –help命令显示用于修改账户的基本选项。一些常见的选项如下：</p>
<table>
<thead>
<tr>
<th>usermod选项</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>-a，–append</td>
<td>与-G选项一起使用，将补充组添加到用户当前的组成员集合中，而不是将补充组集合替换为新的集合。</td>
</tr>
<tr>
<td>-c，–comment COMMENT</td>
<td>将COMMENT文本添加到注释字段。</td>
</tr>
<tr>
<td>-d，–home HOME_DIR</td>
<td>为用户账户指定一个主目录。</td>
</tr>
<tr>
<td>-g， –gid GROUP</td>
<td>为用户账户指定主要组。</td>
</tr>
<tr>
<td>-G，–groups GROUPS</td>
<td>为用户账户指定补充组，多个补充组用逗号分割列表。</td>
</tr>
<tr>
<td>-L， –lock</td>
<td>锁定用户账户。</td>
</tr>
<tr>
<td>-m，–move-home</td>
<td>将用户的主目录移送到新的位置。您必须将它于-d选项搭配使用。</td>
</tr>
<tr>
<td>-s，–shell SHELL</td>
<td>为用户账户指定特定的登录shell。</td>
</tr>
<tr>
<td>-U，–unlock</td>
<td>解锁用户账户。</td>
</tr>
</tbody></table>
<h2 id="从命令行删除用户"><a href="#从命令行删除用户" class="headerlink" title="从命令行删除用户"></a>从命令行删除用户</h2><p>​	userdel username 命令从&#x2F;etc&#x2F;passwd中删除用户的详细信息，但用户的主目录保持不变。userdel -r username 命令从&#x2F;etc&#x2F;passwd 中删除用户，同时删除用户的主目录。</p>
<p>​	<code>警告：如果您在不指定userdel -r 选项的情况下删除用户，则用户的文件归为未分配的UID所有。如果您创建了一个用户，并且该用户被分配了已删除用户的UID，则新账户将用有这些文件，这存在安全风险。通常，组织安全策略不允许删除用户账户，而是锁定它们不被使用，以避免这种情况。</code></p>
<p>​	以下示例演示了这如何导致信息泄露：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 kiosk]# useradd user01</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3 user01   user01     78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">[root@foundation0 ~]# userdel user01 </span><br><span class="line"><span class="comment"># 为加-r选项，此时用户的主目录处于未分配状态，他之前所属用户UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 1</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line"><span class="comment"># 创建用户，-u 指定该用户的UID为：1002</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user02</span><br><span class="line"><span class="comment"># 由于于之前的user01的UID一致，user01的主目录则自动归属为user02</span></span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 10:57 user01</span><br><span class="line">drwx------.  3 user02   user02     78 May 13 11:02 user02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>请注意，user02现在拥有之前归为user01所属的所有文件。root用户可以使用find / -nouser -o -nogroup 命令来查找无人拥有的文件和目录。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# userdel user02 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -l /home/</span><br><span class="line">total 2</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 10:57 user01</span><br><span class="line">drwx------.  3     1002     1002   78 May 13 11:02 user02</span><br><span class="line"><span class="comment"># nouser表示没有归属用户的条件，nogroup表示没有归属用户的组，-o选项表示【或】的意思，用于多个条件的拼接</span></span><br><span class="line">[root@foundation0 ~]# find / -nouser -o -nogroup </span><br><span class="line">...忽略...</span><br><span class="line">/home/user01/.mozilla</span><br><span class="line">/home/user01/.mozilla/extensions</span><br><span class="line">/home/user01/.mozilla/plugins</span><br><span class="line">/home/user01/.bash_logout</span><br><span class="line">/home/user01/.bash_profile</span><br><span class="line">/home/user01/.bashrc</span><br><span class="line">/home/user02</span><br><span class="line">....忽略....</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="从命令行设置密码"><a href="#从命令行设置密码" class="headerlink" title="从命令行设置密码"></a>从命令行设置密码</h2><p>​	passwd username 命令可为username用户设置初始密码，或更改其现有密码。root用户可以将密码设置为任何值。如果密码不符合最低建议标准，终端会显示消息；不顾哦，之后您可以重新键入该新密码，passwd也会成功更新该密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">[root@foundation0 ~]# useradd -u 1002 user01</span><br><span class="line">useradd: warning: the home directory /home/user01 already exists.</span><br><span class="line">useradd: Not copying any file from skel directory into it.</span><br><span class="line">Creating mailbox file: File exists</span><br><span class="line"><span class="comment"># 为用户设置初始密码，密码：123456，虽会提示密码过于简单，未通过字典检查，但再次确认密码后任然可以成功设置。</span></span><br><span class="line">[root@foundation0 home]# passwd user01 </span><br><span class="line">Changing password <span class="keyword">for</span> user user01.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	<code>建议普通用户必须选择至少八个字符长的密码。不要使用字典词语、用户名或旧密码。</code></p>
<h2 id="UID范围"><a href="#UID范围" class="headerlink" title="UID范围"></a>UID范围</h2><ul>
<li>UID 0：超级用户(root)账户UID。</li>
<li>UID 1-200：静态分配给系统进程的系统账户UID。</li>
<li>UID 201-999：分配给不拥有此系统上文件的系统进程的UID。需要非特权UID的软件将从这个可用池中动态分配UID。</li>
<li>UID 1000+：分配给普通非特权用户的UID范围。</li>
</ul>
<p>注意：RedHat6及更早的版本对系统用户使用的范围1-499的UID，对普通用户使用高于500的UID。您可以在&#x2F;etc&#x2F;login.defs文件中更改useradd和groupadd默认范围。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250513112428467.png" alt="image-20250513112428467"></p>
<h1 id="管理本地组账户"><a href="#管理本地组账户" class="headerlink" title="管理本地组账户"></a>管理本地组账户</h1><h2 id="从命令行创建组"><a href="#从命令行创建组" class="headerlink" title="从命令行创建组"></a>从命令行创建组</h2><p>​	groupadd命令用于创建组。不带选项时，groupadd命令会使用&#x2F;etc&#x2F;login.defs文件中通过GID_MIN和GID_MAX 变量指定的范围内的下一个可用GID。默认情况下，该命令分配的GID值大于任何其他现有的GID，即使有较低的值可用。</p>
<p>​	groupadd 命令 -g选项指定该组使用的特定GID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupadd -g 10000 group1</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">....忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：由于创建用户时会自动为该用户生成一个私有组（GID 1000+），一些管理员会留出了一个单独的GID范围，用于创建补充组来满足其目的。但是，这种额外的管理是不必要的，因为用户的UID和主要组GID是不需要是相同的数字。</code></p>
<p>​	groupadd 命令 -r 选项用于创建系统组。与普通一样，系统组使用&#x2F;etc&#x2F;login.defs文件中列出的有效系统GID范围内的GID。&#x2F;etc&#x2F;login.defs文件中的SYS_GID_MIN和SYS_GID_MAX配置项定义系统GID的范围。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group2:x:976:</span><br></pre></td></tr></table></figure>



<h2 id="从命令行修改现有的组"><a href="#从命令行修改现有的组" class="headerlink" title="从命令行修改现有的组"></a>从命令行修改现有的组</h2><p>​	groupmod 命令可以更改现有组的属性。groupmod命令-n选项可指定组的新名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -n group002 group2 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:976:</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	注意组名称从group2更改为group002，groupmod命令-g选项可更改GID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupmod -g 975 group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br><span class="line">group002:x:975:</span><br></pre></td></tr></table></figure>

<p>​	注意GID从原来的976变更为975.</p>
<h2 id="从命令行删除组"><a href="#从命令行删除组" class="headerlink" title="从命令行删除组"></a>从命令行删除组</h2><p>​	groupdel 命令可删除组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# groupdel group002 </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">tail</span> /etc/group</span><br><span class="line">...忽略...</span><br><span class="line">group1:x:10000:</span><br></pre></td></tr></table></figure>

<p>​	<code>注意：如果删除的组是现有用户的主要组，则您无法删除它。于使用userdel命令类似，首先检查以确保找到该组拥有的文件，避免信息泄露</code></p>
<h2 id="从命令行更改组成员资格"><a href="#从命令行更改组成员资格" class="headerlink" title="从命令行更改组成员资格"></a>从命令行更改组成员资格</h2><p>​	组成员资格通过用户管理进行控制。使用usermod -g命令来更改用户的主要组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01)</span><br><span class="line">[root@foundation0 home]# usermod -g group01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# </span><br></pre></td></tr></table></figure>

<p>​	使用usermod -aG命令，将用户太你家到某一补充组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1)</span><br><span class="line">[root@foundation0 home]# usermod -aG user01 user01 </span><br><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 </span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01)</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：usermod命令的-a选项可启用附加模式。不带-a选项时，命令会从当前未包含在 -G 选项列表中的任何补充组从该用户中删除。</code></p>
<h2 id="比较主要组和补充组成员资格"><a href="#比较主要组和补充组成员资格" class="headerlink" title="比较主要组和补充组成员资格"></a>比较主要组和补充组成员资格</h2><p>​	用户的主要组是在&#x2F;etc&#x2F;passwd文件中查看的用户账户和组。一个用户一次只能属于一个主要组。</p>
<p>​	用户的补充组是为用户配置的额外组，可在&#x2F;etc&#x2F;group文件中的用户条目中查看。一个用户可以属于任意数量的补充组，以有效实施文件访问和权限。</p>
<p>​	对于配置基于组的文件权限而言，用户的主要组和补充组之间没有区别。如果用户所属的组被分配了特定文件的访问权限，则该用户有权访问这些文件。</p>
<p>​	用户的主要组和补充组成员资格之间唯一的区别体现在用户创建文件时。新文件必须具有用户所有者和组所有者，这是在文件创建时分配的。用户的主要组用于新文件的组所有权，除非被选项命令覆盖。</p>
<h2 id="临时更改您的主要组"><a href="#临时更改您的主要组" class="headerlink" title="临时更改您的主要组"></a>临时更改您的主要组</h2><p>​	只有用户的主要组才会用于新文件创建属性。但是，您可以暂时将主要组切换到另一个组，但只能从您所属的补充组中去选择。如果您要手动或以脚本方式创建多个新文件，并希望创建时将不通的组分配为所有者，则可以切换组。</p>
<p>​	在此shell会话中，使用newgrp命令来切换主要组。您可以在所属的任何主要组或补充组之间却换，但一次只能由一个组是主要组。如果您注销并重新登录，主要组将回复为默认值。此示例将user01用户中的补充组user01临时切换为主要组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=10000(group1) <span class="built_in">groups</span>=10000(group1),1002(user01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line">[user01@foundation0 ~]$ newgrp </span><br><span class="line">group1  user01  </span><br><span class="line">[user01@foundation0 ~]$ newgrp user01 </span><br><span class="line">[user01@foundation0 ~]$ <span class="built_in">id</span></span><br><span class="line">uid=1002(user01) gid=1002(user01) <span class="built_in">groups</span>=1002(user01),10000(group1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>





<h1 id="管理用户密码"><a href="#管理用户密码" class="headerlink" title="管理用户密码"></a>管理用户密码</h1><h2 id="影子密码和密码策略"><a href="#影子密码和密码策略" class="headerlink" title="影子密码和密码策略"></a>影子密码和密码策略</h2><p>​	加密的密码最初存储在全局可读的&#x2F;etc&#x2F;passwd文件中。这曾认为是最妥善的，直到对加密密码的字典式攻击变得常见。加密后的密码已移至&#x2F;etc&#x2F;shadow文件，只有root用户可以读取该文件。</p>
<p>​	与&#x2F;etc&#x2F;passwd文件一样，每个用户在&#x2F;etc&#x2F;shadow文件中都有一个条目。&#x2F;etc&#x2F;shadow文件中的示例条目具有九个以冒号分割的字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redhat01:$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0:20195:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>​	以此代码块为例，每个字段用冒号分割：</p>
<ul>
<li>redhat01：用户账户名称。</li>
<li>$6$N4i94UcIEydv…省略：用户的加密密码，$6开头（SHA-512）加密。</li>
<li>20195：上次更改密码时间距离纪元的天数；纪元是UTC时区的1970-01-01。</li>
<li>0：自上次更改密码以来到用户可再次更改密码之前必须经过的最短天数。</li>
<li>99999：在密码过期之前不进行密码更改的最长天数。空字段表示密码永不过期，自最后一次修改密码截至多少天过期。</li>
<li>7：在密码过期前提前多少天警告用户。</li>
<li>空：自密码过期之日起，在账户自动锁定前能够活动的天数，宽限天数。</li>
<li>空：密码到期之日距离纪元的天数。空字段表示密码永不过期，密码过期天数。</li>
<li>空：保留字段，预留给未来使用。</li>
</ul>
<h2 id="加密密码的格式"><a href="#加密密码的格式" class="headerlink" title="加密密码的格式"></a>加密密码的格式</h2><p>​	加密密码字段中存储了三段信息：所用的哈希算法、salt及加密哈希值。每段信息由美元符号（$）字符分割。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$6$N4i94UcIEydvTFzp<span class="variable">$pf9W0C4I6w4BFxyK</span>/ver6M7DVPnvupuGoYK/ZP24Y9ojBLN1/VYuJSucRtIDrICSSzhvmc31iUeXuBNnV3oBm0</span><br></pre></td></tr></table></figure>

<ul>
<li>$6：此密码所使用的哈希算法。6表示SHA-512,这是RedHat默认算法；1表示MD5，而5则表示SHA-256。</li>
<li>$N4i94UcIEydvTFzp：用于加密密码的salt；最初是随机选择的。</li>
<li>$pf9W0C4I6w4BFxyK&#x2F;ver…忽略：用户密码的加密后的哈希；将salt和未加密密码组合并加密，生成密码哈希。</li>
</ul>
<p>​	将salt与密码组合的主要原因是为了防止使用预先计算的密码哈希列表攻击。添加salt会改变生成的哈希值，使预先计算的列表毫无用处。如果攻击者获得了使用salt的&#x2F;etc&#x2F;shadow文件的副本，则它们需要通过暴力破解来猜测密码，这将花费更多的时间和精力。</p>
<h2 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h2><p>​	用户尝试登录时，系统在&#x2F;etc&#x2F;shadow文件中查询用户的条目，将用户的salt和键入的未加密密码组合，在使用制定的哈希算法加密组合。如何加密组合后的结果与已加密的哈希匹配，则用户键入了正确的密码。如果结果与已加密的密码不符合，则用户键入了错误的密码，登录尝试也会失败。这种方式允许系统半段用户是否键入了正确的密码，同时又不以用于登录的密码形式来存储密码。</p>
<h2 id="配置密码期限"><a href="#配置密码期限" class="headerlink" title="配置密码期限"></a>配置密码期限</h2><p>​	下图显示了相关的密码期限参数，可以通过chage命令对起调整实施密码期限策略。</p>
<p><img src="/2025/04/03/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%8A%82/image-20250520145616305.png" alt="image-20250520145616305"></p>
<p>​	以下示例演示使用chage命令修改redhat01用户的密码策略。该命令定义密码修改间隔最短期限（-m）为0天，密码最长有效期（-M）为90天，警告期（-W）7天，以及过期后宽限（-I）14天后自动过期为不活动状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -m 0 -M 90 -W 7 -I 14 redhat01</span><br><span class="line">[root@foundation0 ~]# chage -l redhat01 </span><br><span class="line">Last password change					: Apr 17, 2025</span><br><span class="line">Password expires					: Jul 16, 2025</span><br><span class="line">Password inactive					: Jul 30, 2025</span><br><span class="line">Account expires						: never</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 90</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	假设您在RedHat上管理用户密码策略。user01用户是系统中的新用户，您要设置自定义密码期限策略。您希望将账户的到期之间设置为，即日起30天后到期，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> +%F</span><br><span class="line">2025-05-20</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F</span><br><span class="line">2025-06-19</span><br><span class="line">[root@foundation0 ~]# chage -E $(<span class="built_in">date</span> -d <span class="string">&quot;+30 days&quot;</span> +%F) user01</span><br><span class="line">[root@foundation0 ~]# chage -l user01 | grep <span class="string">&quot;Account expires&quot;</span></span><br><span class="line">Account expires						: Jun 19, 2025</span><br></pre></td></tr></table></figure>

<ul>
<li>使用date命令获取当前时间，并通过+%F选项，调整date命令输出的日期格式。</li>
<li>使用date命令的-d选项以及“+30 days”参数获取即日起30天后的日期，并转换日期格式。</li>
<li>使用chage命令的-E选项，将获得的截至日期作为参数赋予该选项。</li>
<li>使用chage命令的-l选项，并且通过grep命令筛选出命令输出结果中的“Account expires”行，最终查看user01用户的过期时间成功设置为30天后。</li>
</ul>
<p>​	几天后，您在&#x2F;var&#x2F;log&#x2F;secure日志文件中发现user01用户有一个奇怪的行为。用户尝试使用sudo与其他用户的文件交互。您怀疑用户可能忘记关闭在另一台计算机上工作时打开的ssh会话。您希望user01用户在下次登录时更改密码，因此您可以使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# chage -d 0 user01 </span><br><span class="line">[root@foundation0 ~]# chage -l user01</span><br><span class="line">Last password change					: password must be changed</span><br><span class="line">Password expires					: password must be changed</span><br><span class="line">Password inactive					: password must be changed</span><br><span class="line">Account expires						: Jun 19, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	此时user01的密码策略中提示，用户必须修改密码的结果，下次用户登录时就必须要求修改密码了。</p>
<p>​	<code>注意：date命令可以计算未来的时间。-u选项报告UTC时间。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# date -d &quot;+5 days&quot; -u +%F</span><br><span class="line">2025-05-25</span><br></pre></td></tr></table></figure>

<p>​	您可以在&#x2F;etc&#x2F;login.defs文件中更改默认密码期限配置。PASS_MAX_DAYS和PASS_MIN_DAYS选项分别设置密码的默认最长和最短期限。PASS_WARN_AGE设置密码的默认警告期限。默认密码期限策略中的任何更改都会影响更改后新创建的用户。现有用户继续使用就密码期限设置，而非新密码设置。</p>
<h2 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h2><p>​	您可以使用usermod命令来修改用户的账户到期日期。例如，usermod命令-L选项可锁定用户账户，并且该用户无法登录系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L user03</span><br><span class="line">[kiosk@foundation0 ~]$ su - user03 </span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br></pre></td></tr></table></figure>

<p>​	如果用户在特定日期从公司离职，您可以通过usermod命令锁定并使其到期。该日期必须是从1970-01-01的天开始算起，或者使用YYYY-MM-DD格式。以下示例中，usermod命令于2025-05-21锁定user03用户并使其过期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -L -e 2025-05-21 user03 </span><br><span class="line">[root@foundation0 ~]# chage -l user03 </span><br><span class="line">Last password change					: May 20, 2025</span><br><span class="line">Password expires					: never</span><br><span class="line">Password inactive					: never</span><br><span class="line">Account expires						: May 21, 2025</span><br><span class="line">Minimum number of days between password change		: 0</span><br><span class="line">Maximum number of days between password change		: 99999</span><br><span class="line">Number of days of warning before password expires	: 7</span><br></pre></td></tr></table></figure>

<p>​	账户锁定后，您可以防止用户使用密码向系统进行验证。简易使用此方法防止前员工访问账户。使用usermod命令-U选项可以重新启用账户的访问权限。</p>
<h2 id="非登录Shell"><a href="#非登录Shell" class="headerlink" title="非登录Shell"></a>非登录Shell</h2><p>​	nologin shell用作不打算以交互方式登录系统的用户账户的代替shell。从安全角度来看，在账户不需要登录系统时，禁止账户登录系统是一个明智的选择。例如，邮件服务器可能需要账户来存储邮件，需要密码供用户通过检索邮件所用的邮件客户端进行身份验证。用户不需要直接登录该系统。</p>
<p>​	这种情况的常用解决方案是将用户的登录shell设置为&#x2F;sbin&#x2F;nologin。如果用户试图直接登录系统，nologin shell将关闭该连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# usermod -s /sbin/nologin user03 </span><br><span class="line">[root@foundation0 ~]# su - user03</span><br><span class="line">Last login: Tue May 20 14:49:37 CST 2025 on pts/0</span><br><span class="line">Last failed login: Tue May 20 14:51:02 CST 2025 on pts/0</span><br><span class="line">There were 4 failed login attempts since the last successful login.</span><br><span class="line">This account is currently not available.</span><br></pre></td></tr></table></figure>

<p>​	<code>重要：nologin shell可以防止以交互式使用系统，但不会阻止访问。如果用户使用密码进行身份验证，它们有时可以通过身份验证，并使用web应用、文件传输程序或邮件读取程序等应用上传或检索文件。</code></p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第三章节</title>
    <url>/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="在红帽企业Linux中获取帮助"><a href="#在红帽企业Linux中获取帮助" class="headerlink" title="在红帽企业Linux中获取帮助"></a>在红帽企业Linux中获取帮助</h1><h2 id="阅读手册页"><a href="#阅读手册页" class="headerlink" title="阅读手册页"></a>阅读手册页</h2><h3 id="Linux手册页简介"><a href="#Linux手册页简介" class="headerlink" title="Linux手册页简介"></a>Linux手册页简介</h3><p>​	本地系统上通常可用的文档来源之一是系统手册页或man page。软件包随附这些页面来提供文档，您可以使用man命令从命令行访问这些文档。页面存储在&#x2F;usr&#x2F;share&#x2F;man 目录的子目录中。</p>
<p>​	man page 源自过去的Linux程序员手册，该手册篇幅很长，足以划分多个章节。每个章节包含有特定主题信息。</p>
<table>
<thead>
<tr>
<th>章节</th>
<th>内容类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户命令</td>
<td>可执行命令和shell程序</td>
</tr>
<tr>
<td>2</td>
<td>系统调用</td>
<td>从用户空间调用的内核例程</td>
</tr>
<tr>
<td>3</td>
<td>库函数</td>
<td>有程序库提供</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件</td>
<td>例如设备文件</td>
</tr>
<tr>
<td>5</td>
<td>文件格式</td>
<td>用于许多配置文件和结构</td>
</tr>
<tr>
<td>6</td>
<td>游戏和屏保</td>
<td>过去的趣味程序章节</td>
</tr>
<tr>
<td>7</td>
<td>惯例、标准和其他</td>
<td>协议、文件系统</td>
</tr>
<tr>
<td>8</td>
<td>系统管理和特权命令</td>
<td>维护任务</td>
</tr>
<tr>
<td>9</td>
<td>Linux内核API</td>
<td>内部内核调用</td>
</tr>
</tbody></table>
<p>​	为区分不同章节中相同的主题名称，man page参考中在主题后附上章节编号（用括号括起）。例如：passwd(1)介绍更改密码的命令，而passwd(5)说明用于存储本地用户账户的&#x2F;etc&#x2F;passwd配置文件相关格式。</p>
<p>​	若要读取具体的man page，请使用man topic命令。man page一次显示一屏内容。man命令按照字母数字顺序搜索手册章节。例如：man passwd默认情况下只显示passwd(1)。要显示特定章节中的man page主题，您可以使用man section topic 命令。例如：man 5 passwd会显示passwd(5)。</p>
<p>​	常见的系统管理主题在第一章（用户命令）、第五章（文件格式）和第八章（管理命令）中。采用特定故障排除工具的管理员页可以使用第二章（系统调用）。剩余的章节供内核开发等人员参考或用于高级管理。</p>
<h3 id="阅览和搜索-Man-Page"><a href="#阅览和搜索-Man-Page" class="headerlink" title="阅览和搜索 Man Page"></a>阅览和搜索 Man Page</h3><p>​	高校的搜索主题并在man page中导航是一项非常重要的管理技能。您可以使用GUI管理goon根据来配置常见系统资源，但使用命令行界面依然更为高效。更有效的在命令行中找到所需man page信息。</p>
<p>​	下表列出在查看man page时基本的导航命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Spacebar（空格）</td>
<td>向前（向下）滚动一屏</td>
</tr>
<tr>
<td>PageDown（下键）</td>
<td>向前（向下）滚动一屏</td>
</tr>
<tr>
<td>Pageup（上键）</td>
<td>向后（向上）滚动一屏</td>
</tr>
<tr>
<td>D</td>
<td>向前（向下）滚动半屏</td>
</tr>
<tr>
<td>U</td>
<td>向后（向上）滚动半屏</td>
</tr>
<tr>
<td>&#x2F;string</td>
<td>在man page中搜索string内容</td>
</tr>
<tr>
<td>N</td>
<td>在man page中重复向前（向下）搜索</td>
</tr>
<tr>
<td>Shift+N</td>
<td>在man page中重复向后（向上）搜索</td>
</tr>
<tr>
<td>G</td>
<td>转到man page的开头</td>
</tr>
<tr>
<td>shift+G</td>
<td>转到man page的末尾</td>
</tr>
<tr>
<td>Q</td>
<td>退出man，并返回命令行</td>
</tr>
</tbody></table>
<h3 id="阅读Man-Page"><a href="#阅读Man-Page" class="headerlink" title="阅读Man Page"></a>阅读Man Page</h3><p>​	man page将各个主题划分为几个部分。大多数主题共享相同的标题，并以相同的顺序显示。通常，主题不包含所有标题，因为并非所有标题都使用所有主题。</p>
<p>​	常见的标题如下：</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>主题名称。通常是命令或文件名。简短的描述</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>命令语法概要</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>提供对主题的基本理解和描述</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>命令执行选项说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>有关如何使用命令、功能或文件的示例</td>
</tr>
<tr>
<td>FILES</td>
<td>与man page相关的文件和目录的列表。</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>相关的信息，通常是其他man page 主题。</td>
</tr>
<tr>
<td>BUGS</td>
<td>软件中已知错误。</td>
</tr>
<tr>
<td>AUTHOR</td>
<td>有关草鱼撰写该主题的人员信息。</td>
</tr>
</tbody></table>
<h3 id="根据关键字搜索man-page"><a href="#根据关键字搜索man-page" class="headerlink" title="根据关键字搜索man page"></a>根据关键字搜索man page</h3><p>​	使用man命令 -k（小写）选项（等同于apropos选项）可在man page的标题和描述中搜索关键字。关键字搜索的结果中显示与关键字匹配的man page 主题和章节编号列表。例如以下命令可搜索含词语passwd的man page。</p>
<p>​	<code>注意：关键字搜索依赖于mandb(8)命令生成的索引，该命令必须以root身份允许。在安装含有man page软件包是，man-db-cache-update访问会自动允许mandb命令，如果您通过man -k 无法搜索相应标题，则可能需要您手动执行一个mandb。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -k passwd</span><br><span class="line">chgpasswd (8)        - update group passwords <span class="keyword">in</span> batch mode</span><br><span class="line">chpasswd (8)         - update passwords <span class="keyword">in</span> batch mode</span><br><span class="line">fgetpwent_r (3)      - get passwd file entry reentrantly</span><br><span class="line">getpwent_r (3)       - get passwd file entry reentrantly</span><br><span class="line">gpasswd (1)          - administer /etc/group and /etc/gshadow</span><br><span class="line">grub2-mkpasswd-pbkdf2 (1) - Generate a PBKDF2 password <span class="built_in">hash</span>.</span><br><span class="line">htpasswd (1)         - Manage user files <span class="keyword">for</span> basic authentication</span><br><span class="line">lpasswd (1)          - Change group or user password</span><br><span class="line">openssl-passwd (1ossl) - compute password hashes</span><br><span class="line">pam_localuser (8)    - require <span class="built_in">users</span> to be listed <span class="keyword">in</span> /etc/passwd</span><br><span class="line">passwd (1)           - update user<span class="string">&#x27;s authentication tokens</span></span><br><span class="line"><span class="string">passwd (1ossl)       - OpenSSL application commands</span></span><br><span class="line"><span class="string">passwd (5)           - password file</span></span><br><span class="line"><span class="string">passwd2des (3)       - RFS password encryption</span></span><br><span class="line"><span class="string">pwhistory_helper (8) - Helper binary that transfers password hashes from passwd or shadow to opasswd</span></span><br><span class="line"><span class="string">saslpasswd2 (8)      - set a user&#x27;</span>s sasl password</span><br><span class="line">smbpasswd (5)        - The Samba encrypted password file</span><br><span class="line">vncpasswd (1)        - change the VNC password</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<p>​	man -K（大写）选项可在全文页面中搜索关键字，而补仅仅是在标题和描述中搜索。全文搜索使用更多的系统资源，耗费更长的时间。</p>
<p>​	使用全文页面搜索时，man 命令显示含有匹配项的第一页。按Q退出第一页，man命令则可显示下一页。</p>
<p>​	在本示例中，man显示每个匹配项，同时允许您查看或跳过每个匹配项。<code>man page页按Q退出，Ctrl+D（跳过该匹配项），Ctrl+c（退出匹配）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -K passwd</span><br><span class="line">--Man-- next: <span class="built_in">cut</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: <span class="built_in">logname</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: <span class="built_in">sort</span>(1p) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line"></span><br><span class="line">--Man-- next: xargs(1) [ view (<span class="built_in">return</span>) | skip (Ctrl-D) | quit (Ctrl-C) ]</span><br><span class="line">^C</span><br><span class="line">[root@foundation0 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="模拟操作练习"><a href="#模拟操作练习" class="headerlink" title="模拟操作练习"></a>模拟操作练习</h2><p>​	请根据下列要求完成用户创建，以及用户密码修改</p>
<ul>
<li>查询su命令使用方法，将当前shell（kiosk）用户切换为root用户。</li>
<li>查询useradd命令使用方法，使用该命令创建一个名为redhat01的用户。</li>
<li>查询passwd命令使用方法，使用该命令为redhat01用户更新密码。</li>
</ul>
<h2 id="模拟练习讲解"><a href="#模拟练习讲解" class="headerlink" title="模拟练习讲解"></a>模拟练习讲解</h2><p>​	根据题目已知，我们首先要使用man page查询关于su命令的一个使用方法，并且使用su命令将我们从kiosk用户切换到root用户的shell提示符。</p>
<p>​	方式一：通过man -k 来查找su的page页，但这样会找出很多有关su的page页，在我们已知我们要查找su的用户命令时，不推荐使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ man -k su</span><br><span class="line">.....忽略.....</span><br><span class="line">strspn (3)           - get length of a prefix substring</span><br><span class="line">strspn (3p)          - get length of a substring</span><br><span class="line">strstr (3)           - locate a substring</span><br><span class="line">strstr (3p)          - find a substring</span><br><span class="line">su (1)               - run a <span class="built_in">command</span> with substitute user and group ID</span><br><span class="line">Sub::Exporter (3pm)  - a sophisticated exporter <span class="keyword">for</span> custom-</span><br><span class="line">.....忽略.....</span><br><span class="line">[kiosk@foundation0 ~]$ man 1 su</span><br></pre></td></tr></table></figure>



<p>​	方式二：已知我们要找su的用户命令，用户命令的编号是 (1)，就可以直接使用，man 1 su 或者 man su，man su在没有指定page编号时，默认是打开序号（1）的用户命令页。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ man su</span><br></pre></td></tr></table></figure>



<p>​	打开page页后，即可开始阅读su命令相关文档了。name命令的名称，synopsis命令使用的语法格式，description命令详细作用、功能描述，options命令可使用的选项即描述。可从他的语法格式中看出，该命令是试用【su [选项] [-] [用户名作为参数]】 ,方括号内表示选填项。</p>
<p><img src="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/image-20250520171558216.png" alt="image-20250520171558216"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ su - root</span><br><span class="line">Password: </span><br><span class="line">Last login: Fri Mar  7 17:46:32 CST 2025 on pts/0</span><br><span class="line">Last failed login: Mon Mar 10 14:34:10 CST 2025 on pts/0</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>



<p>​	成功切换到root后，继续查看useradd命令是如何使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man useradd</span><br><span class="line">[root@foundation0 ~]# useradd redhat01</span><br></pre></td></tr></table></figure>

<p>​	更新redhat01用的密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man passwd</span><br><span class="line">[root@foundation0 ~]# passwd redhat01 </span><br><span class="line">Changing password <span class="keyword">for</span> user redhat01.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	您可以使用man命令-t选项，将你man page写入到你的文档文件中，并使用file命令验证识别文件类型为document文档。例如下方示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# man -t passwd &gt; passwd.ps</span><br><span class="line">[root@foundation0 ~]# file passwd.ps </span><br><span class="line">passwd.ps: PostScript document text conforming DSC level 3.0</span><br><span class="line">[root@foundation0 ~]#</span><br></pre></td></tr></table></figure>

<p>​	最后您可以通过evince命令，调用操作系统的文档工具打开该文档进行可视化阅览。</p>
<p><img src="/2025/03/07/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%8A%82/image-20250520171622522.png" alt="image-20250520171622522"></p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第八章节</title>
    <url>/2025/06/04/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="控制服务和守护进程"><a href="#控制服务和守护进程" class="headerlink" title="控制服务和守护进程"></a>控制服务和守护进程</h1><h2 id="识别自动启动的系统进程"><a href="#识别自动启动的系统进程" class="headerlink" title="识别自动启动的系统进程"></a>识别自动启动的系统进程</h2><h3 id="Systemd守护进程简介"><a href="#Systemd守护进程简介" class="headerlink" title="Systemd守护进程简介"></a>Systemd守护进程简介</h3><p>​	Systemd守护进程管理Linux的启动过程，一般包括服务启动和服务管理。systemd守护进程可再系统引导时以及运行中的系统上激活系统资源、服务器守护进程和其他进程。</p>
<p>​	守护进程是再执行各种任务的后台等待或运行的进程。一般情况下，守护进程再系统引导时自动启用并持续运行至关机或您手动将它停止。按照管理，守护进程的名称以及字母d结尾。</p>
<p>​	在systemd意义上，服务通常是指一个或多个守护进程。但是，启动或停止服务可能会更改一次系统状态，之后不会留下一个运行中的守护进程（称之为oneshot）。</p>
<p>​	在红帽企业Linux中，第一个启动的进程（PID1）是systemd守护进程，它提供以下功能：</p>
<ul>
<li>并行化功能（同时运行多个服务），它可提高系统的启动速度。</li>
<li>按需启动守护进程，而不需要单独的服务。</li>
<li>自动服务依赖关系管理，可以防止长时间超时。例如，只有在网络可用时，依赖网络的服务才会尝试启动。</li>
<li>利用Linux控制组一起追踪相关进程的方式。</li>
</ul>
<h3 id="服务单元描述"><a href="#服务单元描述" class="headerlink" title="服务单元描述"></a>服务单元描述</h3><p>​	</p>
]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-RHCE-124-第六章节</title>
    <url>/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/</url>
    <content><![CDATA[<h1 id="第六章-控制对文件的访问"><a href="#第六章-控制对文件的访问" class="headerlink" title="第六章-控制对文件的访问"></a>第六章-控制对文件的访问</h1><h2 id="解释Linux文件系统权限"><a href="#解释Linux文件系统权限" class="headerlink" title="解释Linux文件系统权限"></a>解释Linux文件系统权限</h2><h3 id="Linux文件系统权限"><a href="#Linux文件系统权限" class="headerlink" title="Linux文件系统权限"></a>Linux文件系统权限</h3><p>​	文件权限控制对文件的访问。Linux文件权限简单又灵活，能够应对大多数的常见权限情况。</p>
<p>​	文件具有三个应用权限的用户类别。文件归某个用户所有，通常是文件的创建者。文件还归单个组所有，通常是创建改文件的用户的主要组，但是可以进行更改。</p>
<p>​	您可以为所属用户（用户权限）、所属组（组权限），以及系统上非用户和非所属组成员的所有其他用户（其他权限）设置不通过的权限。</p>
<p>​	最具体的权限具有优先权。用户权限覆盖组权限，后者有覆盖其他权限。</p>
<p>​	举例说明成员资格如何促进用户之间协作。假设您的系统有两个用户：alice和bob。alice是alice和web组的成员，bob是bob、wheel和web组的成员。当alice和bob协作时，文件应当与web组关联，并且组权限应当允许这两个用户访问这些文件。</p>
<p>​	有三种权限类别可应用：读取、写入和执行。下表说明了这些权限如何影响文件和目录的访问。</p>
<p><em><strong>权限对文件和目录的影响</strong></em></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>r（读取）</td>
<td>可以读取该文件的内容</td>
<td>可以列出该目录下内容（文件名）</td>
</tr>
<tr>
<td>w（写入）</td>
<td>可以更改文件的内容</td>
<td>可以创建或删除目录中的任意文件</td>
</tr>
<tr>
<td>x（执行）</td>
<td>可以作为命令执行文件</td>
<td>目录可以成为当前工作目录。您可以允许cd进入这个目录，但还需要读取权限才能列出里面的文件。</td>
</tr>
</tbody></table>
<p>​	用户通常对只读目录具有读取和执行权限，因此他们可以进入该目录并列出该目录的内容。如果用户对目录仅具有读取访问权限，则可以列出其中文件的名称。但是，用户无法访问其他信息，如权限或时间戳。如果用户对目录具有仅执行权限，则无法列出目录中的文件名。如果他们知道自己有读取权限的文件名称，可以通过制定相对文件名称，从目录外访问该文件的内容。</p>
<p>​	对目录拥有所有权或写入权限的任何人都可以删除其中的文件，不论文件的所有权或权限如何。您可以使用粘滞位权限覆盖此行为，稍后讨论。</p>
<p>​	<code>注意：Linux文件权限的工作方式与Microsoft NTFS文件系统权限不同。在Linux上，权限仅适用于设置它们的文件或目录。目录内的子目录不会自动集成父目录的权限。但是，目录权限是可以阻止访问该目录的内容，具体取决于它们的限制程度。</code></p>
<h3 id="查看文件和目录的权限及所有权"><a href="#查看文件和目录的权限及所有权" class="headerlink" title="查看文件和目录的权限及所有权"></a>查看文件和目录的权限及所有权</h3><p>​	ls命令和-l选项可以显示有关权限和所有权的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 ~]$ <span class="built_in">ls</span> -l <span class="built_in">test</span> </span><br><span class="line">-rw-r--r--. 1 redhat01 redhat01 0 May 20 17:51 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>​	使用ls命令和-d选项可显示有关目录本身（而非其内容）的详细信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[redhat01@foundation0 ~]$ <span class="built_in">ls</span> -ld /home</span><br><span class="line">drwxr-xr-x. 6 root root 63 May 20 14:49 /home</span><br></pre></td></tr></table></figure>

<p>​	长列表的第一个字符表示文件类型，具体解释如下：</p>
<ul>
<li>-：是常规文件</li>
<li>d：是目录</li>
<li>l：是符号链接</li>
<li>c：是字符设备文件</li>
<li>b：是块设备文件</li>
<li>p：是命名管道文件</li>
<li>s：是本地套接字</li>
</ul>
<p>​	接下来九个字符表示文件权限。这些字符解释为三组，每组三个字符：第一组是适用于文件所有者的权限，第二组适用于文件的组所有者，最后一组则适用于其他所有（全局）用户。如果一组内是rwx，说明该组具有读取、写入和执行全部三种权限。如果一组的一个字母被替换为-，则表示改组没有这个权限。</p>
<p>​	在第一个示例中，用户redhat01的权限由第一组三个字符指定。redhat01用户对test文件具有读取和写入权限。第二组三个字符是redhat01组的权限；对test具有读取权限。第三组三个字符是所有其他用户的权限；对test具有读权限。</p>
<p>​	应用最具体的权限组。因此，如果redhat01与组redhat01具有不同权限，二用户redhat01也是该组的成员，那么将使用用户的所有者权限。这样，从族中删除用户可能不切实际时，可以为用户设置比其他组成员资源更严厉的权限集。</p>
<h3 id="权限影响示例"><a href="#权限影响示例" class="headerlink" title="权限影响示例"></a>权限影响示例</h3><p>​	以下示例说明文件权限的影响。对于这些示例，您的系统有四个具有以下组成员资格的用户：</p>
<table>
<thead>
<tr>
<th>用户</th>
<th>组成员资格</th>
</tr>
</thead>
<tbody><tr>
<td>user01</td>
<td>user01、user04</td>
</tr>
<tr>
<td>user02</td>
<td>user02、user04</td>
</tr>
<tr>
<td>user03</td>
<td>user03、operator2</td>
</tr>
<tr>
<td>user04</td>
<td>user04、operator2</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 home]# <span class="built_in">id</span> user01 user02 user03 user04 </span><br><span class="line">uid=1001(user01) gid=1001(user01) <span class="built_in">groups</span>=1001(user01),1004(user04)</span><br><span class="line">uid=1002(user02) gid=1002(user02) <span class="built_in">groups</span>=1002(user02),1004(user04)</span><br><span class="line">uid=1003(user03) gid=1003(user03) <span class="built_in">groups</span>=1003(user03),10001(operator2)</span><br><span class="line">uid=1004(user04) gid=1004(user04) <span class="built_in">groups</span>=1004(user04),10001(operator2)</span><br></pre></td></tr></table></figure>

<p>​	这些用户将使用dir目录中的文件。如下是改目录中文件的长列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user02@foundation0 <span class="built_in">dir</span>]$ <span class="built_in">ls</span> -la</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x.  2 user02 user04        70 May 21 11:16 .</span><br><span class="line">drwxr-xr-x. 20 root   root        4096 May 21 11:18 ..</span><br><span class="line">-rw-rw-r--.  1 user01 user01         0 May 21 11:15 app1.log</span><br><span class="line">-rw-r--rw-.  1 user01 consultantl    0 May 21 11:15 app2.log</span><br><span class="line">-rw-rw-r--.  1 user02 consultantl    0 May 21 11:16 db1.conf</span><br><span class="line">-rw-r-----.  1 user02 consultantl    0 May 21 11:16 db2.conf</span><br></pre></td></tr></table></figure>

<p>​	ls 命令-a选项可显示隐藏文件的权限，包含用于表示目录及其父目录的特殊权限。在本示例中，.（点）特殊目录反映了dir本身的目录权限，而..（点点）特殊目录则反映了其父目录的权限。</p>
<p>​	对于db1.conf文件，拥有该文件的用户（user02）具有读取、写入权限，但没有执行权限。拥有该文件的组（user04）具有读取和写入权限，但没有执行权限。所有其他用户具有读取权限，但没有写入和执行权限。</p>
<p>​	下表探讨了这组权限对这些用户的一些影响：</p>
<table>
<thead>
<tr>
<th>影响</th>
<th>为什么会有此影响？</th>
</tr>
</thead>
<tbody><tr>
<td>user01用户可以更改db1.conf文件的内容。</td>
<td>user01用户是consultantl组的成员，并且该组对db1.conf文件具有读取、写入权限。</td>
</tr>
<tr>
<td>user02用户可以查看和修改db2.conf文件的内容。</td>
<td>user02用户拥有db2.conf文件，并对其具有读取和写入访问权限。</td>
</tr>
<tr>
<td>user01可以查看db2.conf文件的内容，但不能修改其内容。</td>
<td>user01用户是consultantl组的成员，并且该组对db2.conf文件仅有读取、写入权限，无写入权限。</td>
</tr>
<tr>
<td>user03和user04用户没有对db2.conf的内容的任何访问权限。</td>
<td>other权限适用于user03和user04用户，并且这些权限不包括读取或写入权限。</td>
</tr>
<tr>
<td>user01用户是唯一能够更改app1.log文件内容的用户</td>
<td>仅有user01用户和user01组的成员对该文件具有写入权限，而其他用户没用该权限，而user01组的唯一组成员是user01用户。</td>
</tr>
<tr>
<td>user03用户可以更改app2.log文件的内容。</td>
<td>user03用户不是app2.log文件的所有者，也不是consultantl组成员，因此他仅适用于other权限，other权限具有读、写去权限。</td>
</tr>
<tr>
<td>user02用户可以查看app2.log文件的内容，但不能修改app2.log文件的内容。</td>
<td>user02用户是consultantl组的成员，并且该组对app2.log文件具有读权限，虽然other具有读、写权限。但是组的优先级大于other，所以会覆盖other的权限。</td>
</tr>
<tr>
<td>user02用户可以删除app1.log和app2.log文件。</td>
<td>user02用户对dir目录又有写入权限（如.（点）特殊目录所示），因此可以删除该目录中的任何文件。即使user02用户没有直接对文件具有写入权限，依然是可以进行删除的。</td>
</tr>
</tbody></table>
<h2 id="从命令行管理文件系统权限"><a href="#从命令行管理文件系统权限" class="headerlink" title="从命令行管理文件系统权限"></a>从命令行管理文件系统权限</h2><h3 id="更改文件和目录权限"><a href="#更改文件和目录权限" class="headerlink" title="更改文件和目录权限"></a>更改文件和目录权限</h3><p>​	chmod命令可从命令行更改文件和目录权限。chmod命令可以解释为“更改模式”，因为文件的模式是吻技安权限的另一个名称。chmod命令在要更改的文件或目录列表后面列出了权限说明。您可以通过符号或八进制（数字）表示法设置权限指令。</p>
<h3 id="通过符号法更改权限"><a href="#通过符号法更改权限" class="headerlink" title="通过符号法更改权限"></a>通过符号法更改权限</h3><p>​	使用chmod命令修改文件和目录权限。以下示例可以帮助您了解chmod命令的用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> <span class="built_in">who</span>/what/which file|directory</span><br></pre></td></tr></table></figure>

<p>​	who是用户的类，如下表所示。如果您不提供用户类，则chmod命令将使用all组作为默认值。</p>
<table>
<thead>
<tr>
<th>who</th>
<th>集合</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>user</td>
<td>文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group</td>
<td>文件所属组成员</td>
</tr>
<tr>
<td>o</td>
<td>other</td>
<td>既不是文件所有者也不是文件所属组成员的用户</td>
</tr>
<tr>
<td>a</td>
<td>all</td>
<td>所有前面三组</td>
</tr>
</tbody></table>
<p>​	what 是修改which的操作符，如下表中所示。</p>
<table>
<thead>
<tr>
<th>what</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>add</td>
<td>向文件添加权限。</td>
</tr>
<tr>
<td>-</td>
<td>remove</td>
<td>从文件删除权限。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>set exactly</td>
<td>精确设置所提供的文件权限。</td>
</tr>
</tbody></table>
<p>​	which是模式，指定文件或目录的权限，如下表所示。</p>
<table>
<thead>
<tr>
<th>which</th>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>read</td>
<td>文件的读取权限。目录的列出权限。</td>
</tr>
<tr>
<td>w</td>
<td>write</td>
<td>文件或目录的写入权限。</td>
</tr>
<tr>
<td>x（小写）</td>
<td>execute</td>
<td>文件的执行权限。允许进入目录，以及访问该目录中的文件和子目录。</td>
</tr>
<tr>
<td>X（大写）</td>
<td>special execute</td>
<td>目录的执行权限，或者文件的执行权限（如果是文件，则该文件需要至少有一个执行权限，否则不会生效）</td>
</tr>
</tbody></table>
<p>​	用于更改文件权限的符号使用字母代表不同的权限组：u表示用户，g表示组，o表示其他，a表示全部。</p>
<p>​	使用符号法时，您不需要设置一组全新的权限。取而代之，您可以更改现有的一个或多个权限，或者使用等号（&#x3D;）来替换一组权限的整个集合。</p>
<p>​	权限自身由单个字母来表示：r表示读取，w表示写入，x表示执行。只有文件是目录或者以为用户、组或其他人设置了执行权限，您才可以使用大写X作为权限标志来添加执行权限。</p>
<p>​	以下列表显示了使用符号方法更改权限的一些示例：</p>
<p>​	对于document.pdf文件，为组和其他添加删除、读取和写入权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 <span class="built_in">dir</span>]# <span class="built_in">chmod</span> go+rw document.pdf</span><br></pre></td></tr></table></figure>

<p>​	对于myscript.sh文件，为所有人添加执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 <span class="built_in">dir</span>]# <span class="built_in">chmod</span> a+x myscript.sh</span><br></pre></td></tr></table></figure>

<p>​	您可以使用chmod命令-R选项，以递归方式对整个目录树中的文件设置权限。例如下一个命令的递归方式为拥有myfolder目录的组成员以及其中的文件和目录添加读取、写入和执行权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> -R g+rwx /root/myfolder/</span><br></pre></td></tr></table></figure>

<p>​	您还可以使用chmod命令-R选项以及X选项，以符号方式设置权限。使用chmod命令X选项，您可以对目录设置执行（搜索）权限，以便在不更改大部分文件权限的情况下，访问这些目录的内容。不过，使用X选项是要谨慎，因为如果某个文件设置有任何执行权限，则X选项也将会对该文件设置指定的执行权限。</p>
<p>​	例如，以下命令会以递归方式为组所有者设置对demodir目录及其所有子文件和目录的读、写权限，但将仅向以为用户、组或其他目录设置了执行权限的目录和文件应用组执行权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> -R g+rwX demodir/</span><br></pre></td></tr></table></figure>



<h3 id="通过八进制法更改权限"><a href="#通过八进制法更改权限" class="headerlink" title="通过八进制法更改权限"></a>通过八进制法更改权限</h3><p>​	您可以使用chmod命令，通过八进制法（而非符号法）来更改文件权限。在以下实例中，#字符代表以为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod ### file|directory</span><br></pre></td></tr></table></figure>

<p>​	如果使用八进制法，您可以用三位（火灾设置高级权限时为四位）八进制数来表示权限。单个八进制数字可以表示0-7的任何单个值。</p>
<p>​	在权限的三位八进制表示法中，每一位数字表示一个访问级别，从左至右为：用户、组和其他。要确定每个数字：</p>
<ul>
<li>从0开始。</li>
<li>如果要为此访问级别添加读取权限，请加4。</li>
<li>如果要添加写入权限，请加2。</li>
<li>如果要添加执行权限，请加1。</li>
</ul>
<p>​	有经验的管理员通常使用八进制权限，因为它们更容易对单个或匹配的文件实施权限变更。并且仍然提供完整的权限控制。</p>
<p>​	以下列表显示了使用八进制法更改权限的一些示例：</p>
<p>​	对于sample.txt文件，为用户设置读取和写入权限，并为组和其他人设置读取权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chmod</span> 644 sample.txt</span><br></pre></td></tr></table></figure>

<p>​	对sampledor目录，为用户设置读取、写入和执行权限，为组设置读取和执行权限，而为其他人设置权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chmod</span> 750 sampledor</span><br></pre></td></tr></table></figure>



<h3 id="更改文件和目录的用户或组所有权"><a href="#更改文件和目录的用户或组所有权" class="headerlink" title="更改文件和目录的用户或组所有权"></a>更改文件和目录的用户或组所有权</h3><p>​	用户拥有其创建的文件。默认情况下，新文件的组所有权为创建该文件的主要用户组。在RedHat Linux 中，用户的主要组通常为仅有该用户作为成员的私有组。要根据组成员资格授予文件的访问权限，可能需要更改拥有该文件的组。</p>
<p>​	只有root用户能够更改拥有文件的用户。但是，文件的所有者和root用户可以设置组所有权。root用户可以将文件所有权授予任何组。但只有普通用户是目标组的成员才能更改文件的组所有权。</p>
<p>​	您可以使用chown（更改所有者）命令更改文件所有权。例如，要将app.conf的所有权授予user01用户，您可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user01 app.conf</span><br></pre></td></tr></table></figure>

<p>​	chown命令 -R 选项可以递归更改整个目录树的所有权。以下命令可将Pictures目录以及其下的所有文件和子目录的所有权授予给user01用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> -R user01 Pictures</span><br></pre></td></tr></table></figure>

<p>​	也可以使用chown命令更改文件的组所有权，只需要在组名称之前加上冒号（:）。例如，以下命令将Pictures目录的组所有权更改为user02：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> :user02 Pictures</span><br></pre></td></tr></table></figure>

<p>​	您可以使用chown命令也可以同时更改所有者和组，使用owner:group语法即可。例如，要将Pictures目录的所有权更改到user03用户，同时将组所有权更改为user04，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user03:user04 Pictures</span><br></pre></td></tr></table></figure>

<p>​	有些用户并不使用chown命令，而是使用chgrp命令来更改组所有权。该命令的作用与chown类似，不同之处在于，您只能用它来更改组所有权，而组名前也不需要加冒号（:）。</p>
<p>​	<code>重要：您可能会遇到chown用句点而不是冒号来分割所有者和组的情况：</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 demodir]# <span class="built_in">chown</span> user03.user04 Pictures</span><br></pre></td></tr></table></figure>

<p>​	<code>虽然同样可以更改成功，但RedHat官方不建议使用此语法，而应始终使用冒号。因为句点是用户名中有效的字符，因此chown命令可能会误解您的意图。同时命令可能会将用户和组解释为文件名。取而代之，仅可在同时设置用户和组时使用冒号字符。</code></p>
<h2 id="管理默认权限和文件访问"><a href="#管理默认权限和文件访问" class="headerlink" title="管理默认权限和文件访问"></a>管理默认权限和文件访问</h2><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>​	特殊权限是除了基本用户、组和其他类型之外的第四种特权类型。顾名思义，特殊权限提供了额外的访问相关功能，超出了基本权限类型允许的范畴。本章节介绍特殊权限的影响，具体参见下表的总结。</p>
<p><strong>特殊权限对文件和目录的影响</strong></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>u+s（suid）</td>
<td>以拥有文件的用户身份，而不是以允许文件的用户身份执行文件。</td>
<td>无影响。</td>
</tr>
<tr>
<td>g+s（sgid）</td>
<td>已拥有文件的组身份执行文件。</td>
<td>目录中创建的文件的组所有者与目录的组所有者相匹配。</td>
</tr>
<tr>
<td>o+t（sticky）</td>
<td>无影响。</td>
<td>对目录具有写入访问权限的用户仅可以删除其所拥有的文件，而无法删除或强制保存到其他用户所拥有的文件。</td>
</tr>
</tbody></table>
<p>​	对可执行文件的setuid权限表示，将以拥有该文件的用户的身份运行命令，而不是以运行命令的用户身份，以passwd为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user01@foundation0 demodir]$ <span class="built_in">ls</span> -l /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x. 1 root root 32648 Aug 10  2021 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的s字符辨别出setuid权限，此处通常是x字符（所有者执行权限）。如果所有者不具有执行权限，这个字符将由大写的S字符取代。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如该文件所有者的执行权限x是存在的</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwxr-xr-x. 1 root root 32648 Aug 10  2021 passwd</span><br><span class="line"><span class="comment"># 此时为所有者设置setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">chmod</span> 4755 passwd</span><br><span class="line"><span class="comment"># 则x将替换为小写的s，表示该文件具有执行权限以及setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwsr-xr-x. 1 root root 32648 Aug 10  2021 passwd</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前文件所有者无该x权限。</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rw-r--r--. 1 root root 32648 Aug 10  2021 passwd</span><br><span class="line"><span class="comment"># 此时为所有者无x权限去设置setuid权限</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">chmod</span> 4644 passwd</span><br><span class="line"><span class="comment"># 则由大写的S取代。</span></span><br><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l passwd </span><br><span class="line">-rwSr--r--. 1 root root 32648 Aug 10  2021 passwd</span><br></pre></td></tr></table></figure>

<p>​	对于目录的setgid特殊权限，表现在该目录中创建的文件将继承该父目录的组所有权，而不是从创建用户继承组所有权。此功能通常用于协作目录，将文件从默认的私有组自动更改为共享组，或者当文件始终都应由特定的组所使用时使用。这种行为的一个示例是&#x2F;run&#x2F;log&#x2F;journal目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -ld /run/log/journal/</span><br><span class="line">drwxr-sr-x+ 3 root systemd-journal 60 May 22 09:41 /run/log/journal/</span><br></pre></td></tr></table></figure>

<p>​	如果对可执行文件设置了setgid，则命令将以拥有该文件的用户的身份运行，而不是运行命令的用户身份。此情况类似于setuid的工作方式。以locate命令为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -l /usr/bin/locate </span><br><span class="line">-rwx--s--x. 1 root slocate 41032 Aug 10  2021 /usr/bin/locate</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的s字符来表别出setgid，此处通常是x字符（组执行权限）。如果组不具有执行权限，这个字符将由大写的S字符取代。</p>
<p>​	最后，针对目录的粘滞位将对目录中的文件删除设置特殊限制。只有文件的所有者（及root用户）才能删除该目录中的文件。一个示例是&#x2F;tmp目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 bin]# <span class="built_in">ls</span> -ld /tmp/</span><br><span class="line">drwxrwxrwt. 21 root root 4096 May 22 16:17 /tmp/</span><br></pre></td></tr></table></figure>

<p>​	在长列表中，您可以通过小写的t字符辨别出粘滞位权限，此处通常是x字符（其他人执行权限）。如果其他人不具备执行权限，这个字符将由大写的T字符取代。</p>
<p>​	<strong>设置特殊权限</strong></p>
<ul>
<li>符号：setuid&#x3D;u+s；setgid&#x3D;g+s；粘滞位&#x3D;o+t</li>
<li>八进制：添加在三个序位前；setuid&#x3D;4；setgid&#x3D;2；粘滞位&#x3D;1</li>
</ul>
<p>​	特殊权限示例通过使用符号法在example目录中添加setgid位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-xr-x. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> g+s example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	通过使用符号法删除example目录上的setuid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwsr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> u-s example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxr-sr-x. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	使用八进制法，对example目录设置setgid位，并为用户和组添加读取、写入和执行权限，但其他用户不具备任何访问权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxr--r--. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> 2770 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxrws---. 2 user02 user04 6 May 22 17:09 example/</span><br></pre></td></tr></table></figure>

<p>​	使用八进制法，对example目录删除setgid位，并未用户和组添加读取、写入和执行权限，但其他人不具备任何访问权限。请注意，使用八进制法删除特殊权限时，您需要在权限值的开头添加额外的0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example/</span><br><span class="line">drwxrws---. 2 user02 user04 6 May 22 17:09 example/</span><br><span class="line">[root@foundation0 ~]# <span class="built_in">chmod</span> 00770 example </span><br><span class="line">[root@foundation0 ~]# <span class="built_in">ls</span> -ld example</span><br><span class="line">drwxrwx---. 2 user02 user04 6 May 22 17:09 example</span><br></pre></td></tr></table></figure>



<h3 id="默认文件权限"><a href="#默认文件权限" class="headerlink" title="默认文件权限"></a>默认文件权限</h3><p>​	在创建时，文件被分配初始权限。有两个因素会影响这些初始权限。其一是您要创建的是常规文件还是目录。其二是当前的umask，它代表用户文件创建掩码。</p>
<p>​	如果创建目录，则其初始八进制权限为0777（drwxrwxrwx）。如果您创建常规文件，则其初始八进制权限为0666（-rw-rw-rw-）。必须始终不为常规文件添加执行权限。这一步可使攻击者更难破坏系统，创建和运行恶意文件</p>
<p>​	此外，shell会话会设置umask，进一步限制文件的初始权限。umask是一个八进制位掩码，可以清除由进程创建的新文件和目录的权限。如果在umask中设置了一个位，则新文件中的对应的权限将被清楚。例如，umask 0002 可清楚其他用户的写入位。前导零表示特殊权限、用户和组权限未被清楚。umask为0077时，清楚新创建文件的所有组和其他权限。</p>
<p>​	不带参数运行umask命令可显示当前shell的umask值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@foundation0 ~]# <span class="built_in">umask</span> </span><br><span class="line">0022</span><br></pre></td></tr></table></figure>

<p>​	通过一个八进制参数使用umask命令，可以更改当前shell的umask。该参数应当是与新umask值对应的八进制值。umask中第一个特殊权限的前导零均可以省略。例如，umask 077与umask 0077相同。</p>
<p>​	Bash shell用户的系统默认 umask值在 &#x2F;etc&#x2F;login.defs和&#x2F;etc&#x2F;bashrc文件中定义。普通用户可以在其主目录的 .bash_profile 或 .bashrc 文件中覆盖系统默认值。</p>
<p>​	<code>重要：在RedHat Linux 8和更早的版本中，如果用户账户的UID为200或更大的值，并且用户名和账户的主要组相同，则默认的umask为0002.否则，其默认的umask为0022.</code></p>
<p>​	<code>红帽RedHat Linux 9正更改了这一设定，所有账户的umask都为0022。当您启动登录shell时，您的umask为0022。但是，当您启动交互式非登录shell时（例如当您在图形UI中启动gnome-terminal时），如果您账户的UID为200或更大值，并且您的主要组与您的用户账户同名，则您的umask为0002。未来RedHat会将所有用户都更改为同样的0022。</code></p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250522182353825.png" alt="image-20250522182353825"></p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250522182245664.png" alt="image-20250522182245664"></p>
<h3 id="umask使用程序对权限的影响"><a href="#umask使用程序对权限的影响" class="headerlink" title="umask使用程序对权限的影响"></a>umask使用程序对权限的影响</h3><p>​	以下示例说明umask如何影响文件合目录的权限。查看当前shell中文件和目录的默认umask权限。<code>重要：假设umask当前值为0022。</code></p>
<p>​	如果您创建常规文件，则其初始八进制权限为0666（二进制表示为 000 110 110 110）。然后0022的umask（000 000 010 010）将禁用组合其他对象的写入权限位。因此，所有者对文件具有读取和写入权限，组合其他对象设置为读取权限（000 110 100 100）.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> </span><br><span class="line">0022</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> test.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l test.txt </span><br><span class="line">-rw-r--r--. 1 kiosk kiosk 0 May 23 14:40 test.txt</span><br></pre></td></tr></table></figure>

<p>​	如果创建目录，则其初始的八进制权限为0777（000 111 111 111）.然后umask为0022（000 000 010 010）将禁用组和其他对象的写入权限位。因此所有者对目录具有读取、写入和执行权限，组合其他对象设置为读取和执行权限（000 111 101 101）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> </span><br><span class="line">0022</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> default</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld default/</span><br><span class="line">drwxr-xr-x. 2 kiosk kiosk 6 May 23 14:44 default/</span><br></pre></td></tr></table></figure>

<p>​	通过将umask值设置为0，其他用户的文件权限将从读取改为读取和写入。其他用户的目录权限将从读取和执行改为读取、写入和执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 0</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> zero.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l zero.txt </span><br><span class="line">-rw-rw-rw-. 1 kiosk kiosk 0 May 23 17:21 zero.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> zero </span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld zero</span><br><span class="line">drwxrwxrwx. 2 kiosk kiosk 6 May 23 17:22 zero</span><br></pre></td></tr></table></figure>

<p>​	要屏蔽其他用户的所有文件和目录权限，请将umask值设置为007。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 007</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l seven.txt </span><br><span class="line">-rw-rw----. 1 kiosk kiosk 0 May 23 17:23 seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> seven</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld seven</span><br><span class="line">drwxrwx---. 2 kiosk kiosk 6 May 23 17:23 seven</span><br></pre></td></tr></table></figure>

<p>​	umask为027可确保用户对新文件具有读写权限，组具有读取权限。组对新目录具有读取和执行权限，而其他用户则没有任何权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">umask</span> 027</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">touch</span> two-seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -l two-seven.txt</span><br><span class="line">-rw-r-----. 1 kiosk kiosk 0 May 23 17:27 two-seven.txt</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">mkdir</span> two-seven</span><br><span class="line">[kiosk@foundation0 ~]$ <span class="built_in">ls</span> -ld two-seven</span><br><span class="line">drwxr-x---. 2 kiosk kiosk 6 May 23 17:28 two-seven</span><br></pre></td></tr></table></figure>



<h3 id="更改默认权限"><a href="#更改默认权限" class="headerlink" title="更改默认权限"></a>更改默认权限</h3><p>​	在RedHat Linux 9中，&#x2F;etc&#x2F;logindefs文件为用户设置默认的umask。默认情况下，其umask行指定的默认umask为0022。</p>
<p>​	在RedHat Linux 9.0和9.1中，这只影响登录shell。如果您启动新的终端窗口或以其他方式启动交互式飞登录shell，&#x2F;etc&#x2F;bashrc中的设置仍然适用。对于这些shell，如果账户UID为200或更大值，并且用户名和主要组名相同，就会向账户分配一个值为0002的umask。否则，其umask为0022。</p>
<p>​	root用户可以通过在&#x2F;etc&#x2F;profile.d&#x2F;目录中添加local-umask.sh的shell启动脚本来更改交互式非登录shell的默认umask。以下示例显示了一个local-umask.sh文件。</p>
<p><img src="/2025/05/20/01-RHCE/01-124/Linux-RHCE-124-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%8A%82/image-20250523175818661.png" alt="image-20250523175818661"></p>
<p>​	对于UID大于199且用户名和主要组相匹配的用户，上面的示例会将umask设置为0007，其余全部设置为0022。（前导零可以省略）如果想将所有人的umask都设置为0022，可以使用以下内容创建该文件。</p>
<p>总结：交互式非登录bashrc生效，交互式登录bash_profile生效。</p>
<p>​	可以通过shopt login_shell验证是否是登录还是非登录，如果为on则表示当前是登录式，off则是非登录式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ shopt login_shell </span><br><span class="line">login_shell    	on</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>RHCE</category>
      </categories>
      <tags>
        <tag>RHCE</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA-kubernetes-第三章</title>
    <url>/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Kubectl语法"><a href="#Kubectl语法" class="headerlink" title="Kubectl语法"></a>Kubectl语法</h1><p>​	一旦K8s集群搭建完成后，我们就可以再其部署容器化应用。在此之前我们需要先了解，kubectl的语法，以便后续管理和维护k8s集群。</p>
<p>​	kubectl命令的常见格式是：<code>kubectl action resource [parameter]</code>。</p>
<ul>
<li>kubectl：二进制执行文件。</li>
<li>action：操作选项。</li>
<li>resource：资源类型。</li>
<li>parameter（可选）：参数。</li>
</ul>
<p>​	这会对指定的资源（类似node或deployment）执行指定的操作（类似create、describe或delete）。您可以再子命令后面使用 <code>--help</code>获取可能参数相关的更多信息。kubectl get nodes –help</p>
<p>​	示例：创建一个deployment类型的资源，创建的资源名称为deployment-nginx，所引用的镜像为nginx，查询刚创建名为deployment-nginx的deployment资源类型，当前启动了0个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create deployment deployment-nginx --image nginx </span><br><span class="line">deployment.apps/deployment-nginx created</span><br><span class="line"><span class="comment"># 创建资源成功，但是READY启动了0个pod</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get deployments.apps deployment-nginx </span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment-nginx   0/1     1            0           2m</span><br><span class="line"><span class="comment"># 稍等一会在查，READY已经1/1，那是因为在这过程中他回去先拉取镜像，是需要等一会的</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get deployments.apps deployment-nginx </span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment-nginx   1/1     1            1           8m48s</span><br><span class="line"><span class="comment"># 想要查看资源创建详情可通过describe选项</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl describe deployments.apps deployment-nginx </span><br><span class="line">Name:                   deployment-nginx</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 14 Jul 2025 16:44:03 +0800</span><br><span class="line">Labels:                 app=deployment-nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               app=deployment-nginx</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=deployment-nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:         nginx</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Environment:   &lt;none&gt;</span><br><span class="line">    Mounts:        &lt;none&gt;</span><br><span class="line">  Volumes:         &lt;none&gt;</span><br><span class="line">  Node-Selectors:  &lt;none&gt;</span><br><span class="line">  Tolerations:     &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   deployment-nginx-f9986cddf (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  11m   deployment-controller  Scaled up replica <span class="built_in">set</span> deployment-nginx-f9986cddf from 0 to 1</span><br><span class="line"><span class="comment"># 删除刚创建的deployment</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete deployments.apps deployment-nginx </span><br><span class="line">deployment.apps <span class="string">&quot;deployment-nginx&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h1><p>​	kubectl命令是正常是可以创建出服务，但是在企业实践中这是利用kubectl创建的服务通常仅用来测试或者临时的服务，因为一个完整的业务他是需要具备着很多参数，使用kubectl来创建显然不是很方便阅读，并且命令敲了是一次性的，当我要更新这个服务时，只能删除后重新进行执行，因为对于k8s来说它是没有更新的概念的，所有的更新都是删除后重新部署的。</p>
<p>​	但是我们使用yaml文件的方式进行部署版本迭代，那就可以很轻松的解决，唯一的缺点就是yaml的学习成本较高，对于初学者来说是较为困难的事情。下图为官网给出的一个最简单的创建资源的yaml。</p>
<ul>
<li>文件内容格式要求严格。</li>
<li>大小写敏感。</li>
<li>使用缩进表达上下级关系，上下级需保持两位空格缩进。</li>
<li>缩进时不允许使用tab，只能使用空格进行缩进。</li>
<li>#号为注释，不作为允许时的代码。</li>
<li>键值对（key:value）用冒号分割，value不允许紧挨着冒号，需要空一个书写value。</li>
<li>列表类型的value需要回车用-（减号）加一个空格来表示，多个列表使用同级缩进进行表示为一组列表。</li>
<li>文件已yaml和yml后缀作为文件名。</li>
</ul>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714172355789.png" alt="image-20250714172355789"></p>
<p>​	虽然有些复杂，但是我们可以通过帮助<code>explain</code>选项帮助我们查询它所具备的参数及用法。</p>
<p>​	例如：<code>kubectl explain pod</code></p>
<p>​	查询pod资源下存在如图标记出的key选项。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714173015446.png" alt="image-20250714173015446"></p>
<p>​	<code>kubectl explain pod.spec</code>下有具备如下图众多选项，命令中的上下级使用.（点）来表示，yaml文件中的上下级通过换行缩进两格进行表示。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714173220277.png" alt="image-20250714173220277"></p>
<p>​	</p>
<p>​	如果您对kubectl很熟悉，也可以通过kubectl来主动帮您生成yaml，仅需在写好的kubectl后加上<code>--dry-run=client -o yaml</code>参数即可，添加后您的这条语句不会正真执行操作，而是将它转化为yaml进行输出，具体示例参考下方代码。</p>
<p>​	kubectl创建一个名为deployment-nginx的deployment类型资源，镜像使用nginx，<code>--replicas 3</code>生成3个副本（Pod），<code>--dry-run=client -o yaml</code>模拟运行到客户端，已yaml的方式进行输出，这样我们就很轻松的完成一个yaml了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create deployment deployment-nginx --image nginx --replicas 3 --dry-run=client -o yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: deployment-nginx</span><br><span class="line">  name: deployment-nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: deployment-nginx</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: deployment-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">status: &#123;&#125;</span><br><span class="line">[root@k8s-master-01 ~]#</span><br></pre></td></tr></table></figure>

<p>​	<strong>注：Kind代表你要操作的资源类型，apiVersion代表这个资源的版本，metadata下的内容代表着这个资源的具体操作内容，apiVersion并不都是v1，下表中介绍版本中各不同的表示。</strong></p>
<table>
<thead>
<tr>
<th>Alpha</th>
<th>Beta</th>
<th>Stable</th>
</tr>
</thead>
<tbody><tr>
<td>1、版本名称包含了Alpha。</td>
<td>1、版本名称包含了Beta。</td>
<td>1、版本名称是vX，其中X是整数。</td>
</tr>
<tr>
<td>2、可能是由缺陷的。启用该功能可能会带来问题，默认是关闭的。</td>
<td>2、代码进行测试过。启动该功能认为是安全的，默认是启用。</td>
<td>2、功能和稳定版本将出现在许多后续版本的发行软件中。</td>
</tr>
<tr>
<td>3、支持的功能可能在没有通知的情况下随时删除。</td>
<td>3、所有以支持的功能不会被删除，细节可能发生变化。</td>
<td>3、有时候也会被称为GA或者毕业等词汇。</td>
</tr>
<tr>
<td>4、API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</td>
<td>4、对象的模式和语义可能会在后续的Beta测试版或稳定版中以不兼容的方式进行更改。</td>
<td></td>
</tr>
<tr>
<td>5、由于BUG风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</td>
<td>5、建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。如果您有多个可以独立升级的集群，则可以放款此限制。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="API-and-RESOURCES"><a href="#API-and-RESOURCES" class="headerlink" title="API and RESOURCES"></a>API and RESOURCES</h1><p>​	我们前面简单以pod、deployment资源进行了演示，那么我们这个k8s到底还存在着哪些API功能呢？</p>
<p>​	可以通过：<code>kubectl api-resources</code>命令进行查看。</p>
<ul>
<li>NAME：资源名称，通常用于kubectl中表示资源类型的名称。</li>
<li>SHORTNAMES：资源名称缩写，通常用于kubectl中表示资源类型的名称缩写。</li>
<li>APIVERSION：API版本，通常用于表示这每个资源的稳定情况及预示后续版本可能会带来的某些变化。</li>
<li>NAMESPACED：代表着这个资源的命名空间作用域范围。<ul>
<li>True表示只作用于所创建隶属于哪个命名空间的范围。</li>
<li>False表示该资源创建后作用域整个集群。</li>
</ul>
</li>
<li>KIND：资源类型，通常用于Yaml中表示要操作的资源类型。</li>
</ul>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250714174333125.png" alt="image-20250714174333125"></p>
<p>​	<strong>注：NAMESPACED其实主要的作用就是在您写Yaml时，如果是True那您就需要在metadata下写明该资源要创建到哪个命名空间中，作用域这个小范围，如果是False则无需写明，因为他的作用域是集群的全局，写不写意义不大。</strong></p>
<h1 id="Kubernetes与docker的关系"><a href="#Kubernetes与docker的关系" class="headerlink" title="Kubernetes与docker的关系"></a>Kubernetes与docker的关系</h1><p>​	在之前我们介绍过，当您使用了K8s那我们就从一个打螺丝的一线员工晋升为领导了，我们所有操作都是通过master节点中的kubelet下发指令然后通过kube-api向node节点中的kubelet发送指令，翻译成docker的语言，让docker干活，node节点中的kubelet就处于一个监工的角色。以下用一个示例来演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里我们通过master节点创建了一个资源，让docker去生成一个httpd的容器。</span></span><br><span class="line"><span class="comment"># 这里k8s告诉我资源已经创建成功，但是容器是否有创建成功我们不知道。</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl create deployment httpd-01 --image httpd</span><br><span class="line">deployment.apps/httpd-01 created</span><br><span class="line"><span class="comment"># 可以通过如下命令看到READY1/1说明运行了一个容器，一个容器正在运行中</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl get deployments.apps </span><br><span class="line">NAME       READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">httpd-01   1/1     1            1           8m9s</span><br><span class="line"><span class="comment"># 我们在master上并未发现有httpd镜像</span></span><br><span class="line">[root@k8s-master-01 namespace]# docker images</span><br><span class="line">REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx                                                      latest     9592f5595f2b   3 weeks ago     192MB</span><br><span class="line">reg.liweihu.cn/calico/typha                                v3.30.2    b3baa600c7ff   4 weeks ago     85.2MB</span><br><span class="line">calico/typha                                               v3.30.2    b3baa600c7ff   4 weeks ago     85.2MB</span><br><span class="line"><span class="comment"># master上并未发现有httpd容器在运行</span></span><br><span class="line">[root@k8s-master-01 namespace]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                         COMMAND                   CREATED       STATUS       PORTS     NAMES</span><br><span class="line">ba8132dd4b57   1cf5f116067c                                  <span class="string">&quot;/coredns -conf /etc…&quot;</span>   6 hours ago   Up 6 hours             k8s_coredns_coredns-dc6b59956-bfgfb_kube-system_962eb48f-da7c-40b4-be9d-2a4420322173_8</span><br><span class="line">7f4c39926348   1cf5f116067c                                  <span class="string">&quot;/coredns -conf /etc…&quot;</span>   6 hours ago   Up 6 hours             k8s_coredns_coredns-dc6b59956-72kvq_kube-system_de1ba00e-bac3-4d96-8e5c-90d523cdac40_8</span><br></pre></td></tr></table></figure>

<p>​	我们说过，master是管理节点是一个领导的角色，领导是不会在一线打螺丝的，所以我们所创建的容器肯定是在node节点上去运行的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在node1节点上我们发现了httpd被拉下来的镜像</span></span><br><span class="line">[root@k8s-node-01 ~]# docker images</span><br><span class="line">REPOSITORY                                    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx                                         latest    22bd15417453   6 days ago      192MB</span><br><span class="line">httpd                                         latest    90f191b9781e   10 days ago     148MB</span><br><span class="line"><span class="comment"># 并且我们所创建的httpd的容器也是在node1上运行的</span></span><br><span class="line">[root@k8s-node-01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                         COMMAND                   CREATED         STATUS         PORTS     NAMES</span><br><span class="line">fa97240d5022   httpd                                         <span class="string">&quot;httpd-foreground&quot;</span>        5 minutes ago   Up 5 minutes             k8s_httpd_httpd-01-6797c85b9f-csrjb_book-k8s_3ac3ff31-78de-45b3-8ca0-c40edd15c2e1_0</span><br></pre></td></tr></table></figure>



<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>​	在Kubernetes中，命名空间（Namespace）提供了一种机制，将同一集群中的资源划分为相互隔离的组。同一命名空间的内的资源名称要唯一，但跨命名空间时没这个要求。命名空间作用域仅针对带有命名空间的对象，（例如Deployment、Service等），这种作用域对集群范围的对象（例如StorageClass、Node）PersistentVolume 等）不适用，这一点也就是上段文章内容中介绍的<code>kubectl api-resources</code>命令查看到的Namespace字段，True表示适用命名空间，False表示不适用。</p>
<h2 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h2><p>​	命名空间适用于存在很多个团队或项目的用户场景，对于只有几个到十几个用户的群体，可以不需要考虑命名空间。如果业务和团队合作时确实需要，请开始使用它们。</p>
<p>​	命名空间为命名提供了一个范围。资源的名称需要在命名空间内是唯一的，但不能跨命名空间。命名空间不能相互嵌套，每个Kubernetes资源只能在一个命名空间中。</p>
<p>​	命名空间是在多个用户质检划分集群资源的一种方式（通过资源配额）。</p>
<p>​	不必使用多个命名空间来分割仅仅轻微不同的资源，例如同一软件的不同版本：应该使用标签来区分同一命名空间中的不同资源。</p>
<p>​	在Kubernetes集群中会分别会自动创建四个命令空间，我们可以使用以下命令进行查看当前集群中存在哪些命名空间。</p>
<ul>
<li>default：Kubernetes包含这个命名空间，以便于您无需创建新的命名空间即可开始使用新集群，同时当您在创建资源为指定命名空间时，默认会创建在改命名空间下。</li>
<li>kube-node-lease：该名字空间包含用于与各个节点关联的 Lease（租约）对象。 节点租约允许 kubelet 发送心跳， 由此控制面能够检测到节点故障。该命名空间下主要包含的资源是leases。</li>
<li>kube-public：所有的客户端（包括未经身份验证的客户端）都可以读取该名字空间。 该名字空间主要预留为集群使用，以便某些资源需要在整个集群中可见可读。 该名字空间的公共属性只是一种约定而非要求。</li>
<li>kube-system：该名字空间用于 Kubernetes 系统集群类资源创建的对象。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get namespaces</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   12d</span><br><span class="line">kube-node-lease   Active   12d</span><br><span class="line">kube-public       Active   12d</span><br><span class="line">kube-system       Active   12d</span><br><span class="line">tigera-operator   Active   10d</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：tigera-operator并非集群初始化的命名空间，而是Calico官方操作Kubernetes所创建的命名空间，用于创建管理Calico网络策略和配置资源的。</strong></p>
<p>​	<strong>重要：对于生产环境，请考虑不要使用default命名空间，而是创建其他具有项目意义的名字来使用。</strong></p>
<h2 id="创建一个具有项目意义的命名空间"><a href="#创建一个具有项目意义的命名空间" class="headerlink" title="创建一个具有项目意义的命名空间"></a>创建一个具有项目意义的命名空间</h2><p>​	以下我们将要创建一个属于我们项目独有、具有识别意义的命名空间，之后我们的大部分资源创建操作都将在该命名空间中。</p>
<ul>
<li>创建一个名为：book-k8s的命名空间。</li>
<li>查看命名空间，检查名为book-k8s的命名空间是否存在。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create namespace book-k8s</span><br><span class="line">namespace/book-k8s created</span><br><span class="line">[root@k8s-master-01 ~]# </span><br><span class="line">[root@k8s-master-01 ~]# kubectl get namespaces </span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">book-k8s          Active   6s</span><br><span class="line">default           Active   12d</span><br><span class="line">kube-node-lease   Active   12d</span><br><span class="line">kube-public       Active   12d</span><br><span class="line">kube-system       Active   12d</span><br><span class="line">tigera-operator   Active   10d</span><br></pre></td></tr></table></figure>

<p><strong>Yaml的方式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建yaml文件</span></span><br><span class="line">[root@k8s-master-01 namespace]# <span class="built_in">cat</span> &gt;&gt; create-names.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Namespace</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: book-k8s</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 执行yaml文件</span></span><br><span class="line">[root@k8s-master-01 namespace]# kubectl create -f create-names.yaml </span><br><span class="line">namespace/book-k8s created</span><br></pre></td></tr></table></figure>



<h2 id="为创建资源设置命名空间"><a href="#为创建资源设置命名空间" class="headerlink" title="为创建资源设置命名空间"></a>为创建资源设置命名空间</h2><p>​	目前我们已经创建了一个名为book-k8s的命名空间，接下来我们需要在该命名空间中创建第一个项目资源Pod。</p>
<ul>
<li>​	使用yaml或kubectl的方式创建一个Pod并指定该资源运行在book-k8s命名空间中。</li>
<li>查看资源是否正常运行中。</li>
</ul>
<p><strong>kubectl的方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为nginx的Pod，使用Nginx镜像，该资源在book-k8s命名空间下运行。</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl run nginx --image nginx --namespace book-k8s </span><br><span class="line">pod/nginx created</span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods</span><br><span class="line">No resources found <span class="keyword">in</span> default namespace.</span><br></pre></td></tr></table></figure>

<p><strong>Yaml语法：可以使用–dry-run&#x3D;client -o yaml快速生成，但在学习阶段不建议使用该方式，能使用explain进行编写是最好的。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl run nginx --image nginx --namespace book-k8s --dry-run=client -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    run: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">  namespace: book-k8s</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx</span><br><span class="line">    name: nginx</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们创建了一个Pod，在book-k8s命名空间下，但是我们使用<code>kubectl get pods</code>命令查看Pod是否在正常运行时提示了，在default（默认命名空间）中未发现任何资源。</p>
<p>​	这就是之前说的，default是默认的命名空间，当你不管是创建还是查询资源时未指定命名空间，默认是使用的default命名空间。所以本示例中我们在需要指定一下命名空间，或者使用<code>-A</code>选项，显示所有命名空间下的该类型资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有命名空间下的Pods资源类型</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS    RESTARTS       AGE</span><br><span class="line">book-k8s      nginx                                      1/1     Running   0              11m</span><br><span class="line">kube-system   calico-kube-controllers-7f59498f59-kf5nn   1/1     Running   7 (40m ago)    10d</span><br><span class="line">kube-system   calico-node-7ndvs                          1/1     Running   7              10d</span><br><span class="line">....忽略....</span><br><span class="line"><span class="comment"># 显示book-k8s命名空间下的pods资源</span></span><br><span class="line"><span class="comment"># -n为--namespace的缩写</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods -n book-k8s </span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          12m</span><br></pre></td></tr></table></figure>



<h2 id="设置命名空间偏好（修改默认命名空间）"><a href="#设置命名空间偏好（修改默认命名空间）" class="headerlink" title="设置命名空间偏好（修改默认命名空间）"></a>设置命名空间偏好（修改默认命名空间）</h2><p>​	如果您仅有这一个命名空间，认为每次查询或创建时都需要指定命名空间较为麻烦，您可以使用以下命令，将默认命名空间修改为您所指定的命名空间，但是这样也会伴随着一些失误，导致您之后操作集群时误操作风险。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config为k8s的配置项，修改k8s的配置上下文。</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl config set-context --current --namespace=book-k8s</span><br><span class="line">Context <span class="string">&quot;kubernetes-admin@kubernetes&quot;</span> modified.</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl config view --minify | grep namespace:</span><br><span class="line">    namespace: book-k8s</span><br><span class="line"><span class="comment"># 再度不加命名空间，发现他默认就是查询的book-k8s下的资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods </span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          21m</span><br></pre></td></tr></table></figure>



<h2 id="删除命令空间"><a href="#删除命令空间" class="headerlink" title="删除命令空间"></a>删除命令空间</h2><p>​	当您需要删除命名空间时，可使用delete选项进行删除，如果改命名空间下存在资源，则会连通资源一并进行删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 namespace]# kubectl delete namespaces book-k8s </span><br><span class="line">namespace <span class="string">&quot;book-k8s&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p>​	如果您是使用yaml创建的资源，也可以使用创建资源时所使用的yaml文件进行删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 namespace]# kubectl delete -f create-names.yaml</span><br><span class="line">namespace <span class="string">&quot;book-k8s&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="关于Pod"><a href="#关于Pod" class="headerlink" title="关于Pod"></a>关于Pod</h1><p>​	Pod是可以再Kubernetes中创建和管理的最小单元、最小的可部署的计算单位。</p>
<p>​	Pod（就像豌豆荚）是一组（一个或多个）容器；这些容器恭喜昂存储、网络、以及怎样运行这些容器的规约。Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250721180834032.png" alt="image-20250721180834032"></p>
<p>​	之前我们说微服务他是解耦合（松散耦合），这里又提到Pod是精密耦合，这是不冲突的，对于项目的拆解是属于解耦合，但是他们实际在运行中跟豌豆荚中的豆一样，他们的关系是紧密相连的。同时你的一个项目不可能拆分的特别细，不可能细到一个把报表一个容器，只是拆分的相对精细。</p>
<p><strong>Kubernetes 集群中的 Pod 主要有两种用法：</strong></p>
<ul>
<li><strong>运行单个容器的 Pod</strong>：每个 Pod 一个容器模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>
<li><strong>运行多个协同工作的容器的 Pod</strong>： Pod 可以封装由紧密耦合且需要共享资源的多个并置容器组成的应用。 这些位于同一位置的容器构成一个内聚单元。</li>
</ul>
<p>​	将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</p>
<h2 id="使用Pod"><a href="#使用Pod" class="headerlink" title="使用Pod"></a>使用Pod</h2><p>​	以下是一个Pod的示例，它由一个运行镜像nginx:latest的容器组成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pod-01.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-01</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx-01</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    ports: </span></span><br><span class="line"><span class="string">    - name: nginx-01-ports</span></span><br><span class="line"><span class="string">      containerPort: 80</span></span><br><span class="line"><span class="string">      protocol: TCP</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	要创建上面显示的Pod，请允许以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pod-01.yaml</span><br></pre></td></tr></table></figure>

<p>​	Pod通常不用于直接创建，而是使用工作负载资源进项创建。</p>
<h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><p>​	本页讲述 Pod 的生命周期。 Pod 遵循预定义的生命周期，起始于 Pending 阶段， 如果至少其中有一个主要容器正常启动，则进入 Running，之后取决于 Pod 中是否有容器以失败状态结束而进入 Succeeded 或者 Failed 阶段。</p>
<p>​	和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（UID）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。 如果一个节点死掉了，调度到该节点的 Pod 也被计划在给定超时期限结束后删除。</p>
<p>​	在 Pod 运行期间，kubelet 能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的状态并确定使 Pod 重新变得健康所需要采取的动作。</p>
<p>​	Pod 在其生命周期中只会被调度一次。 将 Pod 分配到特定节点的过程称为绑定，而选择使用哪个节点的过程称为调度。 一旦 Pod 被调度并绑定到某个节点，Kubernetes 会尝试在该节点上运行 Pod。 Pod 会在该节点上运行，直到 Pod 停止或者被终止； 如果 Kubernetes 无法在选定的节点上启动 Pod（例如，如果节点在 Pod 启动前崩溃）， 那么特定的 Pod 将永远不会启动。</p>
<p>​	以下我们使用一个示例来演示：</p>
<p>​	注：imagePullPolicy为镜像拉取模式：</p>
<ul>
<li>当value为IfNotPresent时，当运行的本地节点存在镜像时，则无需额外拉取，直接使用本地镜像。</li>
<li>当value为Always时，无论节点本地是否存在镜像，都从docker配置的仓库中进行额外拉取。</li>
<li>当value为Never时，无论节点本地是否存在镜像，都从本地节点进行拉取，如果本地节点不存在该镜像，则会导致容器创建失败。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pod-02.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: nginx-02</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx-02</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	运行yaml及查询资源状态使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pod-02.yaml</span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pod-02.yaml </span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-02   1/1     Running   0          9s</span><br></pre></td></tr></table></figure>

<p>​	最开始Pod的状态是Pending（等待执行），期间会去拉取镜像、运行镜像，当容器处于运行中时，状态则会变成Running，如果容器已失败运行结束，则会变成Failed，反之成功则会边成Succeeded（完成）。</p>
<h2 id="根容器"><a href="#根容器" class="headerlink" title="根容器"></a>根容器</h2><p>​	当我们创建了一个Pod，该Pod里拥有2个容器，那您可能会认为这个Pod里仅有两个容器，实则不然，其实该Pod拥有三个容器，其中一个容器叫做根容器（Pause）。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250722160242947.png" alt="image-20250722160242947"></p>
<p>​	之前我们介绍过，pod是由一个或多个容器组成的，他们共享网络、存储。并且生命周期是一起启动一起停止等等，该根容器就是负责这个Pod中的多个Pod网络、存储共享、生命周期一起启动或停止等。</p>
<p>​	下图中我们可以看到，其中一个node节点中，分别由K8s创建出来的三个Pod，这三个Pod分别都对应着一个容器，同样三个Pod也会有三个根容器（Pause）。</p>
<p><img src="/2025/07/14/03-Kubernetes/CKA-kubernetes-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20250722160604659.png" alt="image-20250722160604659"></p>
<h2 id="创建多容器Pod"><a href="#创建多容器Pod" class="headerlink" title="创建多容器Pod"></a>创建多容器Pod</h2><p>​	上面我们采用的都是单容器对应一个pod进行创建，另外一个Pod可以对应多个容器，以下示例进行演示：</p>
<p>​	对于一个Pod包含多个容器，只需要在containers下在写一个容器列表描述。</p>
<p>​	其中pod.spec下的restartPolicy参数，表示pod重启的策略模式。</p>
<ul>
<li>OnFailure： 只有在容器错误退出（退出状态非零时）才会重启。</li>
<li>Never： 从不会重启，即使失败或是完成终止都不会重启。</li>
<li>Always： 只要容器终止就自动重启容器。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; pods-01.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">metadata: </span></span><br><span class="line"><span class="string">  name: pods-01</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec: </span></span><br><span class="line"><span class="string">  containers: </span></span><br><span class="line"><span class="string">  - name: nginx</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">  - name: ubuntu</span></span><br><span class="line"><span class="string">    image: ubuntu:latest</span></span><br><span class="line"><span class="string">    command: [&#x27;sh&#x27;,&#x27;-c&#x27;,&#x27;echo &quot;hello lwh&quot; &amp;&amp; sleep 3600&#x27;]</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">  restartPolicy: OnFailure</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	以下命名可以运行yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f pods-01.yaml </span><br><span class="line">pod/pods-01 created</span><br></pre></td></tr></table></figure>

<p>​	以下命令可以查询资源运行情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前状态就是处于Pending中的一环，正在创建容器，也就是正在拉取容器，如果您本地没有镜像，这拉取需要等待一段时间。</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pods-01.yaml </span><br><span class="line">NAME      READY   STATUS              RESTARTS   AGE</span><br><span class="line">pods-01   0/2     ContainerCreating   0          9s</span><br><span class="line"><span class="comment"># 过一段时间以后即可处于Running</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f pods-01.yaml </span><br><span class="line">NAME      READY   STATUS    RESTARTS   AGE</span><br><span class="line">pods-01   2/2     Running   0          2m23s</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：Pod实际上是不支持重启的，Pod只支持创建、删除，所以这里说的重启并非真正意义上的重启，而是删除后重新创建达到的一个重启效果。</strong></p>
<h2 id="修改Pod"><a href="#修改Pod" class="headerlink" title="修改Pod"></a>修改Pod</h2><p>​	原则上Pod是不能修改的，但是官方并没有说Pod不能修改，而是可修改的内容及其有限，几乎达到了不能修改的级别。</p>
<p>​	修改etcd数据，可以使用以下命令，之后会为您打开一个vim编辑器，正常通过编辑文本的方式进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl edit -f pods-01.yaml</span><br></pre></td></tr></table></figure>



<h2 id="进入容器的方法"><a href="#进入容器的方法" class="headerlink" title="进入容器的方法"></a>进入容器的方法</h2><p>​	如果要通过pod进入容器，与docker类似，使用以下命令：</p>
<ul>
<li>exec：执行容器命令的选项。</li>
<li>-it：交互式访问容器。</li>
<li>pods&#x2F;pods-01： 指定进入哪个Pod</li>
<li>-c nginx：如该pod存在多个容器，则需指定pod中的哪个容器名。</li>
<li>– ：k8s中的容器命令特殊连接符号。</li>
<li>&#x2F;bin&#x2F;bash：在容器中执行的bash命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl <span class="built_in">exec</span> -it pods/pods-01 -c nginx  -- /bin/bash</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">root@pods-01:/# <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>



<h2 id="删除Pod"><a href="#删除Pod" class="headerlink" title="删除Pod"></a>删除Pod</h2><p>​	如果要删除Pod可通过以下命令进行删除：</p>
<p><strong>利用创建Pod时所使用的yaml进行删除</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl delete -f pods-01.yaml </span><br><span class="line">pod <span class="string">&quot;pods-01&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>利用kubectl指定Pod进行删除</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl delete pod pods-01 </span><br><span class="line">pod <span class="string">&quot;pods-01&quot;</span> deleted</span><br></pre></td></tr></table></figure>



<h1 id="Init类型容器"><a href="#Init类型容器" class="headerlink" title="Init类型容器"></a>Init类型容器</h1><p>​	Init容器是一种特殊的容器，在Pod内的应用容器启动之前运行。Init容器可以包含一些应用镜像中不存在的实用工具和安装脚本。</p>
<p>​	您可以在Pod的规约中与用来描述应用容器的containers数组平行的位置指定Init容器。Init容器使用<code>pod.spec.initContainers</code>来进行描述。</p>
<h2 id="Init容器特点"><a href="#Init容器特点" class="headerlink" title="Init容器特点"></a>Init容器特点</h2><ul>
<li>在主容器启动前执行。</li>
<li>具有临时性，执行完成即终止。</li>
<li>kubectl get无法查看到pod。</li>
</ul>
<h2 id="使用Init容器"><a href="#使用Init容器" class="headerlink" title="使用Init容器"></a>使用Init容器</h2><p>​	以下生成了一个Yaml文件，该yaml较之前的复杂很多，以下会对yaml做些内容解析，该部分仅用理解initContainers参数，其余的volumeMounts目前稍作了解即可：</p>
<ul>
<li><strong>metadata.labels</strong>：为该Pod打上一个标签，对服务是无任何意义的，主要是便于后续资源查找筛选使用。</li>
<li><strong>metadata.containers.volumeMounts</strong>：为该容器挂载一个持久卷，向宿主机的<code>/work-dir</code>目录创建文件可映射到容器内的<code>/usr/share/nginx/html</code>目录。</li>
<li><strong>metadata.spec.volumes</strong>：创建一个空的持久卷，持久卷名字为：<code>workdir</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; init-pods.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: my-web</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: my-web</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: my-web</span></span><br><span class="line"><span class="string">    image: nginx:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">    - name: workdir</span></span><br><span class="line"><span class="string">      mountPath: /usr/share/nginx/html</span></span><br><span class="line"><span class="string">  initContainers:</span></span><br><span class="line"><span class="string">  - name: my-service</span></span><br><span class="line"><span class="string">    image: busybox:latest</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">    command:</span></span><br><span class="line"><span class="string">    - wget</span></span><br><span class="line"><span class="string">    - &quot;-O&quot;</span></span><br><span class="line"><span class="string">    - &quot;/work-dir/index.html&quot;</span></span><br><span class="line"><span class="string">    - http://info.cern.ch</span></span><br><span class="line"><span class="string">    volumeMounts:</span></span><br><span class="line"><span class="string">    - name: workdir</span></span><br><span class="line"><span class="string">      mountPath: &quot;/work-dir&quot;</span></span><br><span class="line"><span class="string">  volumes:</span></span><br><span class="line"><span class="string">  - name: workdir</span></span><br><span class="line"><span class="string">    emptyDir: &#123;&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	执行yaml文件使用如下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# kubectl create -f init-pods.yaml </span><br><span class="line">pod/my-web created</span><br></pre></td></tr></table></figure>

<p>​	yaml整个执行阶段的变化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init容器正在创建</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS     RESTARTS   AGE</span><br><span class="line">my-web   0/1     Init:0/1   0          6s</span><br><span class="line"><span class="comment"># init容器进行初始化任务中</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS            RESTARTS   AGE</span><br><span class="line">my-web   0/1     PodInitializing   0          9s</span><br><span class="line"><span class="comment"># init容器初始化完成，应用容器运行中</span></span><br><span class="line">[root@k8s-master-01 pod]# kubectl get -f init-pods.yaml </span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-web   1/1     Running   0          11s</span><br></pre></td></tr></table></figure>





<h2 id="Init容器的具体行为"><a href="#Init容器的具体行为" class="headerlink" title="Init容器的具体行为"></a>Init容器的具体行为</h2><p>以上yaml整个运行流程梳理：</p>
<ol>
<li>initContainers的初始化容器会先去执行wget下载一个index.html的文件到容器的&#x2F;work-dir&#x2F;index.html目录下，同时该init容器的&#x2F;work-dir&#x2F;目录挂载了名为workdir的持久卷，也相当于把文件下载到了这个持久卷中，执行完成后init容器会以completed状态结束。</li>
<li>containers运行的应用容器是一个nginx页面服务，该容器将持久卷workdir挂载到服务首页配置目录中，持久卷内具有一个从init容器帮我们提前完成下载的index.html的文件，最终完成整个服务的部署启动。</li>
</ol>
<p>总结：init通常用于应用服务运行前的环境检查，及先决条件配置，当先决条件满足后才会正式运行我们真正用到的容器服务。</p>
<h1 id="Sidecar类型容器"><a href="#Sidecar类型容器" class="headerlink" title="Sidecar类型容器"></a>Sidecar类型容器</h1><p>​	Sidecar容器也称为边车容器，他与主应用容器是在同一个Pod中运行的辅助性容器。Sidecar容器通过额外的辅助性服务或功能（如日志记录、监控、安全性或数据同步）来增强或扩展主应用容器的功能，而无需直接修改主应用代码。</p>
<h2 id="Sidecar容器特点"><a href="#Sidecar容器特点" class="headerlink" title="Sidecar容器特点"></a>Sidecar容器特点</h2><p>​	Sidecar具有以下特点：</p>
<ul>
<li>Sidecar并非特定类型的容器，而是一个辅助容器的概念。</li>
<li>Sidecar生命周期具有持久性。</li>
<li>Sidecar容器可被kubectl get获取到（取决于用法）</li>
<li>Pod终止时主容器会先行终止，Sidecar等待主容器终止后随之终止。</li>
</ul>
<h2 id="以init容器启动Sidecar"><a href="#以init容器启动Sidecar" class="headerlink" title="以init容器启动Sidecar"></a>以init容器启动Sidecar</h2><p>​	以下Ymal将产生具有Sidecar概念的pod，细心的可以看出，这怎么跟之前创建的Init容器一样，都具有一个containers（主容器）和initContainers（初始化容器），唯一不同的是initContainers容器里增加了一个重启策略，策略模式为Always，只要容器终止就会自动重启，这里我们先来解析以下他分别做了些什么事。</p>
<ul>
<li>​	创建了一个containers容器，使用了alpine镜像，command中每秒向容器内的&#x2F;opt&#x2F;logs.txt文件中写入”logging”内容，并挂载了一个名为data的临时卷。</li>
<li>创建了一个initContainers容器，使用了alpine镜像，并且restartPolicy（重启策略）为Always，容器停止则自动重启，command中实时查看&#x2F;opt&#x2F;logs.txt文件，并同样挂载了一个名为data的临时卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; init-Sidecar.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: myapp</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: myapp</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: myapp</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: myapp</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: myapp</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;while true; do echo &quot;logging&quot; &gt;&gt; /opt/logs.txt; sleep 1; done&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      initContainers:</span></span><br><span class="line"><span class="string">        - name: logshipper</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          restartPolicy: Always</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;tail -F /opt/logs.txt&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      volumes:</span></span><br><span class="line"><span class="string">        - name: data</span></span><br><span class="line"><span class="string">          emptyDir: &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	以下命令可运行yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create -f init-Sidecar.yaml</span><br></pre></td></tr></table></figure>

<p>​	查看效果，需要查看资源日志可使用kubectl logs [资源名] [一个pod包含多个容器则需要指定容器]：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于init容器具有重启策略的加持，会一直进行重启，所以READY的时候会发现这个pod具有两个容器</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods myapp-55d976bcf9-m4mw8 </span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myapp-55d976bcf9-m4mw8   2/2     Running   0          35m</span><br><span class="line"><span class="comment"># 正常情况下我们无法通过kubectl查看到主容器的日志文件情况</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-55d976bcf9-m4mw8 myapp</span><br><span class="line"><span class="comment"># 但是当我们指定查看辅助容器，则可以快速查看和定位到主容器服务写入的日志</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-55d976bcf9-m4mw8 logshipper </span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete -f init-Sidecar.yaml</span><br></pre></td></tr></table></figure>





<h2 id="以普通容器启动Sidecar"><a href="#以普通容器启动Sidecar" class="headerlink" title="以普通容器启动Sidecar"></a>以普通容器启动Sidecar</h2><p>​	以下Yaml与上面init启动的Sidecar是一样的，区别就是在于Sidecar辅助容器现在用普通的containers进行创建，并且<code>restartPolicy: Always</code>与containers同级，作用域是containers下的所有容器，但是这个与Sidecar没有关系，这里只是为了让该资源创建时更为健壮，不会因为停止而停止。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 pod]# <span class="built_in">cat</span> &gt; pod-Sidecar.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: myapp</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    app: myapp</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: myapp</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: myapp</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: myapp</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;while true; do echo &quot;logging&quot; &gt;&gt; /opt/logs.txt; sleep 1; done&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">        - name: logshipper</span></span><br><span class="line"><span class="string">          image: alpine:latest</span></span><br><span class="line"><span class="string">          command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;tail -F /opt/logs.txt&#x27;]</span></span><br><span class="line"><span class="string">          volumeMounts:</span></span><br><span class="line"><span class="string">            - name: data</span></span><br><span class="line"><span class="string">              mountPath: /opt</span></span><br><span class="line"><span class="string">      restartPolicy: Always</span></span><br><span class="line"><span class="string">      volumes:</span></span><br><span class="line"><span class="string">        - name: data</span></span><br><span class="line"><span class="string">          emptyDir: &#123;&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	使用以下命令进行yaml资源创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl create -f pod-Sidecar.yaml </span><br><span class="line">deployment.apps/myapp created</span><br></pre></td></tr></table></figure>

<p>​	查看效果，需要查看资源日志可使用kubectl logs [资源名] [一个pod包含多个容器则需要指定容器]：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与init生成的Sidecar概念区别在于containers生成的pods可被直观的看到，这里外面发现READY容器数量是2</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl get pods myapp-75c678fb68-r7fxm </span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myapp-75c678fb68-r7fxm   2/2     Running   0          3m38s</span><br><span class="line"><span class="comment"># 正常情况下我们无法通过kubectl查看到主容器的日志文件情况</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-75c678fb68-r7fxm myapp</span><br><span class="line"><span class="comment"># 但是当我们指定查看辅助容器，则可以快速查看和定位到主容器服务写入的日志</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl logs pods/myapp-75c678fb68-r7fxm logshipper </span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line">logging</span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line">[root@k8s-master-01 ~]# kubectl delete -f pod-Sidecar.yaml</span><br></pre></td></tr></table></figure>







<h2 id="Sidecar与init和普通容器的区别"><a href="#Sidecar与init和普通容器的区别" class="headerlink" title="Sidecar与init和普通容器的区别"></a>Sidecar与init和普通容器的区别</h2><p>​	<strong>从以上实验我们可以看出Sidecar与init的区别在于：</strong></p>
<ul>
<li>一个是可持续性运行的容器。那是因为我们加的<code>restartPolicy: Always</code>重启策略使init不会因为一次执行完成后而终止。</li>
<li>一个是为主容器做完先决运行条件后终止的容器临时在主容器启动前完成运行的容器。</li>
</ul>
<p>从以上实验我们可以看出Sidecar与普通containers的就没有区别，他就是一个普通的容器。</p>
<p>​	所以我们在开头就说Sidecar容器他只是一个概念，取决于你的用途，你的init可以用于为主容器完成先决运行条件配置、检查，也可以使用init辅助主容器持续的完成日志转发等扩展功能，而无需去修改主容器的代码。普通的containers容器也相同，你可以使用containers作为主容器，也可以使用containers辅助你另外一个主容器达到功能扩展。</p>
<p>​	就类似在一个公司会有高级程序员和程序员助理，大家都是打螺丝的员工，没有区别，而助理是为高级程序员做辅助性工作的，只是做的事情不一样而已。</p>
<p>​	<strong>重要：Pod中存在多个容器的话，并且用到了Sidecar概念时，你如果使用containers来运行这类辅助性工作的容器，里面的容器他是一起启动的，如果您需要Sidecar辅助性容器要有些延迟，在应用容器先行启动的话，建议使用initcontainers来进行创建。</strong></p>
<h2 id="Sidecar可以做什么？"><a href="#Sidecar可以做什么？" class="headerlink" title="Sidecar可以做什么？"></a>Sidecar可以做什么？</h2><p>​	一般边车容器可用来处理以下几个事件：</p>
<ul>
<li>日志代理&#x2F;转发，例如fluentd；</li>
<li>Service Mesh，比如Istio，Linkerd；</li>
<li>代理，比如Docker Ambassador；</li>
<li>探活：检查某些组件是不是正常工作；</li>
<li>其他辅助性工作，比如拷贝文件，下载文件等；</li>
</ul>
<h1 id="静态pod"><a href="#静态pod" class="headerlink" title="静态pod"></a>静态pod</h1><p><strong>正常资源创建流程</strong></p>
<p>​	<code>在此我们可以回忆一下，我们前面介绍的k8s创建一个Pod的流程，kubectl将指令发送给API，API接收到请求后，询问kube-scheduler（调度器）这个Pod适合放在哪个节点上运行，发送给API，API将资源信息存放到etcd数据库，并发送给选中节点中的kubelet，节点中的kubelet把指令翻译成docker看得懂的语言进行创建，并将创建的结果及状态反馈给API，API再将状态信息等数据存入ETCD数据库。所有的资源创建都由API进行监管</code></p>
<p>​	</p>
<p>​	<strong>而静态 Pod 在指定的节点上由 kubelet 守护进程直接管理，不需要 API 服务器监管。</strong> 与由控制面管理的 Pod（例如，Deployment） 不同；kubelet 监视每个静态 Pod（在它失败之后重新启动）。</p>
<p>​	静态 Pod 始终都会绑定到特定节点的 Kubelet 上。</p>
<p>​	既然静态Pod不能API所监管，那么我们为什么可以在kubectl get node的时候看见这些静态Pod呢？</p>
<p>​	kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod 自动创建一个镜像 mirror Pod。 这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。 Pod 名称将把以连字符开头的节点主机名作为后缀。</p>
<h2 id="静态Pod如何创建？"><a href="#静态Pod如何创建？" class="headerlink" title="静态Pod如何创建？"></a>静态Pod如何创建？</h2><p>​	其实静态Pod里我们很近，其实k8s中的API、controller-manager、kube-scheduler就是使用静态Pod进行部署的。我们可以发现这几个Pod他的命名格式跟静态Pod一摸一样，都是组件名+节点主机名进行命名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# kubectl get pods -A</span><br><span class="line">kube-system   kube-apiserver-k8s-master-01               1/1     Running            17 (24m ago)   17d</span><br><span class="line">kube-system   kube-controller-manager-k8s-master-01      1/1     Running            15 (24m ago)   17d</span><br><span class="line">kube-system   kube-scheduler-k8s-master-01               1/1     Running            15 (24m ago)   17d</span><br></pre></td></tr></table></figure>



<p>​	既然静态Pod是节点中的kubelet进行创建管理的，那么我们可以通过kubelet的守护进程找到静态Pod的配置文件<code>10-kubeadm.conf</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">[root@k8s-master-01 ~]# systemctl status kubelet.service </span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; preset: disabled)</span><br><span class="line">    Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">             └─10-kubeadm.conf</span><br><span class="line">....忽略....</span><br></pre></td></tr></table></figure>

<p>​	找到配置文件后，查看他的配置文件，找到他的config.yaml文件所在目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# <span class="built_in">cat</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf | grep -i Environment</span><br><span class="line">Environment=<span class="string">&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br></pre></td></tr></table></figure>

<p>​	通过它的yaml文件找到它静态Pod的yaml文件存在路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">cat</span> /var/lib/kubelet/config.yaml | grep -i staticPodPath</span><br><span class="line">staticPodPath: /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure>

<p>​	进入到静态Pod的yaml文件存在路径，发现我们的API这些静态Pod的yaml文件全都存放在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 ~]# cd /etc/kubernetes/manifests</span><br><span class="line">[root@k8s-master-01 manifests]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 root root 2572  7月  8 16:02 etcd.yaml</span><br><span class="line">-rw-------. 1 root root 3614  7月  8 16:02 kube-apiserver.yaml</span><br><span class="line">-rw-------. 1 root root 3120  7月  8 16:02 kube-controller-manager.yaml</span><br><span class="line">-rw-------. 1 root root 1673  7月  8 16:02 kube-scheduler.yaml</span><br></pre></td></tr></table></figure>

<p>​	这个staticPodPath的路径就非常有意义，所有你在该目录下创建的yaml都会直接为您创建出一个静态Pod，无需您单独去执行任何命令，以下我们就在该目录创建一个简单的Yaml来演示一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在staticPodPath路径下创建一个yaml</span></span><br><span class="line">[root@k8s-master-01 manifests]#<span class="built_in">cat</span> &gt; staticPod.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: staticpod</span></span><br><span class="line"><span class="string">  namespace: book-k8s</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">  - name: staticpod</span></span><br><span class="line"><span class="string">    image: nginx</span></span><br><span class="line"><span class="string">    imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>​	稍等一会，因为如果您当前节点的本地没有镜像它需要先拉镜像，以及kubelet会定期扫描目录中的变化。在此查询即可发现我们创建的静态资源就出现了。</p>
<p>​	这里我们发现静态Pod是以资源名-节点主机名称的方式来命名的，并且我们可以自由选择将它部署在哪个命名空间下，与我们普通Pod类似，只是创建方式，以及运行流程监管对象不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                                       READY   STATUS             RESTARTS       AGE</span><br><span class="line">book-k8s      staticpod-k8s-master-01                    1/1     Running            0              2m34s</span><br><span class="line">kube-system   calico-kube-controllers-7f59498f59-kf5nn   1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-7ndvs                          1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-l4rfm                          1/1     Running            13 (54m ago)   15d</span><br><span class="line">kube-system   calico-node-ls56h                          1/1     Running            13 (54m ago)   15d</span><br></pre></td></tr></table></figure>



<h2 id="静态Pod的用途"><a href="#静态Pod的用途" class="headerlink" title="静态Pod的用途"></a>静态Pod的用途</h2><p>​	您可以试想一下，您正常通过API创建的资源，万一哪一天API组件坏了，那么您创建的那个资源也会随着API一起全部宕机掉，但是你当前想要有一个API这个重要的组件即使坏了，也不要影响我这个Pod，那么这个时候您就可以考虑使用静态Pod进行发布。</p>
<p>​	例如：您有一个监控系统负责监控K8s集群中的各个组件以及节点的资源使用情况，那么您的这个监控系统就可以使用静态Pod进行发布，避免因为集群API损坏导致您的监控系统一同失效。</p>
<h2 id="删除静态Pod"><a href="#删除静态Pod" class="headerlink" title="删除静态Pod"></a>删除静态Pod</h2><p>​	由于静态Pod是由kubelet通过扫描静态目录，直接进行创建管理，删除也是非常简单，只需将需要删除的yaml从目录中删除即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master-01 manifests]# <span class="built_in">rm</span> -rf staticPod.yaml</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：静态Pod是无法通过kubectl delete [资源名]进行删除，因为它并非由API进行创建的，所有您无法通过该命令进行删除和管理操作，一切的操作只存在于kubelet配置的静态目录中。</strong></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
</search>
